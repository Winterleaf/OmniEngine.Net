// Copyright (C) 2012 Winterleaf Entertainment L,L,C.


using System.Text;
using WinterLeaf.Engine.Classes.Interopt;

namespace WinterLeaf.Engine
{
    sealed public partial class Omni
    {
	
/// <summary>
/// (aiConnect, S32 , 2, 20, (...)
///    @brief Creates a new AIConnection, and passes arguments to its onConnect script callback.
///    @returns The newly created AIConnection
///    @see GameConnection for parameter information
///    @ingroup AI)
/// 
/// </summary>

public int fn__aiConnect (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__aiConnect'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

return  SafeNativeMethods.mwle_fn__aiConnect(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// ( buildTaggedString, const char*, 2, 11, (string format, ...)
///    @brief Build a string using the specified tagged string format.
/// 
///    This function takes an already tagged string (passed in as a tagged string ID) and one 
///    or more additional strings.  If the tagged string contains argument tags that range from 
///    %%1 through %%9, then each additional string will be substituted into the tagged string.  
///    The final (non-tagged) combined string will be returned.  The maximum length of the tagged 
///    string plus any inserted additional strings is 511 characters.
/// 
///    @param format A tagged string ID that contains zero or more argument tags, in the form of 
///    %%1 through %%9.
///    @param ... A variable number of arguments that are insterted into the tagged string 
///    based on the argument tags within the format string.
/// 
///    @returns An ordinary string that is a combination of the original tagged string with any additional 
///    strings passed in inserted in place of each argument tag.
/// 
///    @tsexample
///       // Create a tagged string with argument tags
///       %taggedStringID = addTaggedString(\"Welcome %1 to the game!\");
/// 
///       // Some point later, combine the tagged string with some other string
///       %string = buildTaggedString(%taggedStringID, %playerName);
///       echo(%string);
/// 	@endtsexample
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see addTaggedString()
///    @see getTaggedString()
///    @ingroup Networking)
/// 
/// </summary>

public string fn__buildTaggedString (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__buildTaggedString'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);

SafeNativeMethods.mwle_fn__buildTaggedString(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( call, const char *, 2, 0, ( string functionName, string args... ) 
///    Apply the given arguments to the specified global function and return the result of the call.
///    @param functionName The name of the function to call.  This function must be in the global namespace, i.e. 
///       you cannot call a function in a namespace through #call.  Use eval() for that.
///    @return The result of the function call.
///    @tsexample
///       function myFunction( %arg )
///       {
///         return ( %arg SPC \"World!\" );
///       }
///       
///       echo( call( \"myFunction\", \"Hello\" ) ); // Prints \"Hello World!\" to the console.
///    @endtsexample
///    @ingroup Scripting )
/// 
/// </summary>

public string fn__call (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__call'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fn__call(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( commandToClient, void, 3, 22, (NetConnection client, string func, ...)
///    @brief Send a command from the server to the client
/// 
///    @param client The numeric ID of a client GameConnection
///    @param func Name of the client function being called
///    @param ... Various parameters being passed to client command
/// 
///    @tsexample
///       // Set up the client command.  Needs to be executed on the client, such as
///       // within scripts/client/client.cs
///       // Update the Ammo Counter with current ammo, if not any then hide the counter.
///       function clientCmdSetAmmoAmountHud(%amount)
///       {
///          if (!%amount)
///       	  AmmoAmount.setVisible(false);
///          else
///          {
///       	  AmmoAmount.setVisible(true);
///       	  AmmoAmount.setText(\"Ammo: \"@%amount);
///          }
///       }
///       // Call it from a server function.  Needs to be executed on the server, 
///       //such as within scripts/server/game.cs
///       function GameConnection::setAmmoAmountHud(%client, %amount)
///       {
///          commandToClient(%client, 'SetAmmoAmountHud', %amount);
///       }
///    @endtsexample
/// 
///    @ingroup Networking)
/// 
/// </summary>

public void fn__commandToClient (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19, string a20, string a21)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__commandToClient'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" \"{19}\" \"{20}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);
StringBuilder sba20 = null;
if (a20 != null)
     sba20 = new StringBuilder(a20, 1024);
StringBuilder sba21 = null;
if (a21 != null)
     sba21 = new StringBuilder(a21, 1024);

SafeNativeMethods.mwle_fn__commandToClient(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, sba20, sba21);
}
/// <summary>
/// ( commandToServer, void, 2, 21, (string func, ...)
/// 	@brief Send a command to the server.
/// 
///    @param func Name of the server command being called
///    @param ... Various parameters being passed to server command
/// 
///    @tsexample
///       // Create a standard function.  Needs to be executed on the client, such 
///       // as within scripts/client/default.bind.cs
///       function toggleCamera(%val)
///       {
///       	// If key was down, call a server command named 'ToggleCamera'
///       	if (%val)
///       		commandToServer('ToggleCamera');
///       }
///       // Server command being called from above.  Needs to be executed on the 
///       // server, such as within scripts/server/commands.cs
///       function serverCmdToggleCamera(%client)
///       {
///          if (%client.getControlObject() == %client.player)
///          {
///       	  %client.camera.setVelocity(\"0 0 0\");
///       	  %control = %client.camera;
///          }
///          else
///          {
///       	  %client.player.setVelocity(\"0 0 0\");
///       	  %control = %client.player;
///         }
///          %client.setControlObject(%control);
///          clientCmdSyncEditorGui();
///       }
///    @endtsexample
/// 
///    @ingroup Networking)
/// 
/// </summary>

public void fn__commandToServer (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19, string a20)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__commandToServer'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" \"{19}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);
StringBuilder sba20 = null;
if (a20 != null)
     sba20 = new StringBuilder(a20, 1024);

SafeNativeMethods.mwle_fn__commandToServer(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, sba20);
}
/// <summary>
/// ( echo, void, 2, 0, ( string message... ) 
///    @brief Logs a message to the console.
///    Concatenates all given arguments to a single string and prints the string to the console. 
///    A newline is added automatically after the text.
///    @param message Any number of string arguments.
///    @ingroup Logging )
/// 
/// </summary>

public void fn__echo (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__echo'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fn__echo(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// ( error, void, 2, 0, ( string message... ) 
///    @brief Logs an error message to the console.
///    Concatenates all given arguments to a single string and prints the string to the console as an error 
///    message (in the in-game console, these will show up using a red font by default). 
///    A newline is added automatically after the text.
///    @param message Any number of string arguments.
///    @ingroup Logging )
/// 
/// </summary>

public void fn__error (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__error'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fn__error(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// ( execPrefs, bool, 2, 4, ( string relativeFileName, bool noCalls=false, bool journalScript=false )
/// 				@brief Manually execute a special script file that contains game or editor preferences
/// 				@param relativeFileName Name and path to file from project folder
/// 				@param noCalls Deprecated
/// 				@param journalScript Deprecated
/// 				@return True if script was successfully executed
/// 				@note Appears to be useless in Torque 3D, should be deprecated
/// 				@ingroup Scripting)
/// 
/// </summary>

public bool fn__execPrefs (string a1, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__execPrefs'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",a1,a2,a3));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

return  SafeNativeMethods.mwle_fn__execPrefs(sba1, sba2, sba3)>=1;
}
/// <summary>
/// (expandFilename, const char*, 2, 2, (string filename)
/// 				@brief Grabs the full path of a specified file
/// 				@param filename Name of the local file to locate
/// 				@return String containing the full filepath on disk
/// 				@ingroup FileSystem)
/// 
/// </summary>

public string fn__expandFilename (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__expandFilename'" + string.Format("\"{0}\" ",a1));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

SafeNativeMethods.mwle_fn__expandFilename(sba1, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (expandOldFilename, const char*, 2, 2, (string filename)
/// 				@brief Retrofits a filepath that uses old Torque style
/// 				@return String containing filepath with new formatting
/// 				@ingroup FileSystem)
/// 
/// </summary>

public string fn__expandOldFilename (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__expandOldFilename'" + string.Format("\"{0}\" ",a1));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

SafeNativeMethods.mwle_fn__expandOldFilename(sba1, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( getStockColorCount, S32, 1, 1, () - Gets a count of available stock colors.
///    @return A count of available stock colors. )
/// 
/// </summary>

public int fn__getStockColorCount ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__getStockColorCount'");


return  SafeNativeMethods.mwle_fn__getStockColorCount();
}
/// <summary>
/// ( getStockColorF, const char*, 2, 2, (stockColorName) - Gets a floating-point-based stock color by name.
///    @param stockColorName - The stock color name to retrieve.
///    @return The stock color that matches the specified color name.  Returns nothing if the color name is not found. )
/// 
/// </summary>

public string fn__getStockColorF (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__getStockColorF'" + string.Format("\"{0}\" ",a1));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

SafeNativeMethods.mwle_fn__getStockColorF(sba1, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( getStockColorI, const char*, 2, 2, (stockColorName) - Gets a byte-based stock color by name.
///    @param stockColorName - The stock color name to retrieve.
///    @return The stock color that matches the specified color name.  Returns nothing if the color name is not found. )
/// 
/// </summary>

public string fn__getStockColorI (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__getStockColorI'" + string.Format("\"{0}\" ",a1));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

SafeNativeMethods.mwle_fn__getStockColorI(sba1, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( getStockColorName, const char*, 2, 2,  (stockColorIndex) - Gets the stock color name at the specified index.
///    @param stockColorIndex The zero-based index of the stock color name to retrieve.
///    @return The stock color name at the specified index or nothing if the string is invalid. )
/// 
/// </summary>

public string fn__getStockColorName (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__getStockColorName'" + string.Format("\"{0}\" ",a1));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

SafeNativeMethods.mwle_fn__getStockColorName(sba1, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( isStockColor, bool, 2, 2,  (stockColorName) - Gets whether the specified name is a stock color or not.
///    @param stockColorName - The stock color name to test for.
///    @return Whether the specified name is a stock color or not. )
/// 
/// </summary>

public bool fn__isStockColor (string a1)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__isStockColor'" + string.Format("\"{0}\" ",a1));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);

return  SafeNativeMethods.mwle_fn__isStockColor(sba1)>=1;
}
/// <summary>
/// ( mathInit, void, 1, 10, ( ... )
///                 @brief Install the math library with specified extensions.
///                 Possible parameters are:
///                     - 'DETECT' Autodetect math lib settings.
///                     - 'C' Enable the C math routines. C routines are always enabled.
///                     - 'FPU' Enable floating point unit routines.
///                     - 'MMX' Enable MMX math routines.
///                     - '3DNOW' Enable 3dNow! math routines.
///                     - 'SSE' Enable SSE math routines.
/// 				@ingroup Math)
/// 
/// 
/// 
/// </summary>

public void fn__mathInit (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__mathInit'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);

SafeNativeMethods.mwle_fn__mathInit(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9);
}
/// <summary>
/// (resourceDump, void, 1, 1, ()
/// 				@brief List the currently managed resources
/// 				Currently used by editors only, internal
/// 				@ingroup Editors
/// 				@internal)
/// 
/// </summary>

public void fn__resourceDump ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__resourceDump'");


SafeNativeMethods.mwle_fn__resourceDump();
}
/// <summary>
/// (schedule, S32, 4, 0, schedule(time, refobject|0, command, arg1...argN>))
/// 
/// </summary>

public int fn__schedule (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__schedule'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

return  SafeNativeMethods.mwle_fn__schedule(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// (TestFunction2Args, const char *, 3, 3, testFunction(arg1, arg2))
/// 
/// </summary>

public string fn__TestFunction2Args (string a1, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__TestFunction2Args'" + string.Format("\"{0}\" \"{1}\" ",a1,a2));
var returnbuff = new StringBuilder(16384);
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fn__TestFunction2Args(sba1, sba2, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( warn, void, 2, 0, ( string message... ) 
///    @brief Logs a warning message to the console.
///    Concatenates all given arguments to a single string and prints the string to the console as a warning 
///    message (in the in-game console, these will show up using a turquoise font by default). 
///    A newline is added automatically after the text.
///    @param message Any number of string arguments.
///    @ingroup Logging )
/// 
/// </summary>

public void fn__warn (string a1, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn__warn'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sba1 = null;
if (a1 != null)
     sba1 = new StringBuilder(a1, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fn__warn(sba1, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// ()
///             @brief Activates DirectInput.
///             Also activates any connected joysticks.
/// 			@ingroup Input)
/// 
/// </summary>

public void fn_activateDirectInput ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_activateDirectInput'");


SafeNativeMethods.mwle_fn_activateDirectInput();
}
/// <summary>
/// @brief Activates an existing package.
///    The activation occurs by updating the namespace linkage of existing functions and methods. 
///    If the package is already activated the function does nothing.
///    @ingroup Packages)
/// 
/// </summary>

public void fn_activatePackage (string packageName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_activatePackage'" + string.Format("\"{0}\" ",packageName));
StringBuilder sbpackageName = null;
if (packageName != null)
     sbpackageName = new StringBuilder(packageName, 1024);

SafeNativeMethods.mwle_fn_activatePackage(sbpackageName);
}
/// <summary>
/// @brief Add a string to the bad word filter
/// 
///    The bad word filter is a table containing words which will not be 
///    displayed in chat windows. Instead, a designated replacement string will be displayed.  
///    There are already a number of bad words automatically defined.
/// 
///    @param badWord Exact text of the word to restrict.
///    @return True if word was successfully added, false if the word or a subset of it already exists in the table
/// 
///    @see filterString()
/// 
///    @tsexample
///       // In this game, \"Foobar\" is banned
///       %badWord = \"Foobar\";
///       // Returns true, word was successfully added
///       addBadWord(%badWord);
///       // Returns false, word has already been added
///       addBadWord(\"Foobar\");
///    @endtsexample
/// 
///    @ingroup Game)
/// 
/// </summary>

public bool fn_addBadWord (string badWord)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_addBadWord'" + string.Format("\"{0}\" ",badWord));
StringBuilder sbbadWord = null;
if (badWord != null)
     sbbadWord = new StringBuilder(badWord, 1024);

return  SafeNativeMethods.mwle_fn_addBadWord(sbbadWord)>=1;
}
/// <summary>
/// Adds a global shader macro which will be merged with the script defined 
///    macros on every shader.  The macro will replace the value of an existing 
///    macro of the same name.  For the new macro to take effect all the shaders 
///    in the system need to be reloaded.
///    @see resetLightManager, removeGlobalShaderMacro
///    @ingroup Rendering )
/// 
/// </summary>

public void fn_addGlobalShaderMacro (string name, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_addGlobalShaderMacro'" + string.Format("\"{0}\" \"{1}\" ",name,value));
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fn_addGlobalShaderMacro(sbname, sbvalue);
}
/// <summary>
/// (string texName, string matName)
///    @brief Maps the given texture to the given material.
///    Generates a console warning before overwriting.
///    Material maps are used by terrain and interiors for triggering 
///    effects when an object moves onto a terrain 
///    block or interior surface using the associated texture.
///    @ingroup Materials)
/// 
/// </summary>

public void fn_addMaterialMapping (string texName, string matName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_addMaterialMapping'" + string.Format("\"{0}\" \"{1}\" ",texName,matName));
StringBuilder sbtexName = null;
if (texName != null)
     sbtexName = new StringBuilder(texName, 1024);
StringBuilder sbmatName = null;
if (matName != null)
     sbmatName = new StringBuilder(matName, 1024);

SafeNativeMethods.mwle_fn_addMaterialMapping(sbtexName, sbmatName);
}
/// <summary>
/// ),
///    @brief Use the addTaggedString function to tag a new string and add it to the NetStringTable
/// 
///    @param str The string to be tagged and placed in the NetStringTable. Tagging ignores case, 
///    so tagging the same string (excluding case differences) will be ignored as a duplicated tag.
/// 
///    @return Returns a string( containing a numeric value) equivalent to the string ID for the newly tagged string
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see removeTaggedString()
///    @see getTaggedString()
///    @ingroup Networking)
/// 	
/// </summary>

public string fn_addTaggedString (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_addTaggedString'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_addTaggedString(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ), 'playerName'[, 'AIClassType'] );)
/// 
/// </summary>

public int fn_aiAddPlayer (string name, string ns)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_aiAddPlayer'" + string.Format("\"{0}\" \"{1}\" ",name,ns));
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbns = null;
if (ns != null)
     sbns = new StringBuilder(ns, 1024);

return  SafeNativeMethods.mwle_fn_aiAddPlayer(sbname, sbns);
}
/// <summary>
/// ai.getAimLocation(); ) 
/// 
/// </summary>

public string fn_AIClient_getAimLocation (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_getAimLocation'" + string.Format("\"{0}\" ",aiclient));
var returnbuff = new StringBuilder(16384);
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_getAimLocation(sbaiclient, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ai.getLocation(); ) 
/// 
/// </summary>

public string fn_AIClient_getLocation (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_getLocation'" + string.Format("\"{0}\" ",aiclient));
var returnbuff = new StringBuilder(16384);
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_getLocation(sbaiclient, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ai.getMoveDestination(); ) 
/// 
/// </summary>

public string fn_AIClient_getMoveDestination (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_getMoveDestination'" + string.Format("\"{0}\" ",aiclient));
var returnbuff = new StringBuilder(16384);
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_getMoveDestination(sbaiclient, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ai.getTargetObject(); ) 
/// 
/// </summary>

public int fn_AIClient_getTargetObject (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_getTargetObject'" + string.Format("\"{0}\" ",aiclient));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

return  SafeNativeMethods.mwle_fn_AIClient_getTargetObject(sbaiclient);
}
/// <summary>
/// ai.missionCycleCleanup(); ) 
/// 
/// </summary>

public void fn_AIClient_missionCycleCleanup (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_missionCycleCleanup'" + string.Format("\"{0}\" ",aiclient));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_missionCycleCleanup(sbaiclient);
}
/// <summary>
/// ai.move(); ) 
/// 
/// </summary>

public void fn_AIClient_move (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_move'" + string.Format("\"{0}\" ",aiclient));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_move(sbaiclient);
}
/// <summary>
/// ai.moveForward(); ) 
/// 
/// </summary>

public void fn_AIClient_moveForward (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_moveForward'" + string.Format("\"{0}\" ",aiclient));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_moveForward(sbaiclient);
}
/// <summary>
/// ai.setAimLocation( x y z ); ) 
/// 
/// </summary>

public void fn_AIClient_setAimLocation (string aiclient, string v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_setAimLocation'" + string.Format("\"{0}\" \"{1}\" ",aiclient,v));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);
StringBuilder sbv = null;
if (v != null)
     sbv = new StringBuilder(v, 1024);

SafeNativeMethods.mwle_fn_AIClient_setAimLocation(sbaiclient, sbv);
}
/// <summary>
/// ai.setMoveDestination( x y z ); )
/// 
/// </summary>

public void fn_AIClient_setMoveDestination (string aiclient, string v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_setMoveDestination'" + string.Format("\"{0}\" \"{1}\" ",aiclient,v));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);
StringBuilder sbv = null;
if (v != null)
     sbv = new StringBuilder(v, 1024);

SafeNativeMethods.mwle_fn_AIClient_setMoveDestination(sbaiclient, sbv);
}
/// <summary>
/// ai.setMoveSpeed( float ); ) 
/// 
/// </summary>

public void fn_AIClient_setMoveSpeed (string aiclient, float speed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_setMoveSpeed'" + string.Format("\"{0}\" \"{1}\" ",aiclient,speed));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_setMoveSpeed(sbaiclient, speed);
}
/// <summary>
/// ai.setTargetObject( obj ); ) 
/// 
/// </summary>

public void fn_AIClient_setTargetObject (string aiclient, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_setTargetObject'" + string.Format("\"{0}\" \"{1}\" ",aiclient,objName));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_AIClient_setTargetObject(sbaiclient, sbobjName);
}
/// <summary>
/// ai.stop(); ) 
/// 
/// </summary>

public void fn_AIClient_stop (string aiclient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIClient_stop'" + string.Format("\"{0}\" ",aiclient));
StringBuilder sbaiclient = null;
if (aiclient != null)
     sbaiclient = new StringBuilder(aiclient, 1024);

SafeNativeMethods.mwle_fn_AIClient_stop(sbaiclient);
}
/// <summary>
/// )
/// 
/// </summary>

public string fn_AIConnection_getAddress (string aiconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_getAddress'" + string.Format("\"{0}\" ",aiconnection));
var returnbuff = new StringBuilder(16384);
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);

SafeNativeMethods.mwle_fn_AIConnection_getAddress(sbaiconnection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getFreeLook()
///               Is freelook on for the current move?)
/// 
/// </summary>

public bool fn_AIConnection_getFreeLook (string aiconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_getFreeLook'" + string.Format("\"{0}\" ",aiconnection));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);

return  SafeNativeMethods.mwle_fn_AIConnection_getFreeLook(sbaiconnection)>=1;
}
/// <summary>
/// (string field)
///               Get the given field of a move.
///               @param field One of {'x','y','z','yaw','pitch','roll'}
///               @returns The requested field on the current move.)
/// 
/// </summary>

public float fn_AIConnection_getMove (string aiconnection, string field)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_getMove'" + string.Format("\"{0}\" \"{1}\" ",aiconnection,field));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);
StringBuilder sbfield = null;
if (field != null)
     sbfield = new StringBuilder(field, 1024);

return  SafeNativeMethods.mwle_fn_AIConnection_getMove(sbaiconnection, sbfield);
}
/// <summary>
/// (int trigger)
///               Is the given trigger set?)
/// 
/// </summary>

public bool fn_AIConnection_getTrigger (string aiconnection, int idx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_getTrigger'" + string.Format("\"{0}\" \"{1}\" ",aiconnection,idx));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);

return  SafeNativeMethods.mwle_fn_AIConnection_getTrigger(sbaiconnection, idx)>=1;
}
/// <summary>
/// (bool isFreeLook)
///               Enable/disable freelook on the current move.)
/// 
/// </summary>

public void fn_AIConnection_setFreeLook (string aiconnection, bool isFreeLook)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_setFreeLook'" + string.Format("\"{0}\" \"{1}\" ",aiconnection,isFreeLook));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);

SafeNativeMethods.mwle_fn_AIConnection_setFreeLook(sbaiconnection, isFreeLook);
}
/// <summary>
/// (string field, float value)
///               Set a field on the current move.
///               @param   field One of {'x','y','z','yaw','pitch','roll'}
///               @param   value Value to set field to.)
/// 
/// </summary>

public void fn_AIConnection_setMove (string aiconnection, string field, float value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_setMove'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiconnection,field,value));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);
StringBuilder sbfield = null;
if (field != null)
     sbfield = new StringBuilder(field, 1024);

SafeNativeMethods.mwle_fn_AIConnection_setMove(sbaiconnection, sbfield, value);
}
/// <summary>
/// (int trigger, bool set)
///               Set a trigger.)
/// 
/// </summary>

public void fn_AIConnection_setTrigger (string aiconnection, int idx, bool set)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIConnection_setTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiconnection,idx,set));
StringBuilder sbaiconnection = null;
if (aiconnection != null)
     sbaiconnection = new StringBuilder(aiconnection, 1024);

SafeNativeMethods.mwle_fn_AIConnection_setTrigger(sbaiconnection, idx, set);
}
/// <summary>
/// ( GameBase obj, [Point3F offset] )
///               Sets the bot's target object. Optionally set an offset from target location.
/// 			  @hide)
/// 
/// </summary>

public void fn_AIPlayer_setAimObject (string aiplayer, string objName, string offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_AIPlayer_setAimObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiplayer,objName,offset));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

SafeNativeMethods.mwle_fn_AIPlayer_setAimObject(sbaiplayer, sbobjName, sboffset);
}
/// <summary>
/// allowConnections(bool allow)
///    @brief Sets whether or not the global NetInterface allows connections from remote hosts.
/// 
///    @param allow Set to true to allow remote connections.
/// 
///    @ingroup Networking)
/// 
/// </summary>

public void fn_allowConnections (bool allow)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_allowConnections'" + string.Format("\"{0}\" ",allow));

SafeNativeMethods.mwle_fn_allowConnections(allow);
}
/// <summary>
/// @brief Prints the scripting call stack to the console log.
///    Used to trace functions called from within functions. Can help discover what functions were called 
///    (and not yet exited) before the current point in scripts.
///    @ingroup Debugging)
/// 
/// </summary>

public void fn_backtrace ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_backtrace'");


SafeNativeMethods.mwle_fn_backtrace();
}
/// <summary>
/// CSV), (location, [backend]) -
/// 				@brief Takes a string informing the backend where to store 
/// 				sample data and optionally a name of the specific logging 
/// 				backend to use.  The default is the CSV backend. In most 
/// 				cases, the logging store will be a file name.
/// 				@tsexample
/// 				beginSampling( \"mysamples.csv\" );
/// 				@endtsexample
/// 				@ingroup Rendering)
/// 
/// </summary>

public void fn_beginSampling (string location, string backend)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_beginSampling'" + string.Format("\"{0}\" \"{1}\" ",location,backend));
StringBuilder sblocation = null;
if (location != null)
     sblocation = new StringBuilder(location, 1024);
StringBuilder sbbackend = null;
if (backend != null)
     sbbackend = new StringBuilder(backend, 1024);

SafeNativeMethods.mwle_fn_beginSampling(sblocation, sbbackend);
}
/// <summary>
/// @brief Calculates how much an explosion effects a specific object.
///    Use this to determine how much damage to apply to objects based on their 
///    distance from the explosion's center point, and whether the explosion is 
///    blocked by other objects.
///    @param pos Center position of the explosion.
///    @param id Id of the object of which to check coverage.
///    @param covMask Mask of object types that may block the explosion.
///    @return Coverage value from 0 (not affected by the explosion) to 1 (fully affected)
///    @tsexample
///    // Get the position of the explosion.
///    %position = %explosion.getPosition();
///    // Set a list of TypeMasks (defined in gameFunctioncs.cpp), seperated by the | character.
///    %TypeMasks = $TypeMasks::StaticObjectType | $TypeMasks::ItemObjectType
///    // Acquire the damage value from 0.0f - 1.0f.
///    %coverage = calcExplosionCoverage( %position, %sceneObject, %TypeMasks );
///    // Apply damage to object 
///    %sceneObject.applyDamage( %coverage * 20 );
///    @endtsexample
///    @ingroup FX)
/// 
/// </summary>

public float fn_calcExplosionCoverage (string pos, int id, uint covMask)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_calcExplosionCoverage'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",pos,id,covMask));
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

return  SafeNativeMethods.mwle_fn_calcExplosionCoverage(sbpos, id, covMask);
}
/// <summary>
/// cancel(eventId))
/// 
/// </summary>

public void fn_cancel (int eventId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_cancel'" + string.Format("\"{0}\" ",eventId));

SafeNativeMethods.mwle_fn_cancel(eventId);
}
/// <summary>
/// cancelAll(objectId): cancel pending events on the specified object.  Events will be automatically cancelled if object is deleted.)
/// 
/// </summary>

public void fn_cancelAll (string objectId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_cancelAll'" + string.Format("\"{0}\" ",objectId));
StringBuilder sbobjectId = null;
if (objectId != null)
     sbobjectId = new StringBuilder(objectId, 1024);

SafeNativeMethods.mwle_fn_cancelAll(sbobjectId);
}
/// <summary>
/// cancelServerQuery(...); )
/// 
/// </summary>

public void fn_cancelServerQuery ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_cancelServerQuery'");


SafeNativeMethods.mwle_fn_cancelServerQuery();
}
/// <summary>
/// Release the unused pooled textures in texture manager freeing up video memory.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_cleanupTexturePool ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_cleanupTexturePool'");


SafeNativeMethods.mwle_fn_cleanupTexturePool();
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_clearClientPaths ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_clearClientPaths'");


SafeNativeMethods.mwle_fn_clearClientPaths();
}
/// <summary>
/// Clears the flagged state on all allocated GFX resources. 
///    See flagCurrentGFXResources for usage details.
///    @ingroup GFX
///    @see flagCurrentGFXResources, listGFXResources, describeGFXResources )
/// 
/// </summary>

public void fn_clearGFXResourceFlags ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_clearGFXResourceFlags'");


SafeNativeMethods.mwle_fn_clearGFXResourceFlags();
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_clearServerPaths ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_clearServerPaths'");


SafeNativeMethods.mwle_fn_clearServerPaths();
}
/// <summary>
/// ()
/// 	Returns all pop'd out windows to the main canvas.
/// 	)
/// 
/// </summary>

public void fn_CloseAllPopOuts ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CloseAllPopOuts'");


SafeNativeMethods.mwle_fn_CloseAllPopOuts();
}
/// <summary>
/// () 
///    @brief Closes the current network port
///    @ingroup Networking)
/// 
/// </summary>

public void fn_closeNetPort ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_closeNetPort'");


SafeNativeMethods.mwle_fn_closeNetPort();
}
/// <summary>
/// Close our startup splash window.
///    @note This is currently only implemented on Windows.
///    @ingroup Platform )
/// 
/// </summary>

public void fn_closeSplashWindow ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_closeSplashWindow'");


SafeNativeMethods.mwle_fn_closeSplashWindow();
}
/// <summary>
/// Replace all escape sequences in @a text with their respective character codes.
///    This function replaces all escape sequences (\\\, \\\\t, etc) in the given string 
///    with the respective characters they represent.
///    The primary use of this function is for converting strings from their literal form into 
///    their compiled/translated form, as is normally done by the TorqueScript compiler.
///    @param text A string.
///    @return A duplicate of @a text with all escape sequences replaced by their respective character codes.
///    @tsexample
///       // Print:
///       //
///       //    str
///       //    ing
///       //
///       // to the console.  Note how the backslash in the string must be escaped here
///       // in order to prevent the TorqueScript compiler from collapsing the escape
///       // sequence in the resulting string.
///       echo( collapseEscape( \"str\ing\" ) );
///    @endtsexample
///    @see expandEscape
///    @ingroup Strings )
/// 
/// </summary>

public string fn_collapseEscape (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_collapseEscape'" + string.Format("\"{0}\" ",text));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_collapseEscape(sbtext, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Compile a file to bytecode.
///    This function will read the TorqueScript code in the specified file, compile it to internal bytecode, and, 
///    if DSO generation is enabled or @a overrideNoDDSO is true, will store the compiled code in a .dso file 
///    in the current DSO path mirrorring the path of @a fileName.
///    @param fileName Path to the file to compile to bytecode.
///    @param overrideNoDSO If true, force generation of DSOs even if the engine is compiled to not 
///       generate write compiled code to DSO files.
///    @return True if the file was successfully compiled, false if not.
///    @note The definitions contained in the given file will not be made available and no code will actually 
///       be executed.  Use exec() for that.
///    @see getDSOPath
///    @see exec
///    @ingroup Scripting )
/// 
/// </summary>

public bool fn_compile (string fileName, bool overrideNoDSO)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_compile'" + string.Format("\"{0}\" \"{1}\" ",fileName,overrideNoDSO));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_compile(sbfileName, overrideNoDSO)>=1;
}
/// <summary>
/// addAction( UndoAction ) )
/// 
/// </summary>

public void fn_CompoundUndoAction_addAction (string compoundundoaction, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CompoundUndoAction_addAction'" + string.Format("\"{0}\" \"{1}\" ",compoundundoaction,objName));
StringBuilder sbcompoundundoaction = null;
if (compoundundoaction != null)
     sbcompoundundoaction = new StringBuilder(compoundundoaction, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_CompoundUndoAction_addAction(sbcompoundundoaction, sbobjName);
}
/// <summary>
/// Exports console definition XML representation )
/// 
/// </summary>

public string fn_consoleExportXML ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_consoleExportXML'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_consoleExportXML(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () Attaches the logger to the console and begins writing to file
/// 			  @tsexample
/// 			  // Create the logger
/// 			  // Will automatically start writing to testLogging.txt with normal priority
/// 			  new ConsoleLogger(logger, \"testLogging.txt\", false);
/// 			  // Send something to the console, with the logger consumes and writes to file
/// 			  echo(\"This is logged to the file\");
/// 			  // Stop logging, but do not delete the logger
/// 			  logger.detach();
/// 			  echo(\"This is not logged to the file\");
/// 			  // Attach the logger to the console again
/// 			  logger.attach();
/// 			  // Logging has resumed
/// 			  echo(\"Logging has resumed\");
/// 			  @endtsexample)
/// 
/// </summary>

public bool fn_ConsoleLogger_attach (string consolelogger)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ConsoleLogger_attach'" + string.Format("\"{0}\" ",consolelogger));
StringBuilder sbconsolelogger = null;
if (consolelogger != null)
     sbconsolelogger = new StringBuilder(consolelogger, 1024);

return  SafeNativeMethods.mwle_fn_ConsoleLogger_attach(sbconsolelogger)>=1;
}
/// <summary>
/// () Detaches the logger from the console and stops writing to file
/// 			  @tsexample
/// 			  // Create the logger
/// 			  // Will automatically start writing to testLogging.txt with normal priority
/// 			  new ConsoleLogger(logger, \"testLogging.txt\", false);
/// 			  // Send something to the console, with the logger consumes and writes to file
/// 			  echo(\"This is logged to the file\");
/// 			  // Stop logging, but do not delete the logger
/// 			  logger.detach();
/// 			  echo(\"This is not logged to the file\");
/// 			  // Attach the logger to the console again
/// 			  logger.attach();
/// 			  // Logging has resumed
/// 			  echo(\"Logging has resumed\");
/// 			  @endtsexample)
/// 
/// </summary>

public bool fn_ConsoleLogger_detach (string consolelogger)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ConsoleLogger_detach'" + string.Format("\"{0}\" ",consolelogger));
StringBuilder sbconsolelogger = null;
if (consolelogger != null)
     sbconsolelogger = new StringBuilder(consolelogger, 1024);

return  SafeNativeMethods.mwle_fn_ConsoleLogger_detach(sbconsolelogger)>=1;
}
/// <summary>
/// @brief See if any objects of the given types are present in box of given extent.
///    @note Extent parameter is last since only one radius is often needed.  If 
///    one radius is provided, the yRadius and zRadius are assumed to be the same.  Unfortunately, 
///    if you need to use the client container, you'll need to set all of the radius parameters.  
///    Fortunately, this function is mostly used on the server.
///    @param  mask   Indicates the type of objects we are checking against.
///    @param  center Center of box.
///    @param  xRadius Search radius in the x-axis. See note above.
///    @param  yRadius Search radius in the y-axis. See note above.
///    @param  zRadius Search radius in the z-axis. See note above.
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
///    @return true if the box is empty, false if any object is found.
///    @ingroup Game)
/// 
/// </summary>

public bool fn_containerBoxEmpty (uint mask, string center, float xRadius, float yRadius, float zRadius, bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerBoxEmpty'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",mask,center,xRadius,yRadius,zRadius,useClientContainer));
StringBuilder sbcenter = null;
if (center != null)
     sbcenter = new StringBuilder(center, 1024);

return  SafeNativeMethods.mwle_fn_containerBoxEmpty(mask, sbcenter, xRadius, yRadius, zRadius, useClientContainer)>=1;
}
/// <summary>
/// (int mask, Point3F point, float x, float y, float z)
///    @brief Find objects matching the bitmask type within a box centered at point, with extents x, y, z.
///    @returns The first object found, or an empty string if nothing was found.  Thereafter, you can get more 
///    results using containerFindNext().
///    @see containerFindNext
///    @ingroup Game)
/// 
/// </summary>

public string fn_containerFindFirst (uint typeMask, string origin, string size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerFindFirst'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",typeMask,origin,size));
var returnbuff = new StringBuilder(16384);
StringBuilder sborigin = null;
if (origin != null)
     sborigin = new StringBuilder(origin, 1024);
StringBuilder sbsize = null;
if (size != null)
     sbsize = new StringBuilder(size, 1024);

SafeNativeMethods.mwle_fn_containerFindFirst(typeMask, sborigin, sbsize, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
///    @brief Get more results from a previous call to containerFindFirst().
///    @note You must call containerFindFirst() to begin the search.
///    @returns The next object found, or an empty string if nothing else was found.
///    @see containerFindFirst()
/// 	@ingroup Game)
/// 
/// </summary>

public string fn_containerFindNext ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerFindNext'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_containerFindNext(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Cast a ray from start to end, checking for collision against items matching mask.
/// 
///    If pExempt is specified, then it is temporarily excluded from collision checks (For 
///    instance, you might want to exclude the player if said player was firing a weapon.)
/// 
///    @param start An XYZ vector containing the tail position of the ray.
///    @param end An XYZ vector containing the head position of the ray
///    @param mask A bitmask corresponding to the type of objects to check for
///    @param pExempt An optional ID for a single object that ignored for this raycast
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
/// 
///    @returns A string containing either null, if nothing was struck, or these fields:
///    ul>li>The ID of the object that was struck./li>
///    li>The x, y, z position that it was struck./li>
///    li>The x, y, z of the normal of the face that was struck./li>
///    li>The distance between the start point and the position we hit./li>/ul> 
/// 
///    @ingroup Game)
/// 
/// </summary>

public string fn_containerRayCast (string start, string end, uint mask, string pExempt, bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerRayCast'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",start,end,mask,pExempt,useClientContainer));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstart = null;
if (start != null)
     sbstart = new StringBuilder(start, 1024);
StringBuilder sbend = null;
if (end != null)
     sbend = new StringBuilder(end, 1024);
StringBuilder sbpExempt = null;
if (pExempt != null)
     sbpExempt = new StringBuilder(pExempt, 1024);

SafeNativeMethods.mwle_fn_containerRayCast(sbstart, sbend, mask, sbpExempt, useClientContainer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get distance of the center of the current item from the center of the 
///    current initContainerRadiusSearch.
/// 
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
///    @return distance from the center of the current object to the center of 
///    the search
/// 
///    @see containerSearchNext
///    @ingroup Game)
/// 
/// </summary>

public float fn_containerSearchCurrDist (bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerSearchCurrDist'" + string.Format("\"{0}\" ",useClientContainer));

return  SafeNativeMethods.mwle_fn_containerSearchCurrDist(useClientContainer);
}
/// <summary>
/// @brief Get the distance of the closest point of the current item from the center 
///    of the current initContainerRadiusSearch.
/// 
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
///    @return distance from the closest point of the current object to the 
///    center of the search
/// 
///    @see containerSearchNext 
///    @ingroup Game)
/// 
/// </summary>

public float fn_containerSearchCurrRadiusDist (bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerSearchCurrRadiusDist'" + string.Format("\"{0}\" ",useClientContainer));

return  SafeNativeMethods.mwle_fn_containerSearchCurrRadiusDist(useClientContainer);
}
/// <summary>
/// @brief Get next item from a search started with initContainerRadiusSearch() or 
///    initContainerTypeSearch().
/// 
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
///    @return the next object found in the search, or null if no more
/// 
///    @tsexample
///    // print the names of all nearby ShapeBase derived objects
///    %position = %obj.getPosition;
///    %radius = 20;
///    %mask = $TypeMasks::ShapeBaseObjectType;
///    initContainerRadiusSearch( %position, %radius, %mask );
///    while ( (%targetObject = containerSearchNext()) != 0 )
///    {
///       echo( \"Found: \" @ %targetObject.getName() );
///    }
///    @endtsexample
/// 
///    @see initContainerRadiusSearch()
///    @see initContainerTypeSearch()
///    @ingroup Game)
/// 
/// </summary>

public string fn_containerSearchNext (bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containerSearchNext'" + string.Format("\"{0}\" ",useClientContainer));
var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_containerSearchNext(useClientContainer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Checks to see if text is a bad word
/// 
///    The text is considered to be a bad word if it has been added to the bad word filter.
/// 
///    @param text Text to scan for bad words
///    @return True if the text has bad word(s), false if it is clean
/// 
///    @see addBadWord()
///    @see filterString()
/// 
///    @tsexample
///       // In this game, \"Foobar\" is banned
///       %badWord = \"Foobar\";
///       // Add a banned word to the bad word filter
///       addBadWord(%badWord);
///       // Create the base string, can come from anywhere like user chat
///       %userText = \"Foobar\";
///       // Create a string of random letters
///       %replacementChars = \"knqwrtlzs\";
///       // If the text contains a bad word, filter it before printing
///       // Otherwise print the original text
///       if(containsBadWords(%userText))
///       {
///       	// Filter the string
///       	%filteredText = filterString(%userText, %replacementChars);
///       	// Print filtered text
///       	echo(%filteredText);
///       }
///       else
///       	echo(%userText);
///    @endtsexample
/// 
///    @ingroup Game)
/// 
/// </summary>

public bool fn_containsBadWords (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_containsBadWords'" + string.Format("\"{0}\" ",text));
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_containsBadWords(sbtext)>=1;
}
/// <summary>
/// Count the number of bits that are set in the given 32 bit integer.
///    @param v An integer value.
///    @return The number of bits that are set in @a v.
///    @ingroup Utilities )
/// 
/// </summary>

public int fn_countBits (int v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_countBits'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_countBits(v);
}
/// <summary>
/// @brief Create the given directory or the path leading to the given filename.
///    If @a path ends in a trailing slash, then all components in the given path will be created as directories (if not already in place).  If @a path, 
///    does @b not end in a trailing slash, then the last component of the path is taken to be a file name and only the directory components 
///    of the path will be created.
///    @param path The path to create.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem )
/// 
/// </summary>

public bool fn_createPath (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_createPath'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

return  SafeNativeMethods.mwle_fn_createPath(sbpath)>=1;
}
/// <summary>
/// (string group, string name, string value))
/// 
/// </summary>

public int fn_CreatorTree_addGroup (string creatortree, int group, string name, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_addGroup'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",creatortree,group,name,value));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_addGroup(sbcreatortree, group, sbname, sbvalue);
}
/// <summary>
/// (Node group, string name, string value))
/// 
/// </summary>

public int fn_CreatorTree_addItem (string creatortree, int group, string name, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_addItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",creatortree,group,name,value));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_addItem(sbcreatortree, group, sbname, sbvalue);
}
/// <summary>
/// Clear the tree.)
/// 
/// </summary>

public void fn_CreatorTree_clear (string creatortree)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_clear'" + string.Format("\"{0}\" ",creatortree));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);

SafeNativeMethods.mwle_fn_CreatorTree_clear(sbcreatortree);
}
/// <summary>
/// (string world, string type, string filename))
/// 
/// </summary>

public bool fn_CreatorTree_fileNameMatch (string creatortree, string world, string type, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_fileNameMatch'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",creatortree,world,type,filename));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);
StringBuilder sbworld = null;
if (world != null)
     sbworld = new StringBuilder(world, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_fileNameMatch(sbcreatortree, sbworld, sbtype, sbfilename)>=1;
}
/// <summary>
/// (Node item))
/// 
/// </summary>

public string fn_CreatorTree_getName (string creatortree, string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_getName'" + string.Format("\"{0}\" \"{1}\" ",creatortree,item));
var returnbuff = new StringBuilder(16384);
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

SafeNativeMethods.mwle_fn_CreatorTree_getName(sbcreatortree, sbitem, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (Node n))
/// 
/// </summary>

public int fn_CreatorTree_getParent (string creatortree, int nodeValue)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_getParent'" + string.Format("\"{0}\" \"{1}\" ",creatortree,nodeValue));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_getParent(sbcreatortree, nodeValue);
}
/// <summary>
/// Return a handle to the currently selected item.)
/// 
/// </summary>

public int fn_CreatorTree_getSelected (string creatortree)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_getSelected'" + string.Format("\"{0}\" ",creatortree));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_getSelected(sbcreatortree);
}
/// <summary>
/// (Node n))
/// 
/// </summary>

public string fn_CreatorTree_getValue (string creatortree, int nodeValue)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_getValue'" + string.Format("\"{0}\" \"{1}\" ",creatortree,nodeValue));
var returnbuff = new StringBuilder(16384);
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);

SafeNativeMethods.mwle_fn_CreatorTree_getValue(sbcreatortree, nodeValue, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (Group g))
/// 
/// </summary>

public bool fn_CreatorTree_isGroup (string creatortree, string group)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_CreatorTree_isGroup'" + string.Format("\"{0}\" \"{1}\" ",creatortree,group));
StringBuilder sbcreatortree = null;
if (creatortree != null)
     sbcreatortree = new StringBuilder(creatortree, 1024);
StringBuilder sbgroup = null;
if (group != null)
     sbgroup = new StringBuilder(group, 1024);

return  SafeNativeMethods.mwle_fn_CreatorTree_isGroup(sbcreatortree, sbgroup)>=1;
}
/// <summary>
/// ()
///                 Forcibly disconnects any attached script debugging client.
/// 				@internal Primarily used for Torsion and other debugging tools)
/// 
/// </summary>

public void fn_dbgDisconnect ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dbgDisconnect'");


SafeNativeMethods.mwle_fn_dbgDisconnect();
}
/// <summary>
/// ()
///               Clear all break points in the current file.)
/// 
/// </summary>

public void fn_DbgFileView_clearBreakPositions (string dbgfileview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_clearBreakPositions'" + string.Format("\"{0}\" ",dbgfileview));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_clearBreakPositions(sbdbgfileview);
}
/// <summary>
/// (string findThis)
///               Find the specified string in the currently viewed file and 
///               scroll it into view.)
/// 
/// </summary>

public bool fn_DbgFileView_findString (string dbgfileview, string findThis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_findString'" + string.Format("\"{0}\" \"{1}\" ",dbgfileview,findThis));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);
StringBuilder sbfindThis = null;
if (findThis != null)
     sbfindThis = new StringBuilder(findThis, 1024);

return  SafeNativeMethods.mwle_fn_DbgFileView_findString(sbdbgfileview, sbfindThis)>=1;
}
/// <summary>
/// ()
///               Get the currently executing file and line, if any.
///               @returns A string containing the file, a tab, and then the line number.
///                Use getField() with this.)
/// 
/// </summary>

public string fn_DbgFileView_getCurrentLine (string dbgfileview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_getCurrentLine'" + string.Format("\"{0}\" ",dbgfileview));
var returnbuff = new StringBuilder(16384);
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_getCurrentLine(sbdbgfileview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string filename)
///               Open a file for viewing.
///               @note This loads the file from the local system.)
/// 
/// </summary>

public bool fn_DbgFileView_open (string dbgfileview, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_open'" + string.Format("\"{0}\" \"{1}\" ",dbgfileview,filename));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fn_DbgFileView_open(sbdbgfileview, sbfilename)>=1;
}
/// <summary>
/// (int line)
///               Remove a breakpoint from the specified line.)
/// 
/// </summary>

public void fn_DbgFileView_removeBreak (string dbgfileview, uint line)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_removeBreak'" + string.Format("\"{0}\" \"{1}\" ",dbgfileview,line));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_removeBreak(sbdbgfileview, line);
}
/// <summary>
/// (int line)
///               Set a breakpoint at the specified line.)
/// 
/// </summary>

public void fn_DbgFileView_setBreak (string dbgfileview, uint line)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_setBreak'" + string.Format("\"{0}\" \"{1}\" ",dbgfileview,line));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_setBreak(sbdbgfileview, line);
}
/// <summary>
/// (int line)
///               Set a breakpoint at the specified line.)
/// 
/// </summary>

public void fn_DbgFileView_setBreakPosition (string dbgfileview, uint line)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_setBreakPosition'" + string.Format("\"{0}\" \"{1}\" ",dbgfileview,line));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_setBreakPosition(sbdbgfileview, line);
}
/// <summary>
/// (int line, bool selected)
///               Set the current highlighted line.)
/// 
/// </summary>

public void fn_DbgFileView_setCurrentLine (string dbgfileview, int line, bool selected)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DbgFileView_setCurrentLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",dbgfileview,line,selected));
StringBuilder sbdbgfileview = null;
if (dbgfileview != null)
     sbdbgfileview = new StringBuilder(dbgfileview, 1024);

SafeNativeMethods.mwle_fn_DbgFileView_setCurrentLine(sbdbgfileview, line, selected);
}
/// <summary>
/// ()
///                 Returns true if a script debugging client is connected else return false.
/// 				@internal Primarily used for Torsion and other debugging tools)
/// 
/// </summary>

public bool fn_dbgIsConnected ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dbgIsConnected'");


return  SafeNativeMethods.mwle_fn_dbgIsConnected()>=1;
}
/// <summary>
/// ( int port, string password, bool waitForClient )
///                 Open a debug server port on the specified port, requiring the specified password, 
/// 				and optionally waiting for the debug client to connect.
/// 				@internal Primarily used for Torsion and other debugging tools)
/// 
/// </summary>

public void fn_dbgSetParameters (int port, string password, bool waitForClient)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dbgSetParameters'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",port,password,waitForClient));
StringBuilder sbpassword = null;
if (password != null)
     sbpassword = new StringBuilder(password, 1024);

SafeNativeMethods.mwle_fn_dbgSetParameters(port, sbpassword, waitForClient);
}
/// <summary>
/// ()
///             @brief Disables DirectInput.
///             Also deactivates any connected joysticks.
/// 			@ingroup Input )
/// 
/// </summary>

public void fn_deactivateDirectInput ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_deactivateDirectInput'");


SafeNativeMethods.mwle_fn_deactivateDirectInput();
}
/// <summary>
/// @brief Deactivates a previously activated package.
///    The package is deactivated by removing its namespace linkages to any function or method. 
///    If there are any packages above this one in the stack they are deactivated as well. 
///    If the package is not on the stack this function does nothing.
///    @ingroup Packages)
/// 
/// </summary>

public void fn_deactivatePackage (string packageName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_deactivatePackage'" + string.Format("\"{0}\" ",packageName));
StringBuilder sbpackageName = null;
if (packageName != null)
     sbpackageName = new StringBuilder(packageName, 1024);

SafeNativeMethods.mwle_fn_deactivatePackage(sbpackageName);
}
/// <summary>
/// Drops the engine into the native C++ debugger.
///    This function triggers a debug break and drops the process into the IDE's debugger.  If the process is not 
///    running with a debugger attached it will generate a runtime error on most platforms.
///    @note This function is not available in shipping builds.
///    @ingroup Debugging )
/// 
/// </summary>

public void fn_debug ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_debug'");


SafeNativeMethods.mwle_fn_debug();
}
/// <summary>
/// @brief Dumps all current EngineObject instances to the console.
///    @note This function is only available in debug builds.
///    @ingroup Debugging )
/// 
/// </summary>

public void fn_debugDumpAllObjects ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_debugDumpAllObjects'");


SafeNativeMethods.mwle_fn_debugDumpAllObjects();
}
/// <summary>
/// Call the given function for each instance of the given class.
///    @param className Name of the class for which to enumerate instances.
///    @param functionName Name of function to call and pass each instance of the given class.
///    @note This function is only available in debug builds and primarily meant as an aid in debugging.
///    @ingroup Console)
/// 
/// </summary>

public void fn_debugEnumInstances (string className, string functionName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_debugEnumInstances'" + string.Format("\"{0}\" \"{1}\" ",className,functionName));
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);
StringBuilder sbfunctionName = null;
if (functionName != null)
     sbfunctionName = new StringBuilder(functionName, 1024);

SafeNativeMethods.mwle_fn_debugEnumInstances(sbclassName, sbfunctionName);
}
/// <summary>
/// @brief Logs the value of the given variable to the console.
///    Prints a string of the form \"variableName> = variable value>\" to the console.
///    @param variableName Name of the local or global variable to print.
///    @tsexample
///       %var = 1;
///       debugv( \"%var\" ); // Prints \"%var = 1\"
///    @endtsexample
///    @ingroup Debugging )
/// 
/// </summary>

public void fn_debugv (string variableName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_debugv'" + string.Format("\"{0}\" ",variableName));
StringBuilder sbvariableName = null;
if (variableName != null)
     sbvariableName = new StringBuilder(variableName, 1024);

SafeNativeMethods.mwle_fn_debugv(sbvariableName);
}
/// <summary>
/// Adds a new decal to the decal manager.
///    @param position World position for the decal.
///    @param normal Decal normal vector (if the decal was a tire lying flat on a 
///    surface, this is the vector pointing in the direction of the axle).
///    @param rot Angle (in radians) to rotate this decal around its normal vector.
///    @param scale Scale factor applied to the decal.
///    @param decalData DecalData datablock to use for the new decal.
///    @param isImmortal Whether or not this decal is immortal. If immortal, it 
///    does not expire automatically and must be removed explicitly.
///    @return Returns the ID of the new Decal object or -1 on failure.
///    @tsexample
///    // Specify the decal position
///    %position = \"1.0 1.0 1.0\";
///    // Specify the up vector
///    %normal = \"0.0 0.0 1.0\";
///    // Add the new decal.
///    %decalObj = decalManagerAddDecal( %position, %normal, 0.5, 0.35, ScorchBigDecal, false );
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public int fn_decalManagerAddDecal (string position, string normal, float rot, float scale, string decalData, bool isImmortal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerAddDecal'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",position,normal,rot,scale,decalData,isImmortal));
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);
StringBuilder sbnormal = null;
if (normal != null)
     sbnormal = new StringBuilder(normal, 1024);
StringBuilder sbdecalData = null;
if (decalData != null)
     sbdecalData = new StringBuilder(decalData, 1024);

return  SafeNativeMethods.mwle_fn_decalManagerAddDecal(sbposition, sbnormal, rot, scale, sbdecalData, isImmortal);
}
/// <summary>
/// Removes all decals currently loaded in the decal manager.
///    @tsexample
///    // Tell the decal manager to remove all existing decals.
///    decalManagerClear();
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public void fn_decalManagerClear ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerClear'");


SafeNativeMethods.mwle_fn_decalManagerClear();
}
/// <summary>
/// Returns whether the decal manager has unsaved modifications.
///    @return True if the decal manager has unsaved modifications, false if 
///    everything has been saved.
///    @tsexample
///    // Ask the decal manager if it has unsaved modifications.
///    %hasUnsavedModifications = decalManagerDirty();
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public bool fn_decalManagerDirty ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerDirty'");


return  SafeNativeMethods.mwle_fn_decalManagerDirty()>=1;
}
/// <summary>
/// Clears existing decals and replaces them with decals loaded from the specified file.
///    @param fileName Filename to load the decals from.
///    @return True if the decal manager was able to load the requested file, 
///    false if it could not.
///    @tsexample
///    // Set the filename to load the decals from.
///    %fileName = \"./missionDecals.mis.decals\";
///    // Inform the decal manager to load the decals from the entered filename.
///    decalManagerLoad( %fileName );
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public bool fn_decalManagerLoad (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerLoad'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_decalManagerLoad(sbfileName)>=1;
}
/// <summary>
/// Remove specified decal from the scene.
///    @param decalID ID of the decal to remove.
///    @return Returns true if successful, false if decal ID not found.
///    @tsexample
///    // Specify a decal ID to be removed
///    %decalID = 1;
///    // Tell the decal manager to remove the specified decal ID.
///    decalManagerRemoveDecal( %decalId )
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public bool fn_decalManagerRemoveDecal (int decalID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerRemoveDecal'" + string.Format("\"{0}\" ",decalID));

return  SafeNativeMethods.mwle_fn_decalManagerRemoveDecal(decalID)>=1;
}
/// <summary>
///  ),
///    Saves the decals for the active mission in the entered filename.
///    @param decalSaveFile Filename to save the decals to.
///    @tsexample
///    // Set the filename to save the decals in. If no filename is set, then the
///    // decals will default to activeMissionName>.mis.decals
///    %fileName = \"./missionDecals.mis.decals\";
///    // Inform the decal manager to save the decals for the active mission.
///    decalManagerSave( %fileName );
///    @endtsexample
///    @ingroup Decals )
/// 
/// </summary>

public void fn_decalManagerSave (string decalSaveFile)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_decalManagerSave'" + string.Format("\"{0}\" ",decalSaveFile));
StringBuilder sbdecalSaveFile = null;
if (decalSaveFile != null)
     sbdecalSaveFile = new StringBuilder(decalSaveFile, 1024);

SafeNativeMethods.mwle_fn_decalManagerSave(sbdecalSaveFile);
}
/// <summary>
/// Delete all the datablocks we've downloaded.
///    This is usually done in preparation of downloading a new set of datablocks, 
///    such as occurs on a mission change, but it's also good post-mission cleanup. )
/// 
/// </summary>

public void fn_deleteDataBlocks ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_deleteDataBlocks'");


SafeNativeMethods.mwle_fn_deleteDataBlocks();
}
/// <summary>
/// @brief Deletes the given @a file.
///    @param file %Path of the file to delete.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public bool fn_deleteFile (string file)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_deleteFile'" + string.Format("\"{0}\" ",file));
StringBuilder sbfile = null;
if (file != null)
     sbfile = new StringBuilder(file, 1024);

return  SafeNativeMethods.mwle_fn_deleteFile(sbfile)>=1;
}
/// <summary>
/// Undefine all global variables matching the given name @a pattern.
///    @param pattern A global variable name pattern.  Must begin with '$'.
///    @tsexample
///       // Define a global variable in the \"My\" namespace.
///       $My::Variable = \"value\";
///       // Undefine all variable in the \"My\" namespace.
///       deleteVariables( \"$My::*\" );
///    @endtsexample
///    @see strIsMatchExpr
///    @ingroup Scripting )
/// 
/// </summary>

public void fn_deleteVariables (string pattern)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_deleteVariables'" + string.Format("\"{0}\" ",pattern));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_deleteVariables(sbpattern);
}
/// <summary>
/// @brief Dumps a description of GFX resources to a file or the console.
///    @param resourceTypes A space seperated list of resource types or an empty string for all resources.
///    @param filePath A file to dump the list to or an empty string to write to the console.
///    @param unflaggedOnly If true only unflagged resources are dumped. See flagCurrentGFXResources.
///    @note The resource types can be one or more of the following:
///      - texture
///      - texture target
///      - window target
///      - vertex buffers
///      - primitive buffers
///      - fences
///      - cubemaps
///      - shaders
///      - stateblocks
///    @ingroup GFX )
/// 
/// </summary>

public void fn_describeGFXResources (string resourceTypes, string filePath, bool unflaggedOnly)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_describeGFXResources'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",resourceTypes,filePath,unflaggedOnly));
StringBuilder sbresourceTypes = null;
if (resourceTypes != null)
     sbresourceTypes = new StringBuilder(resourceTypes, 1024);
StringBuilder sbfilePath = null;
if (filePath != null)
     sbfilePath = new StringBuilder(filePath, 1024);

SafeNativeMethods.mwle_fn_describeGFXResources(sbresourceTypes, sbfilePath, unflaggedOnly);
}
/// <summary>
/// Dumps a description of all state blocks.     
///    @param filePath A file to dump the state blocks to or an empty string to write to the console.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_describeGFXStateBlocks (string filePath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_describeGFXStateBlocks'" + string.Format("\"{0}\" ",filePath));
StringBuilder sbfilePath = null;
if (filePath != null)
     sbfilePath = new StringBuilder(filePath, 1024);

SafeNativeMethods.mwle_fn_describeGFXStateBlocks(sbfilePath);
}
/// <summary>
/// @brief Returns the string from a tag string.
/// 
///    Should only be used within the context of a function that receives a tagged 
///    string, and is not meant to be used outside of this context.  Use getTaggedString() 
///    to convert a tagged string ID back into a regular string at any time.
/// 
///    @tsexample
///       // From scripts/client/message.cs
///       function clientCmdChatMessage(%sender, %voice, %pitch, %msgString, %a1, %a2, %a3, %a4, %a5, %a6, %a7, %a8, %a9, %a10)
///       {
///          onChatMessage(detag(%msgString), %voice, %pitch);
///       }
/// 	@endtsexample
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see getTag()
///    @see getTaggedString()
/// 
///    @ingroup Networking)
/// 
/// </summary>

public string fn_detag (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_detag'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_detag(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
///              @brief Disables use of the joystick.
///              @note DirectInput must be enabled and active to use this function.
///              @ingroup Input)
/// 
/// </summary>

public void fn_disableJoystick ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_disableJoystick'");


SafeNativeMethods.mwle_fn_disableJoystick();
}
/// <summary>
/// ()
///             @brief Disables XInput for Xbox 360 controllers.
///             @ingroup Input)
/// 
/// </summary>

public void fn_disableXInput ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_disableXInput'");


SafeNativeMethods.mwle_fn_disableXInput();
}
/// <summary>
/// ), (string queueName, string message, string data)
/// 				@brief Dispatch a message to a queue
/// 				@param queueName Queue to dispatch the message to
/// 				@param message Message to dispatch
/// 				@param data Data for message
/// 				@return True for success, false for failure
/// 				@see dispatchMessageObject
/// 				@ingroup Messaging)
/// 
/// </summary>

public bool fn_dispatchMessage (string queueName, string message, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dispatchMessage'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",queueName,message,data));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

return  SafeNativeMethods.mwle_fn_dispatchMessage(sbqueueName, sbmessage, sbdata)>=1;
}
/// <summary>
/// , ), (string queueName, string message)
/// 				@brief Dispatch a message object to a queue
/// 				@param queueName Queue to dispatch the message to
/// 				@param message Message to dispatch
/// 				@return true for success, false for failure
/// 				@see dispatchMessage
/// 				@ingroup Messaging)
/// 
/// </summary>

public bool fn_dispatchMessageObject (string queueName, string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dispatchMessageObject'" + string.Format("\"{0}\" \"{1}\" ",queueName,message));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

return  SafeNativeMethods.mwle_fn_dispatchMessageObject(sbqueueName, sbmessage)>=1;
}
/// <summary>
/// art/gui/splash.bmp),
///    Display a startup splash window suitable for showing while the engine still starts up.
///    @note This is currently only implemented on Windows.
///    @return True if the splash window could be successfully initialized.
///    @ingroup Platform )
/// 
/// </summary>

public bool fn_displaySplashWindow (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_displaySplashWindow'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

return  SafeNativeMethods.mwle_fn_displaySplashWindow(sbpath)>=1;
}
/// <summary>
/// (bool enabled)
///    @brief Enables logging of the connection protocols
///    When enabled a lot of network debugging information is sent to the console.
///    @param enabled True to enable, false to disable
///    @ingroup Networking)
/// 
/// </summary>

public void fn_DNetSetLogging (bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_DNetSetLogging'" + string.Format("\"{0}\" ",enabled));

SafeNativeMethods.mwle_fn_DNetSetLogging(enabled);
}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_1 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_1'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(16384);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_1(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_10 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_10'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_10(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_12 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_12'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_12(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_13 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_13'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_13(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_14 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_14'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_14(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_15 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_15'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_15(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_2 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_2'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_2(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_3 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_3'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_3(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_4 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_4'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_4(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_5 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_5'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_5(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_6 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_6'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_6(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_7 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_7'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_7(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_8 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_8'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_8(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
/// )
/// 
/// </summary>

public string fn_dnt_testcase_9 (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dnt_testcase_9'" + string.Format("\"{0}\" ",chr));
var returnbuff = new StringBuilder(1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_dnt_testcase_9(sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Dumps all declared console classes to the console.
///             @param dumpScript Optional parameter specifying whether or not classes defined in script should be dumped.
///             @param dumpEngine Optional parameter specifying whether or not classes defined in the engine should be dumped.
/// 			@ingroup Logging)
/// 
/// </summary>

public void fn_dumpConsoleClasses (bool dumpScript, bool dumpEngine)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpConsoleClasses'" + string.Format("\"{0}\" \"{1}\" ",dumpScript,dumpEngine));

SafeNativeMethods.mwle_fn_dumpConsoleClasses(dumpScript, dumpEngine);
}
/// <summary>
/// @brief Dumps all declared console functions to the console.
///             @param dumpScript Optional parameter specifying whether or not functions defined in script should be dumped.
///             @param dumpEngine Optional parameter specitying whether or not functions defined in the engine should be dumped.
/// 			@ingroup Logging)
/// 
/// </summary>

public void fn_dumpConsoleFunctions (bool dumpScript, bool dumpEngine)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpConsoleFunctions'" + string.Format("\"{0}\" \"{1}\" ",dumpScript,dumpEngine));

SafeNativeMethods.mwle_fn_dumpConsoleFunctions(dumpScript, dumpEngine);
}
/// <summary>
/// Dumps the engine scripting documentation to the specified file overwriting any existing content.
///                      @param outputFile The relative or absolute output file path and name.
///                      @return Returns true if successful.
///                      @ingroup Console)
/// 
/// </summary>

public bool fn_dumpEngineDocs (string outputFile)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpEngineDocs'" + string.Format("\"{0}\" ",outputFile));
StringBuilder sboutputFile = null;
if (outputFile != null)
     sboutputFile = new StringBuilder(outputFile, 1024);

return  SafeNativeMethods.mwle_fn_dumpEngineDocs(sboutputFile)>=1;
}
/// <summary>
/// Dumps to the console a full description of all cached fonts, along with 
///    info on the codepoints each contains.
///    @ingroup Font )
/// 
/// </summary>

public void fn_dumpFontCacheStatus ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpFontCacheStatus'");


SafeNativeMethods.mwle_fn_dumpFontCacheStatus();
}
/// <summary>
/// @brief Dumps a formatted list of currently allocated material instances to the console.
///    @ingroup Materials)
/// 
/// </summary>

public void fn_dumpMaterialInstances ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpMaterialInstances'");


SafeNativeMethods.mwle_fn_dumpMaterialInstances();
}
/// <summary>
/// @brief Dumps network statistics for each class to the console.
/// 
///    The returned i>avg/i>, i>min/i> and i>max/i> values are in bits sent per update.  
///    The i>num/i> value is the total number of events collected.
/// 
///    @note This method only works when TORQUE_NET_STATS is defined in torqueConfig.h.
///    @ingroup Networking )
/// 
/// </summary>

public void fn_dumpNetStats ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpNetStats'");


SafeNativeMethods.mwle_fn_dumpNetStats();
}
/// <summary>
/// @brief Dump the current contents of the networked string table to the console.
///    The results are returned in three columns.  The first column is the network string ID.  
///    The second column is the string itself.  The third column is the reference count to the 
///    network string.
///    @note This function is available only in debug builds.
///    @ingroup Networking )
/// 
/// </summary>

public void fn_dumpNetStringTable ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpNetStringTable'");


SafeNativeMethods.mwle_fn_dumpNetStringTable();
}
/// <summary>
/// Dumps all ProcessObjects in ServerProcessList and ClientProcessList to the console. )
/// 
/// </summary>

public void fn_dumpProcessList (bool allow)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpProcessList'" + string.Format("\"{0}\" ",allow));

SafeNativeMethods.mwle_fn_dumpProcessList(allow);
}
/// <summary>
/// Creates a 64x64 normal map texture filled with noise. The texture is saved 
///    to randNormTex.png in the location of the game executable.
///    @ingroup GFX)
/// 
/// </summary>

public void fn_dumpRandomNormalMap ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpRandomNormalMap'");


SafeNativeMethods.mwle_fn_dumpRandomNormalMap();
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_dumpSoCount ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpSoCount'");


SafeNativeMethods.mwle_fn_dumpSoCount();
}
/// <summary>
/// ()
/// 				@brief Dumps information about String memory usage
/// 				@ingroup Debugging
/// 				@ingroup Strings)
/// 
/// </summary>

public void fn_dumpStringMemStats ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpStringMemStats'");


SafeNativeMethods.mwle_fn_dumpStringMemStats();
}
/// <summary>
/// Dumps a list of all active texture objects to the console.
///    @note This function is only available in debug builds.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_dumpTextureObjects ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_dumpTextureObjects'");


SafeNativeMethods.mwle_fn_dumpTextureObjects();
}
/// <summary>
/// Copy the specified old font to a new name. The new copy will not have a 
///    platform font backing it, and so will never have characters added to it. 
///    But this is useful for making copies of fonts to add postprocessing effects 
///    to via exportCachedFont.
///    @param oldFontName The name of the font face to copy.
///    @param oldFontSize The size of the font to copy.
///    @param newFontName The name of the new font face.
///    @ingroup Font )
/// 
/// </summary>

public void fn_duplicateCachedFont (string oldFontName, int oldFontSize, string newFontName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_duplicateCachedFont'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",oldFontName,oldFontSize,newFontName));
StringBuilder sboldFontName = null;
if (oldFontName != null)
     sboldFontName = new StringBuilder(oldFontName, 1024);
StringBuilder sbnewFontName = null;
if (newFontName != null)
     sbnewFontName = new StringBuilder(newFontName, 1024);

SafeNativeMethods.mwle_fn_duplicateCachedFont(sboldFontName, oldFontSize, sbnewFontName);
}
/// <summary>
/// ()
///             @brief Prints information to the console stating if DirectInput and a Joystick are enabled and active.
///             @ingroup Input)
/// 
/// </summary>

public void fn_echoInputState ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_echoInputState'");


SafeNativeMethods.mwle_fn_echoInputState();
}
/// <summary>
/// Perform the onEditorDisabled callback on all SimObjects and set gEditingMission false )
/// 
/// </summary>

public void fn_EditManager_editorDisabled (string editmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EditManager_editorDisabled'" + string.Format("\"{0}\" ",editmanager));
StringBuilder sbeditmanager = null;
if (editmanager != null)
     sbeditmanager = new StringBuilder(editmanager, 1024);

SafeNativeMethods.mwle_fn_EditManager_editorDisabled(sbeditmanager);
}
/// <summary>
/// Perform the onEditorEnabled callback on all SimObjects and set gEditingMission true )
/// 
/// </summary>

public void fn_EditManager_editorEnabled (string editmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EditManager_editorEnabled'" + string.Format("\"{0}\" ",editmanager));
StringBuilder sbeditmanager = null;
if (editmanager != null)
     sbeditmanager = new StringBuilder(editmanager, 1024);

SafeNativeMethods.mwle_fn_EditManager_editorEnabled(sbeditmanager);
}
/// <summary>
/// (int slot))
/// 
/// </summary>

public void fn_EditManager_gotoBookmark (string editmanager, int val)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EditManager_gotoBookmark'" + string.Format("\"{0}\" \"{1}\" ",editmanager,val));
StringBuilder sbeditmanager = null;
if (editmanager != null)
     sbeditmanager = new StringBuilder(editmanager, 1024);

SafeNativeMethods.mwle_fn_EditManager_gotoBookmark(sbeditmanager, val);
}
/// <summary>
/// Return the value of gEditingMission. )
/// 
/// </summary>

public bool fn_EditManager_isEditorEnabled (string editmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EditManager_isEditorEnabled'" + string.Format("\"{0}\" ",editmanager));
StringBuilder sbeditmanager = null;
if (editmanager != null)
     sbeditmanager = new StringBuilder(editmanager, 1024);

return  SafeNativeMethods.mwle_fn_EditManager_isEditorEnabled(sbeditmanager)>=1;
}
/// <summary>
/// (int slot))
/// 
/// </summary>

public void fn_EditManager_setBookmark (string editmanager, int val)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EditManager_setBookmark'" + string.Format("\"{0}\" \"{1}\" ",editmanager,val));
StringBuilder sbeditmanager = null;
if (editmanager != null)
     sbeditmanager = new StringBuilder(editmanager, 1024);

SafeNativeMethods.mwle_fn_EditManager_setBookmark(sbeditmanager, val);
}
/// <summary>
/// ()
///              @brief Enables use of the joystick.
///              @note DirectInput must be enabled and active to use this function.
///              @ingroup Input)
/// 
/// </summary>

public bool fn_enableJoystick ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enableJoystick'");


return  SafeNativeMethods.mwle_fn_enableJoystick()>=1;
}
/// <summary>
/// (pattern, [state]) -
/// 				@brief Enable sampling for all keys that match the given name 
/// 				pattern. Slashes are treated as separators.
/// 				@ingroup Rendering)
/// 
/// </summary>

public void fn_enableSamples (string pattern, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enableSamples'" + string.Format("\"{0}\" \"{1}\" ",pattern,state));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_enableSamples(sbpattern, state);
}
/// <summary>
/// enableWinConsole(bool);)
/// 
/// </summary>

public void fn_enableWinConsole (bool flag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enableWinConsole'" + string.Format("\"{0}\" ",flag));

SafeNativeMethods.mwle_fn_enableWinConsole(flag);
}
/// <summary>
/// ()
///             @brief Enables XInput for Xbox 360 controllers.
///             @note XInput is enabled by default. Disable to use an Xbox 360 
///             Controller as a joystick device.
/// 				@ingroup Input)
/// 
/// </summary>

public bool fn_enableXInput ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enableXInput'");


return  SafeNativeMethods.mwle_fn_enableXInput()>=1;
}
/// <summary>
/// @brief Test whether the given string ends with the given suffix.
///    @param str The string to test.
///    @param suffix The potential suffix of @a str.
///    @param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will 
///       not be taken into account.
///    @return True if the last characters in @a str match the complete contents of @a suffix; false otherwise.
///    @tsexample
///    startsWith( \"TEST123\", \"123\" ) // Returns true.
///    @endtsexample
///    @see startsWith
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_endsWith (string str, string suffix, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_endsWith'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,suffix,caseSensitive));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbsuffix = null;
if (suffix != null)
     sbsuffix = new StringBuilder(suffix, 1024);

return  SafeNativeMethods.mwle_fn_endsWith(sbstr, sbsuffix, caseSensitive)>=1;
}
/// <summary>
/// (string shapePath, GuiTreeViewCtrl ctrl) Collect scene information from 
///    a COLLADA file and store it in a GuiTreeView control. This function is 
///    used by the COLLADA import gui to show a preview of the scene contents 
///    prior to import, and is probably not much use for anything else.
///    @param shapePath COLLADA filename
///    @param ctrl GuiTreeView control to add elements to
///    @return true if successful, false otherwise
///    @ingroup Editors
///    @internal)
/// 
/// </summary>

public bool fn_enumColladaForImport (string shapePath, string ctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enumColladaForImport'" + string.Format("\"{0}\" \"{1}\" ",shapePath,ctrl));
StringBuilder sbshapePath = null;
if (shapePath != null)
     sbshapePath = new StringBuilder(shapePath, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

return  SafeNativeMethods.mwle_fn_enumColladaForImport(sbshapePath, sbctrl)>=1;
}
/// <summary>
///  ),
/// 				@brief Returns a list of classes that derive from the named class.
///             If the named class is omitted this dumps all the classes.
///             @param className The optional base class name.
/// 				@return A tab delimited list of classes.
///             @ingroup Editors
/// 				@internal)
/// 
/// </summary>

public string fn_enumerateConsoleClasses (string className)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enumerateConsoleClasses'" + string.Format("\"{0}\" ",className));
var returnbuff = new StringBuilder(16384);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

SafeNativeMethods.mwle_fn_enumerateConsoleClasses(sbclassName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Provide a list of classes that belong to the given category.
/// 				@param category The category name.
/// 				@return A tab delimited list of classes.
/// 				@ingroup Editors
/// 				@internal)
/// 
/// </summary>

public string fn_enumerateConsoleClassesByCategory (string category)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_enumerateConsoleClassesByCategory'" + string.Format("\"{0}\" ",category));
var returnbuff = new StringBuilder(16384);
StringBuilder sbcategory = null;
if (category != null)
     sbcategory = new StringBuilder(category, 1024);

SafeNativeMethods.mwle_fn_enumerateConsoleClassesByCategory(sbcategory, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// eval(consoleString) )
/// 
/// </summary>

public string fn_eval (string consoleString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_eval'" + string.Format("\"{0}\" ",consoleString));
var returnbuff = new StringBuilder(16384);
StringBuilder sbconsoleString = null;
if (consoleString != null)
     sbconsoleString = new StringBuilder(consoleString, 1024);

SafeNativeMethods.mwle_fn_eval(sbconsoleString, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
///               Print all registered events to the console. )
/// 
/// </summary>

public void fn_EventManager_dumpEvents (string eventmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_dumpEvents'" + string.Format("\"{0}\" ",eventmanager));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);

SafeNativeMethods.mwle_fn_EventManager_dumpEvents(sbeventmanager);
}
/// <summary>
/// ), ( String event )
///               Print all subscribers to an event to the console.
///               @param event The event whose subscribers are to be printed. If this parameter isn't specified, all events will be dumped. )
/// 
/// </summary>

public void fn_EventManager_dumpSubscribers (string eventmanager, string listenerName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_dumpSubscribers'" + string.Format("\"{0}\" \"{1}\" ",eventmanager,listenerName));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);

SafeNativeMethods.mwle_fn_EventManager_dumpSubscribers(sbeventmanager, sblistenerName);
}
/// <summary>
/// ( String event )
///               Check if an event is registered or not.
///               @param event The event to check.
///               @return Whether or not the event exists. )
/// 
/// </summary>

public bool fn_EventManager_isRegisteredEvent (string eventmanager, string evt)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_isRegisteredEvent'" + string.Format("\"{0}\" \"{1}\" ",eventmanager,evt));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);

return  SafeNativeMethods.mwle_fn_EventManager_isRegisteredEvent(sbeventmanager, sbevt)>=1;
}
/// <summary>
/// ), ( String event, String data )
///               ~Trigger an event.
///               @param event The event to trigger.
///               @param data The data associated with the event.
///               @return Whether or not the event was dispatched successfully. )
/// 
/// </summary>

public bool fn_EventManager_postEvent (string eventmanager, string evt, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_postEvent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",eventmanager,evt,data));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

return  SafeNativeMethods.mwle_fn_EventManager_postEvent(sbeventmanager, sbevt, sbdata)>=1;
}
/// <summary>
/// ( String event )
///               Register an event with the event manager.
///               @param event The event to register.
///               @return Whether or not the event was registered successfully. )
/// 
/// </summary>

public bool fn_EventManager_registerEvent (string eventmanager, string evt)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_registerEvent'" + string.Format("\"{0}\" \"{1}\" ",eventmanager,evt));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);

return  SafeNativeMethods.mwle_fn_EventManager_registerEvent(sbeventmanager, sbevt)>=1;
}
/// <summary>
/// ( SimObject listener, String event )
///               Remove a listener from an event.
///               @param listener The listener to remove.
///               @param event The event to be removed from.)
/// 
/// </summary>

public void fn_EventManager_remove (string eventmanager, string listenerName, string evt)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_remove'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",eventmanager,listenerName,evt));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);

SafeNativeMethods.mwle_fn_EventManager_remove(sbeventmanager, sblistenerName, sbevt);
}
/// <summary>
/// ( SimObject listener )
///               Remove a listener from all events.
///               @param listener The listener to remove.)
/// 
/// </summary>

public void fn_EventManager_removeAll (string eventmanager, string listenerName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_removeAll'" + string.Format("\"{0}\" \"{1}\" ",eventmanager,listenerName));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);

SafeNativeMethods.mwle_fn_EventManager_removeAll(sbeventmanager, sblistenerName);
}
/// <summary>
/// ), ( SimObject listener, String event, String callback )
///               Subscribe a listener to an event.
///               @param listener The listener to subscribe.
///               @param event The event to subscribe to.
///               @param callback Optional method name to receive the event notification. If this is not specified, \"on[event]\" will be used.
///               @return Whether or not the subscription was successful. )
/// 
/// </summary>

public bool fn_EventManager_subscribe (string eventmanager, string listenerName, string evt, string callback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_subscribe'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",eventmanager,listenerName,evt,callback));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);
StringBuilder sbcallback = null;
if (callback != null)
     sbcallback = new StringBuilder(callback, 1024);

return  SafeNativeMethods.mwle_fn_EventManager_subscribe(sbeventmanager, sblistenerName, sbevt, sbcallback)>=1;
}
/// <summary>
/// ( String event )
///               Remove an event from the EventManager.
///               @param event The event to remove. )
/// 
/// </summary>

public void fn_EventManager_unregisterEvent (string eventmanager, string evt)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_EventManager_unregisterEvent'" + string.Format("\"{0}\" \"{1}\" ",eventmanager,evt));
StringBuilder sbeventmanager = null;
if (eventmanager != null)
     sbeventmanager = new StringBuilder(eventmanager, 1024);
StringBuilder sbevt = null;
if (evt != null)
     sbevt = new StringBuilder(evt, 1024);

SafeNativeMethods.mwle_fn_EventManager_unregisterEvent(sbeventmanager, sbevt);
}
/// <summary>
/// @brief Used to exclude/prevent all other instances using the same identifier specified
/// 
/// 					 @note Not used on OSX, Xbox, or in Win debug builds
/// 
/// 					 @param appIdentifier Name of the app set up for exclusive use.
/// 
/// 					 @return False if another app is running that specified the same appIdentifier
/// 
/// 					 @ingroup Platform
/// 					 @ingroup GuiCore)
/// 
/// </summary>

public bool fn_excludeOtherInstance (string appIdentifer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_excludeOtherInstance'" + string.Format("\"{0}\" ",appIdentifer));
StringBuilder sbappIdentifer = null;
if (appIdentifer != null)
     sbappIdentifer = new StringBuilder(appIdentifer, 1024);

return  SafeNativeMethods.mwle_fn_excludeOtherInstance(sbappIdentifer)>=1;
}
/// <summary>
/// Execute the given script file.
///    @param fileName Path to the file to execute
///    @param noCalls Deprecated
///    @param journalScript Deprecated
///    @return True if the script was successfully executed, false if not.
///    @tsexample
///       // Execute the init.cs script file found in the same directory as the current script file.
///       exec( \"./init.cs\" );
///    @endtsexample
///    @see compile
///    @see eval
///    @ingroup Scripting )
/// 
/// </summary>

public bool fn_exec (string fileName, bool noCalls, bool journalScript)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_exec'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",fileName,noCalls,journalScript));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_exec(sbfileName, noCalls, journalScript)>=1;
}
/// <summary>
/// @brief Replace all characters in @a text that need to be escaped for the string to be a valid string literal with their 
///    respective escape sequences.
///    All characters in @a text that cannot appear in a string literal will be replaced by an escape sequence (\\\, \\\\t, etc).
///    The primary use of this function is for converting strings suitable for being passed as string literals 
///    to the TorqueScript compiler.
///    @param text A string
///    @return A duplicate of the text parameter with all unescaped characters that cannot appear in string literals replaced by their respective 
///    escape sequences.
///    @tsxample
///    expandEscape( \"str\" NL \"ing\" ) // Returns \"str\ing\".
///    @endtsxample
///    @see collapseEscape
///    @ingroup Strings)
/// 
/// </summary>

public string fn_expandEscape (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_expandEscape'" + string.Format("\"{0}\" ",text));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_expandEscape(sbtext, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// , false ),
///    Write out the definitions of all global variables matching the given name @a pattern.
///    If @a fileName is not \"\", the variable definitions are written to the specified file.  Otherwise the 
///    definitions will be printed to the console.
///    The output are valid TorqueScript statements that can be executed to restore the global variable 
///    values.
///    @param pattern A global variable name pattern.  Must begin with '$'.
///    @param filename %Path of the file to which to write the definitions or \"\" to write the definitions 
///       to the console.
///    @param append If true and @a fileName is not \"\", then the definitions are appended to the specified file. 
///       Otherwise existing contents of the file (if any) will be overwritten.
///    @tsexample
///       // Write out all preference variables to a prefs.cs file.
///       export( \"$prefs::*\", \"prefs.cs\" );
///    @endtsexample
///    @ingroup Scripting )
/// 
/// </summary>

public void fn_export (string pattern, string filename, bool append)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_export'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",pattern,filename,append));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_export(sbpattern, sbfilename, append);
}
/// <summary>
/// Export specified font to the specified filename as a PNG. The 
///    image can then be processed in Photoshop or another tool and 
///    reimported using importCachedFont. Characters in the font are 
///    exported as one long strip.
///    @param faceName The name of the font face.
///    @param fontSize The size of the font in pixels.
///    @param fileName The file name and path for the output PNG.
///    @param padding The padding between characters.   
///    @param kerning The kerning between characters.   
///    @ingroup Font )
/// 
/// </summary>

public void fn_exportCachedFont (string faceName, int fontSize, string fileName, int padding, int kerning)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_exportCachedFont'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",faceName,fontSize,fileName,padding,kerning));
StringBuilder sbfaceName = null;
if (faceName != null)
     sbfaceName = new StringBuilder(faceName, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_exportCachedFont(sbfaceName, fontSize, sbfileName, padding, kerning);
}
/// <summary>
/// Create a XML document containing a dump of the entire exported engine API.
///    @return A SimXMLDocument containing a dump of the engine's export information or NULL if the operation failed.
///    @ingroup Console )
/// 
/// </summary>

public string fn_exportEngineAPIToXML ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_exportEngineAPIToXML'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_exportEngineAPIToXML(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// , false ),
///    Write out the definitions of all global variables matching the given name @a pattern.
///    If @a fileName is not \"\", the variable definitions are written to the specified file.  Otherwise the 
///    definitions will be printed to the console.
///    The output are valid TorqueScript statements that can be executed to restore the global variable 
///    values.
///    @param pattern A global variable name pattern.  Must begin with '$'.
///    @param filename %Path of the file to which to write the definitions or \"\" to write the definitions 
///       to the console.
///    @param append If true and @a fileName is not \"\", then the definitions are appended to the specified file. 
///       Otherwise existing contents of the file (if any) will be overwritten.
///    @tsexample
///       // Write out all preference variables to a prefs.cs file.
///       export( \"$prefs::*\", \"prefs.cs\" );
///    @endtsexample
///    @ingroup Scripting )
/// 
/// </summary>

public void fn_exportToSettings (string pattern, string filename, bool append)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_exportToSettings'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",pattern,filename,append));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_exportToSettings(sbpattern, sbfilename, append);
}
/// <summary>
/// ), (simObject, [fieldList]) Copy selected static-fields for selected object./
///                                                         @param simObject Object to copy static-fields from.
///                                                         @param fieldList fields to filter static-fields against.
/// 			                                            @return No return value.)
/// 
/// </summary>

public void fn_FieldBrushObject_copyFields (string fieldbrushobject, string simObjName, string pFieldList)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_FieldBrushObject_copyFields'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",fieldbrushobject,simObjName,pFieldList));
StringBuilder sbfieldbrushobject = null;
if (fieldbrushobject != null)
     sbfieldbrushobject = new StringBuilder(fieldbrushobject, 1024);
StringBuilder sbsimObjName = null;
if (simObjName != null)
     sbsimObjName = new StringBuilder(simObjName, 1024);
StringBuilder sbpFieldList = null;
if (pFieldList != null)
     sbpFieldList = new StringBuilder(pFieldList, 1024);

SafeNativeMethods.mwle_fn_FieldBrushObject_copyFields(sbfieldbrushobject, sbsimObjName, sbpFieldList);
}
/// <summary>
/// (simObject) Paste copied static-fields to selected object./
///                                                         @param simObject Object to paste static-fields to.
/// 			                                            @return No return value.)
/// 
/// </summary>

public void fn_FieldBrushObject_pasteFields (string fieldbrushobject, string simObjName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_FieldBrushObject_pasteFields'" + string.Format("\"{0}\" \"{1}\" ",fieldbrushobject,simObjName));
StringBuilder sbfieldbrushobject = null;
if (fieldbrushobject != null)
     sbfieldbrushobject = new StringBuilder(fieldbrushobject, 1024);
StringBuilder sbsimObjName = null;
if (simObjName != null)
     sbsimObjName = new StringBuilder(simObjName, 1024);

SafeNativeMethods.mwle_fn_FieldBrushObject_pasteFields(sbfieldbrushobject, sbsimObjName);
}
/// <summary>
/// ), (simObject, [groupList]) Query available static-fields for selected object./
///                                                                 @param simObject Object to query static-fields on.
///                                                                 @param groupList groups to filter static-fields against.
/// 			                                                    @return Space-seperated static-field list.)
/// 
/// </summary>

public string fn_FieldBrushObject_queryFields (string fieldbrushobject, string simObjName, string groupList)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_FieldBrushObject_queryFields'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",fieldbrushobject,simObjName,groupList));
var returnbuff = new StringBuilder(16384);
StringBuilder sbfieldbrushobject = null;
if (fieldbrushobject != null)
     sbfieldbrushobject = new StringBuilder(fieldbrushobject, 1024);
StringBuilder sbsimObjName = null;
if (simObjName != null)
     sbsimObjName = new StringBuilder(simObjName, 1024);
StringBuilder sbgroupList = null;
if (groupList != null)
     sbgroupList = new StringBuilder(groupList, 1024);

SafeNativeMethods.mwle_fn_FieldBrushObject_queryFields(sbfieldbrushobject, sbsimObjName, sbgroupList, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (simObject) Query available static-field groups for selected object./
///                                                                 @param simObject Object to query static-field groups on.
/// 			                                                    @return Space-seperated static-field group list.)
/// 
/// </summary>

public string fn_FieldBrushObject_queryGroups (string fieldbrushobject, string simObjName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_FieldBrushObject_queryGroups'" + string.Format("\"{0}\" \"{1}\" ",fieldbrushobject,simObjName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbfieldbrushobject = null;
if (fieldbrushobject != null)
     sbfieldbrushobject = new StringBuilder(fieldbrushobject, 1024);
StringBuilder sbsimObjName = null;
if (simObjName != null)
     sbsimObjName = new StringBuilder(simObjName, 1024);

SafeNativeMethods.mwle_fn_FieldBrushObject_queryGroups(sbfieldbrushobject, sbsimObjName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the base of a file name (removes extension and path)
/// 
///    @param fileName Name and path of file to check
///    @return String containing the file name, minus extension and path
///    @ingroup FileSystem)
/// 
/// </summary>

public string fn_fileBase (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileBase'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_fileBase(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns a platform specific formatted string with the creation time for the file.
/// 
///    @param fileName Name and path of file to check
///    @return Formatted string (OS specific) containing created time, \"9/3/2010 12:33:47 PM\" for example
///    @ingroup FileSystem)
/// 
/// </summary>

public string fn_fileCreatedTime (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileCreatedTime'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_fileCreatedTime(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Delete a file from the hard drive
/// 
/// 	@param path Name and path of the file to delete
/// 	@note THERE IS NO RECOVERY FROM THIS. Deleted file is gone for good.
/// 	@return True if file was successfully deleted
/// 	@ingroup FileSystem)
/// 
/// </summary>

public bool fn_fileDelete (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileDelete'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

return  SafeNativeMethods.mwle_fn_fileDelete(sbpath)>=1;
}
/// <summary>
/// @brief Get the extension of a file
/// 
/// 	@param fileName Name and path of file
/// 	@return String containing the extension, such as \".exe\" or \".cs\"
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_fileExt (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileExt'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_fileExt(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns a platform specific formatted string with the last modified time for the file.
/// 
/// 	@param fileName Name and path of file to check
/// 	@return Formatted string (OS specific) containing modified time, \"9/3/2010 12:33:47 PM\" for example
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_fileModifiedTime (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileModifiedTime'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_fileModifiedTime(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get only the file name of a path and file name string (removes path)
/// 
/// 	@param fileName Name and path of file to check
/// 	@return String containing the file name, minus the path
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_fileName (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileName'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_fileName(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ), FileObject.writeObject(SimObject, object prepend) 
/// 			  @hide)
/// 
/// </summary>

public void fn_FileObject_writeObject (string fileobject, string simName, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_FileObject_writeObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",fileobject,simName,objName));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);
StringBuilder sbsimName = null;
if (simName != null)
     sbsimName = new StringBuilder(simName, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_FileObject_writeObject(sbfileobject, sbsimName, sbobjName);
}
/// <summary>
/// @brief Get the path of a file (removes name and extension)
/// 
/// 	@param fileName Name and path of file to check
/// 	@return String containing the path, minus name and extension
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_filePath (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_filePath'" + string.Format("\"{0}\" ",fileName));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_filePath(sbfileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Determines the size of a file on disk
/// 
/// 	@param fileName Name and path of the file to check
/// 	@return Returns filesize in KB, or -1 if no file
/// 
/// 	@ingroup FileSystem)
/// 
/// </summary>

public int fn_fileSize (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_fileSize'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_fileSize(sbfileName);
}
/// <summary>
/// @brief Replaces the characters in a string with designated text
/// 
///    Uses the bad word filter to determine which characters within the string will be replaced.
/// 
///    @param baseString  The original string to filter.
///    @param replacementChars A string containing letters you wish to swap in the baseString.
///    @return The new scrambled string 
/// 
///    @see addBadWord()
///    @see containsBadWords()
/// 
///    @tsexample
///       // Create the base string, can come from anywhere
///       %baseString = \"Foobar\";
///       // Create a string of random letters
///       %replacementChars = \"knqwrtlzs\";
///       // Filter the string
///       %newString = filterString(%baseString, %replacementChars);
///       // Print the new string to console
///       echo(%newString);
///    @endtsexample
/// 
///    @ingroup Game)
/// 
/// </summary>

public string fn_filterString (string baseString, string replacementChars)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_filterString'" + string.Format("\"{0}\" \"{1}\" ",baseString,replacementChars));
var returnbuff = new StringBuilder(16384);
StringBuilder sbbaseString = null;
if (baseString != null)
     sbbaseString = new StringBuilder(baseString, 1024);
StringBuilder sbreplacementChars = null;
if (replacementChars != null)
     sbreplacementChars = new StringBuilder(replacementChars, 1024);

SafeNativeMethods.mwle_fn_filterString(sbbaseString, sbreplacementChars, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the first file in the directory system matching the given pattern.
/// 
///    Use the corresponding findNextFile() to step through 
///    the results.  If you're only interested in the number of files returned by the 
///    pattern match, use getFileCount().
/// 
///    This function differs from findFirstFileMultiExpr() in that it supports a single search 
///    pattern being passed in.
/// 
///    @note You cannot run multiple simultaneous file system searches with these functions.  Each 
///    call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders 
///    a previous search invalid.
/// 
///    @param pattern The path and file name pattern to match against.
///    @param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern.
///    @return The path of the first file matched by the search or an empty string if no matching file could be found.
/// 
///    @tsexample
///       // Execute all .cs files in a subdirectory and its subdirectories.
///       for( %file = findFirstFile( \"subdirectory/*.cs\" ); %file !$= \"\"; %file = findNextFile() )
///          exec( %file );
///    @endtsexample
/// 
///    @see findNextFile()
///    @see getFileCount()
///    @see findFirstFileMultiExpr()
///    @ingroup FileSearches )
/// 
/// </summary>

public string fn_findFirstFile (string pattern, bool recurse)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_findFirstFile'" + string.Format("\"{0}\" \"{1}\" ",pattern,recurse));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_findFirstFile(sbpattern, recurse, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the first file in the directory system matching the given patterns.
/// 
///    Use the corresponding findNextFileMultiExpr() to step through 
///    the results.  If you're only interested in the number of files returned by the 
///    pattern match, use getFileCountMultiExpr().
/// 
///    This function differs from findFirstFile() in that it supports multiple search patterns 
///    to be passed in.
/// 
///    @note You cannot run multiple simultaneous file system searches with these functions.  Each 
///    call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders 
///    a previous search invalid.
/// 
/// 	@param pattern The path and file name pattern to match against, such as *.cs.  Separate 
///    multiple patterns with TABs.  For example: \"*.cs\" TAB \"*.dso\"
/// 	@param recurse If true, the search will exhaustively recurse into subdirectories 
/// 	of the given path and match the given filename patterns.
///    @return String of the first matching file path, or an empty string if no matching 
///    files were found.
/// 
///    @tsexample
///       // Find all DTS or Collada models
///       %filePatterns = \"*.dts\" TAB \"*.dae\";
///       %fullPath = findFirstFileMultiExpr( %filePatterns );
///       while ( %fullPath !$= \"\" )
///       {
///          echo( %fullPath );
///          %fullPath = findNextFileMultiExpr( %filePatterns );
///       }
///    @endtsexample
/// 
///    @see findNextFileMultiExpr()
///    @see getFileCountMultiExpr()
///    @see findFirstFile()
/// 	@ingroup FileSearches)
/// 
/// </summary>

public string fn_findFirstFileMultiExpr (string pattern, bool recurse)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_findFirstFileMultiExpr'" + string.Format("\"{0}\" \"{1}\" ",pattern,recurse));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_findFirstFileMultiExpr(sbpattern, recurse, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  ),
///    @brief Returns the next file matching a search begun in findFirstFile().
/// 
///    @param pattern The path and file name pattern to match against.  This is optional 
///    and may be left out as it is not used by the code.  It is here for legacy reasons.
///    @return The path of the next filename matched by the search or an empty string if no more files match.
/// 
///    @tsexample
///       // Execute all .cs files in a subdirectory and its subdirectories.
///       for( %file = findFirstFile( \"subdirectory/*.cs\" ); %file !$= \"\"; %file = findNextFile() )
///          exec( %file );
///    @endtsexample
/// 
///    @see findFirstFile()
///    @ingroup FileSearches )
/// 
/// </summary>

public string fn_findNextFile (string pattern)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_findNextFile'" + string.Format("\"{0}\" ",pattern));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_findNextFile(sbpattern, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ),
///    @brief Returns the next file matching a search begun in findFirstFileMultiExpr().
/// 
/// 	@param pattern The path and file name pattern to match against.  This is optional 
///    and may be left out as it is not used by the code.  It is here for legacy reasons.
///    @return String of the next matching file path, or an empty string if no matching 
///    files were found.
/// 
///    @tsexample
///       // Find all DTS or Collada models
///       %filePatterns = \"*.dts\" TAB \"*.dae\";
///       %fullPath = findFirstFileMultiExpr( %filePatterns );
///       while ( %fullPath !$= \"\" )
///       {
///          echo( %fullPath );
///          %fullPath = findNextFileMultiExpr( %filePatterns );
///       }
///    @endtsexample
/// 
///    @see findFirstFileMultiExpr()
/// 	@ingroup FileSearches)
/// 
/// </summary>

public string fn_findNextFileMultiExpr (string pattern)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_findNextFileMultiExpr'" + string.Format("\"{0}\" ",pattern));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_findNextFileMultiExpr(sbpattern, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the first word in @a text.
///    @param text A list of words separated by newlines, spaces, and/or tabs.
///    @return The word at index 0 in @a text or \"\" if @a text is empty.
///    @note This is equal to 
///    @tsexample_nopar
///       getWord( text, 0 )
///    @endtsexample
///    @see getWord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_firstWord (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_firstWord'" + string.Format("\"{0}\" ",text));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_firstWord(sbtext, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Flags all currently allocated GFX resources.
///    Used for resource allocation and leak tracking by flagging 
///    current resources then dumping a list of unflagged resources 
///    at some later point in execution.
///    @ingroup GFX
///    @see listGFXResources, clearGFXResourceFlags, describeGFXResources )
/// 
/// </summary>

public void fn_flagCurrentGFXResources ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_flagCurrentGFXResources'");


SafeNativeMethods.mwle_fn_flagCurrentGFXResources();
}
/// <summary>
/// Releases all textures and resurrects the texture manager.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_flushTextureCache ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_flushTextureCache'");


SafeNativeMethods.mwle_fn_flushTextureCache();
}
/// <summary>
/// () )
/// 
/// </summary>

public void fn_Forest_clear (string forest)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Forest_clear'" + string.Format("\"{0}\" ",forest));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);

SafeNativeMethods.mwle_fn_Forest_clear(sbforest);
}
/// <summary>
/// ())
/// 
/// </summary>

public bool fn_Forest_isDirty (string forest)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Forest_isDirty'" + string.Format("\"{0}\" ",forest));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);

return  SafeNativeMethods.mwle_fn_Forest_isDirty(sbforest)>=1;
}
/// <summary>
/// ())
/// 
/// </summary>

public void fn_Forest_regenCells (string forest)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Forest_regenCells'" + string.Format("\"{0}\" ",forest));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);

SafeNativeMethods.mwle_fn_Forest_regenCells(sbforest);
}
/// <summary>
/// saveDataFile( [path] ) )
/// 
/// </summary>

public void fn_Forest_saveDataFile (string forest, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Forest_saveDataFile'" + string.Format("\"{0}\" \"{1}\" ",forest,path));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_Forest_saveDataFile(sbforest, sbpath);
}
/// <summary>
/// ( ForestItemData obj ) )
/// 
/// </summary>

public bool fn_ForestBrush_containsItemData (string forestbrush, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestBrush_containsItemData'" + string.Format("\"{0}\" \"{1}\" ",forestbrush,obj));
StringBuilder sbforestbrush = null;
if (forestbrush != null)
     sbforestbrush = new StringBuilder(forestbrush, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fn_ForestBrush_containsItemData(sbforestbrush, sbobj)>=1;
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestBrushTool_collectElements (string forestbrushtool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestBrushTool_collectElements'" + string.Format("\"{0}\" ",forestbrushtool));
StringBuilder sbforestbrushtool = null;
if (forestbrushtool != null)
     sbforestbrushtool = new StringBuilder(forestbrushtool, 1024);

SafeNativeMethods.mwle_fn_ForestBrushTool_collectElements(sbforestbrushtool);
}
/// <summary>
/// ( ForestItemData obj ) )
/// 
/// </summary>

public void fn_ForestEditorCtrl_deleteMeshSafe (string foresteditorctrl, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestEditorCtrl_deleteMeshSafe'" + string.Format("\"{0}\" \"{1}\" ",foresteditorctrl,obj));
StringBuilder sbforesteditorctrl = null;
if (foresteditorctrl != null)
     sbforesteditorctrl = new StringBuilder(foresteditorctrl, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fn_ForestEditorCtrl_deleteMeshSafe(sbforesteditorctrl, sbobj);
}
/// <summary>
/// () )
/// 
/// </summary>

public int fn_ForestEditorCtrl_getActiveTool (string foresteditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestEditorCtrl_getActiveTool'" + string.Format("\"{0}\" ",foresteditorctrl));
StringBuilder sbforesteditorctrl = null;
if (foresteditorctrl != null)
     sbforesteditorctrl = new StringBuilder(foresteditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_ForestEditorCtrl_getActiveTool(sbforesteditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public bool fn_ForestEditorCtrl_isDirty (string foresteditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestEditorCtrl_isDirty'" + string.Format("\"{0}\" ",foresteditorctrl));
StringBuilder sbforesteditorctrl = null;
if (foresteditorctrl != null)
     sbforesteditorctrl = new StringBuilder(foresteditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_ForestEditorCtrl_isDirty(sbforesteditorctrl)>=1;
}
/// <summary>
/// ( ForestTool tool ) )
/// 
/// </summary>

public void fn_ForestEditorCtrl_setActiveTool (string foresteditorctrl, string toolName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestEditorCtrl_setActiveTool'" + string.Format("\"{0}\" \"{1}\" ",foresteditorctrl,toolName));
StringBuilder sbforesteditorctrl = null;
if (foresteditorctrl != null)
     sbforesteditorctrl = new StringBuilder(foresteditorctrl, 1024);
StringBuilder sbtoolName = null;
if (toolName != null)
     sbtoolName = new StringBuilder(toolName, 1024);

SafeNativeMethods.mwle_fn_ForestEditorCtrl_setActiveTool(sbforesteditorctrl, sbtoolName);
}
/// <summary>
/// () )
/// 
/// </summary>

public void fn_ForestEditorCtrl_updateActiveForest (string foresteditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestEditorCtrl_updateActiveForest'" + string.Format("\"{0}\" ",foresteditorctrl));
StringBuilder sbforesteditorctrl = null;
if (foresteditorctrl != null)
     sbforesteditorctrl = new StringBuilder(foresteditorctrl, 1024);

SafeNativeMethods.mwle_fn_ForestEditorCtrl_updateActiveForest(sbforesteditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestSelectionTool_clearSelection (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_clearSelection'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

SafeNativeMethods.mwle_fn_ForestSelectionTool_clearSelection(sbforestselectiontool);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestSelectionTool_copySelection (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_copySelection'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

SafeNativeMethods.mwle_fn_ForestSelectionTool_copySelection(sbforestselectiontool);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestSelectionTool_cutSelection (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_cutSelection'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

SafeNativeMethods.mwle_fn_ForestSelectionTool_cutSelection(sbforestselectiontool);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestSelectionTool_deleteSelection (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_deleteSelection'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

SafeNativeMethods.mwle_fn_ForestSelectionTool_deleteSelection(sbforestselectiontool);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_ForestSelectionTool_getSelectionCount (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_getSelectionCount'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

return  SafeNativeMethods.mwle_fn_ForestSelectionTool_getSelectionCount(sbforestselectiontool);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_ForestSelectionTool_pasteSelection (string forestselectiontool)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ForestSelectionTool_pasteSelection'" + string.Format("\"{0}\" ",forestselectiontool));
StringBuilder sbforestselectiontool = null;
if (forestselectiontool != null)
     sbforestselectiontool = new StringBuilder(forestselectiontool, 1024);

SafeNativeMethods.mwle_fn_ForestSelectionTool_pasteSelection(sbforestselectiontool);
}
/// <summary>
/// Returns the count of active DDSs files in memory.
///    @ingroup Rendering )
/// 
/// </summary>

public int fn_getActiveDDSFiles ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getActiveDDSFiles'");


return  SafeNativeMethods.mwle_fn_getActiveDDSFiles();
}
/// <summary>
/// Returns the active light manager name.
///    @ingroup Lighting )
/// 
/// </summary>

public string fn_getActiveLightManager ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getActiveLightManager'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getActiveLightManager(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the version of the application build, as a string. 
///             @ingroup Debugging)
/// 
/// </summary>

public int fn_getAppVersionNumber ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getAppVersionNumber'");


return  SafeNativeMethods.mwle_fn_getAppVersionNumber();
}
/// <summary>
/// Get the version of the aplication build, as a human readable string. 
///             @ingroup Debugging)
/// 
/// </summary>

public string fn_getAppVersionString ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getAppVersionString'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getAppVersionString(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the best texture format for storage of HDR data for the active device.
///    @ingroup GFX )
/// 
/// </summary>

public int fn_getBestHDRFormat ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getBestHDRFormat'");


return  SafeNativeMethods.mwle_fn_getBestHDRFormat();
}
/// <summary>
/// Returns image info in the following format: width TAB height TAB bytesPerPixel. 
///    It will return an empty string if the file is not found.
///    @ingroup Rendering )
/// 
/// </summary>

public string fn_getBitmapInfo (string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getBitmapInfo'" + string.Format("\"{0}\" ",filename));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_getBitmapInfo(sbfilename, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the center point of an axis-aligned box.
///    @param b A Box3F, in string format using \"minExtentX minExtentY minExtentZ maxExtentX maxExtentY maxExtentZ\"
///    @return Center of the box.
///    @ingroup Math)
/// 
/// </summary>

public string fn_getBoxCenter (string box)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getBoxCenter'" + string.Format("\"{0}\" ",box));
var returnbuff = new StringBuilder(1024);
StringBuilder sbbox = null;
if (box != null)
     sbbox = new StringBuilder(box, 1024);

SafeNativeMethods.mwle_fn_getBoxCenter(sbbox, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the type of build, \"Debug\" or \"Release\".
/// 				@ingroup Debugging)
/// 
/// </summary>

public string fn_getBuildString ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getBuildString'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getBuildString(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the category of the given class.
/// 				@param className The name of the class.
/// 				@ingroup Console)
/// 
/// </summary>

public string fn_getCategoryOfClass (string className)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getCategoryOfClass'" + string.Format("\"{0}\" ",className));
var returnbuff = new StringBuilder(16384);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

SafeNativeMethods.mwle_fn_getCategoryOfClass(sbclassName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
/// 				@brief Get text from the clipboard.
/// 				@internal)
/// 
/// </summary>

public string fn_getClipboard ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getClipboard'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getClipboard(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the time of compilation. 
/// 				@ingroup Debugging)
/// 
/// </summary>

public string fn_getCompileTimeString ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getCompileTimeString'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getCompileTimeString(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
/// 				@brief Gets the primary LangTable used by the game
/// 				@return ID of the core LangTable
/// 				@ingroup Localization)
/// 
/// </summary>

public int fn_getCoreLangTable ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getCoreLangTable'");


return  SafeNativeMethods.mwle_fn_getCoreLangTable();
}
/// <summary>
/// @brief Returns the current %ActionMap.
///    @see ActionMap
/// 	@ingroup Input)
/// 
/// </summary>

public string fn_getCurrentActionMap ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getCurrentActionMap'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getCurrentActionMap(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Return the current working directory.
///    @return The absolute path of the current working directory.
///    @note Only present in a Tools build of Torque.
///    @see getWorkingDirectory()
///    @ingroup FileSystem)
/// 
/// </summary>

public string fn_getCurrentDirectory ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getCurrentDirectory'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getCurrentDirectory(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the description string for the named class.
/// 				@param className The name of the class.
/// 				@return The class description in string format.
/// 				@ingroup Console)
/// 
/// </summary>

public string fn_getDescriptionOfClass (string className)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDescriptionOfClass'" + string.Format("\"{0}\" ",className));
var returnbuff = new StringBuilder(16384);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

SafeNativeMethods.mwle_fn_getDescriptionOfClass(sbclassName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the width, height, and bitdepth of the screen/desktop.@ingroup GFX )
/// 
/// </summary>

public string fn_getDesktopResolution ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDesktopResolution'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getDesktopResolution(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gathers a list of directories starting at the given path.
/// 
/// 	@param path String containing the path of the directory
/// 	@param depth Depth of search, as in how many subdirectories to parse through
/// 	@return Tab delimited string containing list of directories found during search, \"\" if no files were found
/// 
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_getDirectoryList (string path, int depth)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDirectoryList'" + string.Format("\"{0}\" \"{1}\" ",path,depth));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_getDirectoryList(sbpath, depth, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the string describing the active GFX device.
///    @ingroup GFX )
/// 
/// </summary>

public string fn_getDisplayDeviceInformation ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDisplayDeviceInformation'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getDisplayDeviceInformation(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns a tab-seperated string of the detected devices across all adapters.
///    @ingroup GFX )
/// 
/// </summary>

public string fn_getDisplayDeviceList ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDisplayDeviceList'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getDisplayDeviceList(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the absolute path to the file in which the compiled code for the given script file will be stored.
///    @param scriptFileName %Path to the .cs script file.
///    @return The absolute path to the .dso file for the given script file.
///    @note The compiler will store newly compiled DSOs in the prefs path but pre-existing DSOs will be loaded 
///       from the current paths.
///    @see compile
///    @see getPrefsPath
///    @ingroup Scripting )
/// 
/// </summary>

public string fn_getDSOPath (string scriptFileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getDSOPath'" + string.Format("\"{0}\" ",scriptFileName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbscriptFileName = null;
if (scriptFileName != null)
     sbscriptFileName = new StringBuilder(scriptFileName, 1024);

SafeNativeMethods.mwle_fn_getDSOPath(sbscriptFileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the engine product that this is running from, as a string. 
/// 				@ingroup Debugging)
/// 
/// </summary>

public string fn_getEngineName ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getEngineName'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getEngineName(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getEventTimeLeft(scheduleId) Get the time left in ms until this event will trigger.)
/// 
/// </summary>

public int fn_getEventTimeLeft (int scheduleId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getEventTimeLeft'" + string.Format("\"{0}\" ",scheduleId));

return  SafeNativeMethods.mwle_fn_getEventTimeLeft(scheduleId);
}
/// <summary>
/// @brief Gets the name of the game's executable
/// 
/// 	@return String containing this game's executable name
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_getExecutableName ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getExecutableName'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getExecutableName(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Gets the clients far clipping.
///    )
/// 
/// </summary>

public float fn_getFarClippingDistance ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFarClippingDistance'");


return  SafeNativeMethods.mwle_fn_getFarClippingDistance();
}
/// <summary>
/// Extract the field at the given @a index in the newline and/or tab separated list in @a text.
///    Fields in @a text must be separated by newlines and/or tabs.
///    @param text A list of fields separated by newlines and/or tabs.
///    @param index The zero-based index of the field to extract.
///    @return The field at the given index or \"\" if the index is out of range.
///    @tsexample
///       getField( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"c d\"
///    @endtsexample
///    @see getFields
///    @see getFieldCount
///    @see getWord
///    @see getRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getField (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getField'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getField(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the number of newline and/or tab separated fields in @a text.
///    @param text A list of fields separated by newlines and/or tabs.
///    @return The number of newline and/or tab sepearated elements in @a text.
///    @tsexample
///       getFieldCount( \"a b\" TAB \"c d\" TAB \"e f\" ) // Returns 3
///    @endtsexample
///    @see getWordCount
///    @see getRecordCount
///    @ingroup FieldManip )
/// 
/// </summary>

public int fn_getFieldCount (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFieldCount'" + string.Format("\"{0}\" ",text));
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_getFieldCount(sbtext);
}
/// <summary>
/// Extract a range of fields from the given @a startIndex onwards thru @a endIndex.
///    Fields in @a text must be separated by newlines and/or tabs.
///    @param text A list of fields separated by newlines and/or tabs.
///    @param startIndex The zero-based index of the first field to extract from @a text.
///    @param endIndex The zero-based index of the last field to extract from @a text.  If this is -1, all fields beginning 
///       with @a startIndex are extracted from @a text.
///    @return A string containing the specified range of fields from @a text or \"\" if @a startIndex 
///       is out of range or greater than @a endIndex.
///    @tsexample
///       getFields( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"c d\" TAB \"e f\"
///    @endtsexample
///    @see getField
///    @see getFieldCount
///    @see getWords
///    @see getRecords
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getFields (string text, int startIndex, int endIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFields'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,startIndex,endIndex));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getFields(sbtext, startIndex, endIndex, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the number of files in the directory tree that match the given patterns
/// 
///    This function differs from getFileCountMultiExpr() in that it supports a single search 
///    pattern being passed in.
/// 
///    If you're interested in a list of files that match the given pattern and not just 
///    the number of files, use findFirstFile() and findNextFile().
/// 
///    @param pattern The path and file name pattern to match against.
///    @param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern 
///       counting files in subdirectories.
///    @return Number of files located using the pattern
/// 
///    @tsexample
///       // Count the number of .cs files in a subdirectory and its subdirectories.
///       getFileCount( \"subdirectory/*.cs\" );
///    @endtsexample
/// 
///    @see findFirstFile()
///    @see findNextFile()
///    @see getFileCountMultiExpr()
///    @ingroup FileSearches )
/// 
/// </summary>

public int fn_getFileCount (string pattern, bool recurse)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFileCount'" + string.Format("\"{0}\" \"{1}\" ",pattern,recurse));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

return  SafeNativeMethods.mwle_fn_getFileCount(sbpattern, recurse);
}
/// <summary>
/// @brief Returns the number of files in the directory tree that match the given patterns
/// 
///    If you're interested in a list of files that match the given patterns and not just 
///    the number of files, use findFirstFileMultiExpr() and findNextFileMultiExpr().
/// 
/// 	@param pattern The path and file name pattern to match against, such as *.cs.  Separate 
///    multiple patterns with TABs.  For example: \"*.cs\" TAB \"*.dso\"
/// 	@param recurse If true, the search will exhaustively recurse into subdirectories 
/// 	of the given path and match the given filename pattern.
/// 	@return Number of files located using the patterns
/// 
///    @tsexample
///       // Count all DTS or Collada models
///       %filePatterns = \"*.dts\" TAB \"*.dae\";
///       echo( \"Nunmer of shape files:\" SPC getFileCountMultiExpr( %filePatterns ) );
///    @endtsexample
/// 
///    @see findFirstFileMultiExpr()
///    @see findNextFileMultiExpr()
/// 	@ingroup FileSearches)
/// 
/// </summary>

public int fn_getFileCountMultiExpr (string pattern, bool recurse)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFileCountMultiExpr'" + string.Format("\"{0}\" \"{1}\" ",pattern,recurse));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

return  SafeNativeMethods.mwle_fn_getFileCountMultiExpr(sbpattern, recurse);
}
/// <summary>
/// @brief Provides the CRC checksum of the given file.
///    
///    @param fileName The path to the file.
///    @return The calculated CRC checksum of the file, or -1 if the file 
///    could not be found.
///    
///    @ingroup FileSystem)
/// 
/// </summary>

public int fn_getFileCRC (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFileCRC'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_getFileCRC(sbfileName);
}
/// <summary>
/// Returns a list of supported shape format extensions separated by tabs.
///   Example output: *.dsq TAB *.dae TAB)
/// 
/// </summary>

public string fn_getFormatExtensions ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFormatExtensions'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getFormatExtensions(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns a list of supported shape formats in filter form.
///   Example output: DSQ Files|*.dsq|COLLADA Files|*.dae|)
/// 
/// </summary>

public string fn_getFormatFilters ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFormatFilters'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getFormatFilters(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief .)
/// 
/// </summary>

public string fn_getFrustumOffset ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFrustumOffset'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getFrustumOffset(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string funcName) 
/// 	@brief Provides the name of the package the function belongs to
/// 	@param funcName String containing name of the function
/// 	@return The name of the function's package
/// 	@ingroup Packages)
/// 
/// </summary>

public string fn_getFunctionPackage (string funcName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getFunctionPackage'" + string.Format("\"{0}\" ",funcName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbfuncName = null;
if (funcName != null)
     sbfuncName = new StringBuilder(funcName, 1024);

SafeNativeMethods.mwle_fn_getFunctionPackage(sbfuncName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getJoystickAxes( instance ))
/// 
/// </summary>

public string fn_getJoystickAxes (uint deviceID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getJoystickAxes'" + string.Format("\"{0}\" ",deviceID));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getJoystickAxes(deviceID, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns a tab seperated list of light manager names.
///    @ingroup Lighting )
/// 
/// </summary>

public string fn_getLightManagerNames ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getLightManagerNames'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getLightManagerNames(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the absolute path to the directory that contains the main.cs script from which the engine was started.
/// 
///    This directory will usually contain all the game assets and, in a user-side game installation, will usually be 
///    read-only.
///    @return The path to the main game assets.
///    @ingroup FileSystem)
/// 
/// </summary>

public string fn_getMainDotCsDir ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMainDotCsDir'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getMainDotCsDir(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @hide)
/// 
/// </summary>

public string fn_getMapEntry (string texName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMapEntry'" + string.Format("\"{0}\" ",texName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtexName = null;
if (texName != null)
     sbtexName = new StringBuilder(texName, 1024);

SafeNativeMethods.mwle_fn_getMapEntry(sbtexName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string texName)
///    @brief Returns the name of the material mapped to this texture.
///    If no materials are found, an empty string is returned.
///    @param texName Name of the texture
///    @ingroup Materials)
/// 
/// </summary>

public string fn_getMaterialMapping (string texName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMaterialMapping'" + string.Format("\"{0}\" ",texName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtexName = null;
if (texName != null)
     sbtexName = new StringBuilder(texName, 1024);

SafeNativeMethods.mwle_fn_getMaterialMapping(sbtexName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Calculate the greater of two specified numbers.
///     @param v1 Input value.
///     @param v2 Input value.
///     @returns The greater value of the two specified values.
///     @ingroup Math )
/// 
/// </summary>

public float fn_getMax (float v1, float v2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMax'" + string.Format("\"{0}\" \"{1}\" ",v1,v2));

return  SafeNativeMethods.mwle_fn_getMax(v1, v2);
}
/// <summary>
/// getMaxFrameAllocation(); )
/// 
/// </summary>

public int fn_getMaxFrameAllocation ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMaxFrameAllocation'");


return  SafeNativeMethods.mwle_fn_getMaxFrameAllocation();
}
/// <summary>
/// (string namespace, string method) 
/// 	@brief Provides the name of the package the method belongs to
/// 	@param namespace Class or namespace, such as Player
/// 	@param method Name of the funciton to search for
/// 	@return The name of the method's package
/// 	@ingroup Packages)
/// 
/// </summary>

public string fn_getMethodPackage (string nameSpace, string method)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMethodPackage'" + string.Format("\"{0}\" \"{1}\" ",nameSpace,method));
var returnbuff = new StringBuilder(16384);
StringBuilder sbnameSpace = null;
if (nameSpace != null)
     sbnameSpace = new StringBuilder(nameSpace, 1024);
StringBuilder sbmethod = null;
if (method != null)
     sbmethod = new StringBuilder(method, 1024);

SafeNativeMethods.mwle_fn_getMethodPackage(sbnameSpace, sbmethod, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Calculate the lesser of two specified numbers.
///     @param v1 Input value.
///     @param v2 Input value.
///     @returns The lesser value of the two specified values.
///     @ingroup Math )
/// 
/// </summary>

public float fn_getMin (float v1, float v2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMin'" + string.Format("\"{0}\" \"{1}\" ",v1,v2));

return  SafeNativeMethods.mwle_fn_getMin(v1, v2);
}
/// <summary>
/// Get the MissionArea object, if any.
/// 					 @ingroup enviroMisc)
/// 
/// </summary>

public string fn_getMissionAreaServerObject ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getMissionAreaServerObject'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getMissionAreaServerObject(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string path) 
/// 				@brief Attempts to extract a mod directory from path. Returns empty string on failure.
/// 				@param File path of mod folder
/// 				@note This is no longer relevant in Torque 3D (which does not use mod folders), should be deprecated
/// 				@internal)
/// 
/// </summary>

public string fn_getModNameFromPath (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getModNameFromPath'" + string.Format("\"{0}\" ",path));
var returnbuff = new StringBuilder(16384);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_getModNameFromPath(sbpath, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the EventManager object for all NavMesh updates.)
/// 
/// </summary>

public int fn_getNavMeshEventManager ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getNavMeshEventManager'");


return  SafeNativeMethods.mwle_fn_getNavMeshEventManager();
}
/// <summary>
/// @brief Returns a space delimited list of the active packages in stack order.
///    @ingroup Packages)
/// 
/// </summary>

public string fn_getPackageList ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getPackageList'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getPackageList(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the pixel shader version for the active device.
///    @ingroup GFX )
/// 
/// </summary>

public float fn_getPixelShaderVersion ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getPixelShaderVersion'");


return  SafeNativeMethods.mwle_fn_getPixelShaderVersion();
}
/// <summary>
/// ([relativeFileName]) 
/// 				@note Appears to be useless in Torque 3D, should be deprecated
/// 				@internal)
/// 
/// </summary>

public string fn_getPrefsPath (string relativeFileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getPrefsPath'" + string.Format("\"{0}\" ",relativeFileName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbrelativeFileName = null;
if (relativeFileName != null)
     sbrelativeFileName = new StringBuilder(relativeFileName, 1024);

SafeNativeMethods.mwle_fn_getPrefsPath(sbrelativeFileName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( int a, int b ) 
///    @brief Returns a random number based on parameters passed in..
///    If no parameters are passed in, getRandom() will return a float between 0.0 and 1.0. If one 
///    parameter is passed an integer between 0 and the passed in value will be returned. Two parameters will 
///    return an integer between the specified numbers.
///    @param a If this is the only parameter, a number between 0 and a is returned. Elsewise represents the lower bound.
///    @param b Upper bound on the random number.  The random number will be = @a b.
///    @return A pseudo-random integer between @a a and @a b, between 0 and a, or a 
///    float between 0.0 and 1.1 depending on usage.
///    @note All parameters are optional.
///    @see setRandomSeed
///    @ingroup Random )
/// 
/// </summary>

public float fn_getRandom (int a, int b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRandom'" + string.Format("\"{0}\" \"{1}\" ",a,b));

return  SafeNativeMethods.mwle_fn_getRandom(a, b);
}
/// <summary>
/// Get the current seed used by the random number generator.
///    @return The current random number generator seed value.
///    @ingroup Random )
/// 
/// </summary>

public int fn_getRandomSeed ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRandomSeed'");


return  SafeNativeMethods.mwle_fn_getRandomSeed();
}
/// <summary>
/// () 
/// 				@brief Return the current real time in milliseconds.
///                 Real time is platform defined; typically time since the computer booted.
/// 				@ingroup Platform)
/// 
/// </summary>

public int fn_getRealTime ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRealTime'");


return  SafeNativeMethods.mwle_fn_getRealTime();
}
/// <summary>
/// Extract the record at the given @a index in the newline-separated list in @a text.
///    Records in @a text must be separated by newlines.
///    @param text A list of records separated by newlines.
///    @param index The zero-based index of the record to extract.
///    @return The record at the given index or \"\" if @a index is out of range.
///    @tsexample
///       getRecord( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"c d\"
///    @endtsexample
///    @see getRecords
///    @see getRecordCount
///    @see getWord
///    @see getField
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getRecord (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRecord'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getRecord(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the number of newline-separated records in @a text.
///    @param text A list of records separated by newlines.
///    @return The number of newline-sepearated elements in @a text.
///    @tsexample
///       getRecordCount( \"a b\" NL \"c d\" NL \"e f\" ) // Returns 3
///    @endtsexample
///    @see getWordCount
///    @see getFieldCount
///    @ingroup FieldManip )
/// 
/// </summary>

public int fn_getRecordCount (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRecordCount'" + string.Format("\"{0}\" ",text));
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_getRecordCount(sbtext);
}
/// <summary>
/// Extract a range of records from the given @a startIndex onwards thru @a endIndex.
///    Records in @a text must be separated by newlines.
///    @param text A list of records separated by newlines.
///    @param startIndex The zero-based index of the first record to extract from @a text.
///    @param endIndex The zero-based index of the last record to extract from @a text.  If this is -1, all records beginning 
///       with @a startIndex are extracted from @a text.
///    @return A string containing the specified range of records from @a text or \"\" if @a startIndex 
///       is out of range or greater than @a endIndex.
///    @tsexample
///       getRecords( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"c d\" NL \"e f\"
///    @endtsexample
///    @see getRecord
///    @see getRecordCount
///    @see getWords
///    @see getFields
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getRecords (string text, int startIndex, int endIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getRecords'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,startIndex,endIndex));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getRecords(sbtext, startIndex, endIndex, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getScheduleDuration(%scheduleId); )
/// 
/// </summary>

public int fn_getScheduleDuration (int scheduleId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getScheduleDuration'" + string.Format("\"{0}\" ",scheduleId));

return  SafeNativeMethods.mwle_fn_getScheduleDuration(scheduleId);
}
/// <summary>
/// getServerCount(...); )
/// 
/// </summary>

public int fn_getServerCount ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getServerCount'");


return  SafeNativeMethods.mwle_fn_getServerCount();
}
/// <summary>
/// () 
/// 				Return the current sim time in milliseconds.
///                 @brief Sim time is time since the game started.
/// 				@ingroup Platform)
/// 
/// </summary>

public int fn_getSimTime ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getSimTime'");


return  SafeNativeMethods.mwle_fn_getSimTime();
}
/// <summary>
/// @brief Return a substring of @a str starting at @a start and continuing either through to the end of @a str 
///    (if @a numChars is -1) or for @a numChars characters (except if this would exceed the actual source 
///    string length).
///    @param str The string from which to extract a substring.
///    @param start The offset at which to start copying out characters.
///    @param numChars Optional argument to specify the number of characters to copy.  If this is -1, all characters up the end 
///       of the input string are copied.
///    @return A string that contains the given portion of the input string.
///    @tsexample
///    getSubStr( \"foobar\", 1, 2 ) // Returns \"oo\".
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_getSubStr (string str, int start, int numChars)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getSubStr'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,start,numChars));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_getSubStr(sbstr, start, numChars, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( string textTagString ) 
///    @brief Extracts the tag from a tagged string
/// 
///    Should only be used within the context of a function that receives a tagged 
///    string, and is not meant to be used outside of this context.
/// 
///    @param textTagString The tagged string to extract.
/// 
///    @returns The tag ID of the string.
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see detag()
///    @ingroup Networking)
/// 
/// </summary>

public string fn_getTag (string textTagString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTag'" + string.Format("\"{0}\" ",textTagString));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtextTagString = null;
if (textTagString != null)
     sbtextTagString = new StringBuilder(textTagString, 1024);

SafeNativeMethods.mwle_fn_getTag(sbtextTagString, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ),
///    @brief Use the getTaggedString function to convert a tag to a string.
/// 
///    This is not the same as detag() which can only be used within the context 
///    of a function that receives a tag. This function can be used any time and 
///    anywhere to convert a tag to a string.
/// 
///    @param tag A numeric tag ID.
/// 
///    @returns The string as found in the Net String table.
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see addTaggedString()
///    @see removeTaggedString()
///    @ingroup Networking)
/// 	
/// </summary>

public string fn_getTaggedString (string tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTaggedString'" + string.Format("\"{0}\" ",tag));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtag = null;
if (tag != null)
     sbtag = new StringBuilder(tag, 1024);

SafeNativeMethods.mwle_fn_getTaggedString(sbtag, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the OS temporary directory, \"C:/Users/Mich/AppData/Local/Temp\" for example
/// 				@note This can be useful to adhering to OS standards and practices, 
/// 				but not really used in Torque 3D right now.
/// 				@note Be very careful when getting into OS level File I/O.
/// 				@return String containing path to OS temp directory
/// 				@note This is legacy function brought over from TGB, and does not appear 
/// 				to have much use. Possibly deprecate?
/// 				@ingroup FileSystem
/// 				@internal)
/// 
/// </summary>

public string fn_getTemporaryDirectory ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTemporaryDirectory'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getTemporaryDirectory(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Creates a name and extension for a potential temporary file
/// 				This does not create the actual file. It simply creates a random name 
/// 				for a file that does not exist.
/// 				@note This is legacy function brought over from TGB, and does not appear 
/// 				to have much use. Possibly deprecate?
/// 				@ingroup FileSystem
/// 				@internal)
/// 
/// </summary>

public string fn_getTemporaryFileName ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTemporaryFileName'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getTemporaryFileName(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (Point2 pos) - gets the terrain height at the specified position.
/// 				@param pos The world space point, minus the z (height) value Can be formatted as either (\"x y\") or (x,y)
/// 				@return Returns the terrain height at the given point as an F32 value.
/// 				@hide)
/// 
/// </summary>

public float fn_getTerrainHeight (string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTerrainHeight'" + string.Format("\"{0}\" ",pos));
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

return  SafeNativeMethods.mwle_fn_getTerrainHeight(sbpos);
}
/// <summary>
/// (Point3F pos) - gets the terrain height at the specified position.
/// 				@param pos The world space point. Can be formatted as either (\"x y z\") or (x,y,z)
/// 				@note This function is useful if you simply want to grab the terrain height underneath an object.
/// 				@return Returns the terrain height at the given point as an F32 value.
/// 				@hide)
/// 
/// </summary>

public float fn_getTerrainHeightBelowPosition (string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTerrainHeightBelowPosition'" + string.Format("\"{0}\" ",pos));
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

return  SafeNativeMethods.mwle_fn_getTerrainHeightBelowPosition(sbpos);
}
/// <summary>
/// (Point3F x/y/z) Gets the terrain block that is located under the given world point.
///                                                       @param x/y/z The world coordinates (floating point values) you wish to query at.  
///                                                       These can be formatted as either a string (\"x y z\") or separately as (x, y, z)
///                                                       @return Returns the ID of the requested terrain block (0 if not found).
/// 													  @hide)
/// 
/// </summary>

public int fn_getTerrainUnderWorldPoint (string position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTerrainUnderWorldPoint'" + string.Format("\"{0}\" ",position));
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);

return  SafeNativeMethods.mwle_fn_getTerrainUnderWorldPoint(sbposition);
}
/// <summary>
/// Returns a list of texture profiles in the format: ProfileName TextureCount TextureMB
///    @ingroup GFX )
/// 
/// </summary>

public string fn_getTextureProfileStats ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTextureProfileStats'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getTextureProfileStats(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getTimeSinceStart(%scheduleId); )
/// 
/// </summary>

public int fn_getTimeSinceStart (int scheduleId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTimeSinceStart'" + string.Format("\"{0}\" ",scheduleId));

return  SafeNativeMethods.mwle_fn_getTimeSinceStart(scheduleId);
}
/// <summary>
/// Get the numeric suffix of the given input string.
///    @param str The string from which to read out the numeric suffix.
///    @return The numeric value of the number suffix of @a str or -1 if @a str has no such suffix.
///    @tsexample
///    getTrailingNumber( \"test123\" ) // Returns '123'.
///    @endtsexample
///    @see stripTrailingNumber
///    @ingroup Strings )
/// 
/// </summary>

public int fn_getTrailingNumber (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getTrailingNumber'" + string.Format("\"{0}\" ",str));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_getTrailingNumber(sbstr);
}
/// <summary>
/// ( String baseName, SimSet set, bool searchChildren )
///    @brief Returns a unique unused internal name within the SimSet/Group based on a given base name.
///    @note Currently only used by editors
///    @ingroup Editors
///    @internal)
/// 
/// </summary>

public string fn_getUniqueInternalName (string baseName, string setString, bool searchChildren)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getUniqueInternalName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",baseName,setString,searchChildren));
var returnbuff = new StringBuilder(16384);
StringBuilder sbbaseName = null;
if (baseName != null)
     sbbaseName = new StringBuilder(baseName, 1024);
StringBuilder sbsetString = null;
if (setString != null)
     sbsetString = new StringBuilder(setString, 1024);

SafeNativeMethods.mwle_fn_getUniqueInternalName(sbbaseName, sbsetString, searchChildren, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( String baseName )
/// 	@brief Returns a unique unused SimObject name based on a given base name.
/// 	@baseName Name to conver to a unique string if another instance exists
/// 	@note Currently only used by editors
/// 	@ingroup Editors
/// 	@internal)
/// 
/// </summary>

public string fn_getUniqueName (string baseName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getUniqueName'" + string.Format("\"{0}\" ",baseName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbbaseName = null;
if (baseName != null)
     sbbaseName = new StringBuilder(baseName, 1024);

SafeNativeMethods.mwle_fn_getUniqueName(sbbaseName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getUserDataDirectory())
/// 
/// </summary>

public string fn_getUserDataDirectory ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getUserDataDirectory'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getUserDataDirectory(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getUserHomeDirectory())
/// 
/// </summary>

public string fn_getUserHomeDirectory ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getUserHomeDirectory'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getUserHomeDirectory(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string varName) 
///    @brief Returns the value of the named variable or an empty string if not found.
///    @varName Name of the variable to search for
///    @return Value contained by varName, \"\" if the variable does not exist
///    @ingroup Scripting)
/// 
/// </summary>

public string fn_getVariable (string varName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getVariable'" + string.Format("\"{0}\" ",varName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbvarName = null;
if (varName != null)
     sbvarName = new StringBuilder(varName, 1024);

SafeNativeMethods.mwle_fn_getVariable(sbvarName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the version of the engine build, as a string. 
/// 				@ingroup Debugging)
/// 
/// </summary>

public int fn_getVersionNumber ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getVersionNumber'");


return  SafeNativeMethods.mwle_fn_getVersionNumber();
}
/// <summary>
/// Get the version of the engine build, as a human readable string. 
/// 				@ingroup Debugging)
/// 
/// </summary>

public string fn_getVersionString ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getVersionString'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_getVersionString(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Test whether Torque is running in web-deployment mode.
///    In this mode, Torque will usually run within a browser and certain restrictions apply (e.g. Torque will not 
///    be able to enter fullscreen exclusive mode).
///    @return True if Torque is running in web-deployment mode.
///    @ingroup Platform )
/// 
/// </summary>

public bool fn_getWebDeployment ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getWebDeployment'");


return  SafeNativeMethods.mwle_fn_getWebDeployment()>=1;
}
/// <summary>
/// Extract the word at the given @a index in the whitespace-separated list in @a text.
///    Words in @a text must be separated by newlines, spaces, and/or tabs.
///    @param text A whitespace-separated list of words.
///    @param index The zero-based index of the word to extract.
///    @return The word at the given index or \"\" if the index is out of range.
///    @tsexample
///       getWord( \"a b c\", 1 ) // Returns \"b\"
///    @endtsexample
///    @see getWords
///    @see getWordCount
///    @see getField
///    @see getRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getWord (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getWord'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getWord(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the number of whitespace-separated words in @a text.
///    Words in @a text must be separated by newlines, spaces, and/or tabs.
///    @param text A whitespace-separated list of words.
///    @return The number of whitespace-separated words in @a text.
///    @tsexample
///       getWordCount( \"a b c d e\" ) // Returns 5
///    @endtsexample
///    @see getFieldCount
///    @see getRecordCount
///    @ingroup FieldManip )
/// 
/// </summary>

public int fn_getWordCount (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getWordCount'" + string.Format("\"{0}\" ",text));
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_getWordCount(sbtext);
}
/// <summary>
/// Extract a range of words from the given @a startIndex onwards thru @a endIndex.
///    Words in @a text must be separated by newlines, spaces, and/or tabs.
///    @param text A whitespace-separated list of words.
///    @param startIndex The zero-based index of the first word to extract from @a text.
///    @param endIndex The zero-based index of the last word to extract from @a text.  If this is -1, all words beginning 
///       with @a startIndex are extracted from @a text.
///    @return A string containing the specified range of words from @a text or \"\" if @a startIndex 
///       is out of range or greater than @a endIndex.
///    @tsexample
///       getWords( \"a b c d\", 1, 2, ) // Returns \"b c\"
///    @endtsexample
///    @see getWord
///    @see getWordCount
///    @see getFields
///    @see getRecords
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_getWords (string text, int startIndex, int endIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getWords'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,startIndex,endIndex));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_getWords(sbtext, startIndex, endIndex, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Reports the current directory
/// 
/// 	@return String containing full file path of working directory
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_getWorkingDirectory ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getWorkingDirectory'");

var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_getWorkingDirectory(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( int controllerID, string property, bool currentD )
/// 				@brief Queries the current state of a connected Xbox 360 controller.
///             XInput Properties:
///              - XI_THUMBLX, XI_THUMBLY - X and Y axes of the left thumbstick. 
///              - XI_THUMBRX, XI_THUMBRY - X and Y axes of the right thumbstick. 
///              - XI_LEFT_TRIGGER, XI_RIGHT_TRIGGER - Left and Right triggers. 
///              - SI_UPOV, SI_DPOV, SI_LPOV, SI_RPOV - Up, Down, Left, and Right on the directional pad.
///              - XI_START, XI_BACK - The Start and Back buttons.
///              - XI_LEFT_THUMB, XI_RIGHT_THUMB - Clicking in the left and right thumbstick.
///              - XI_LEFT_SHOULDER, XI_RIGHT_SHOULDER - Left and Right bumpers.
///              - XI_A, XI_B , XI_X, XI_Y - The A, B, X, and Y buttons.
///             @param controllerID Zero-based index of the controller to return information about.
///             @param property Name of input action being queried, such as \"XI_THUMBLX\".
///             @param current True checks current device in action.
///             @return Button queried - 1 if the button is pressed, 0 if it's not.
///             @return Thumbstick queried - Int representing displacement from rest position.
///             @return %Trigger queried - Int from 0 to 255 representing how far the trigger is displaced.
///             @ingroup Input)
/// 
/// </summary>

public int fn_getXInputState (int controllerID, string properties, bool current)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_getXInputState'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",controllerID,properties,current));
StringBuilder sbproperties = null;
if (properties != null)
     sbproperties = new StringBuilder(properties, 1024);

return  SafeNativeMethods.mwle_fn_getXInputState(controllerID, sbproperties, current);
}
/// <summary>
/// Open the given URL or file in the user's web browser.
///    @param address The address to open.  If this is not prefixed by a protocol specifier (\"...://\"), then 
///       the function checks whether the address refers to a file or directory and if so, prepends \"file://\" 
///       to @a adress; if the file check fails, \"http://\" is prepended to @a address.
///    @tsexample
///       gotoWebPage( \"http://www.garagegames.com\" );
///    @endtsexample
///    @ingroup Platform )
/// 
/// </summary>

public void fn_gotoWebPage (string address)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_gotoWebPage'" + string.Format("\"{0}\" ",address));
StringBuilder sbaddress = null;
if (address != null)
     sbaddress = new StringBuilder(address, 1024);

SafeNativeMethods.mwle_fn_gotoWebPage(sbaddress);
}
/// <summary>
/// ( String filename | String filename, bool resize ) Assign an image to the control.
///    @hide )
/// 
/// </summary>

public void fn_GuiBitmapCtrl_setBitmap (string guibitmapctrl, string fileRoot, bool resize)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiBitmapCtrl_setBitmap'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guibitmapctrl,fileRoot,resize));
StringBuilder sbguibitmapctrl = null;
if (guibitmapctrl != null)
     sbguibitmapctrl = new StringBuilder(guibitmapctrl, 1024);
StringBuilder sbfileRoot = null;
if (fileRoot != null)
     sbfileRoot = new StringBuilder(fileRoot, 1024);

SafeNativeMethods.mwle_fn_GuiBitmapCtrl_setBitmap(sbguibitmapctrl, sbfileRoot, resize);
}
/// <summary>
/// () - Is this canvas currently fullscreen? )
/// 
/// </summary>

public bool fn_GuiCanvas_isFullscreen (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_isFullscreen'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fn_GuiCanvas_isFullscreen(sbguicanvas)>=1;
}
/// <summary>
/// () )
/// 
/// </summary>

public bool fn_GuiCanvas_isMaximized (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_isMaximized'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fn_GuiCanvas_isMaximized(sbguicanvas)>=1;
}
/// <summary>
/// () )
/// 
/// </summary>

public bool fn_GuiCanvas_isMinimized (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_isMinimized'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fn_GuiCanvas_isMinimized(sbguicanvas)>=1;
}
/// <summary>
/// () - maximize this canvas' window. )
/// 
/// </summary>

public void fn_GuiCanvas_maximizeWindow (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_maximizeWindow'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_maximizeWindow(sbguicanvas);
}
/// <summary>
/// () - minimize this canvas' window. )
/// 
/// </summary>

public void fn_GuiCanvas_minimizeWindow (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_minimizeWindow'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_minimizeWindow(sbguicanvas);
}
/// <summary>
/// (GuiControl ctrl=NULL)
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiCanvas_popDialog (string guicanvas, string gui)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_popDialog'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,gui));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbgui = null;
if (gui != null)
     sbgui = new StringBuilder(gui, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_popDialog(sbguicanvas, sbgui);
}
/// <summary>
/// (int layer) 
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiCanvas_popLayer (string guicanvas, int layer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_popLayer'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,layer));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_popLayer(sbguicanvas, layer);
}
/// <summary>
/// (GuiControl ctrl, int layer=0, bool center=false)
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiCanvas_pushDialog (string guicanvas, string ctrlName, int layer, bool center)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_pushDialog'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guicanvas,ctrlName,layer,center));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbctrlName = null;
if (ctrlName != null)
     sbctrlName = new StringBuilder(ctrlName, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_pushDialog(sbguicanvas, sbctrlName, layer, center);
}
/// <summary>
/// () - restore this canvas' window. )
/// 
/// </summary>

public void fn_GuiCanvas_restoreWindow (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_restoreWindow'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_restoreWindow(sbguicanvas);
}
/// <summary>
/// (Point2I pos)
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiCanvas_setCursorPos (string guicanvas, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_setCursorPos'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,pos));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_setCursorPos(sbguicanvas, sbpos);
}
/// <summary>
/// () - Claim OS input focus for this canvas' window.)
/// 
/// </summary>

public void fn_GuiCanvas_setFocus (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_setFocus'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_setFocus(sbguicanvas);
}
/// <summary>
/// (int width, int height, bool fullscreen, [int bitDepth], [int refreshRate], [int antialiasLevel] )
///                Change the video mode of this canvas. This method has the side effect of setting the $pref::Video::mode to the new values.
///                \\param width The screen width to set.
///                \\param height The screen height to set.
///                \\param fullscreen Specify true to run fullscreen or false to run in a window
///                \\param bitDepth [optional] The desired bit-depth. Defaults to the current setting. This parameter is ignored if you are running in a window.
///                \\param refreshRate [optional] The desired refresh rate. Defaults to the current setting. This parameter is ignored if you are running in a window
/// 					\\param antialiasLevel [optional] The level of anti-aliasing to apply 0 = none )
/// 
/// </summary>

public void fn_GuiCanvas_setVideoMode (string guicanvas, uint width, uint height, bool fullscreen, uint bitDepth, uint refreshRate, uint antialiasLevel)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiCanvas_setVideoMode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",guicanvas,width,height,fullscreen,bitDepth,refreshRate,antialiasLevel));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fn_GuiCanvas_setVideoMode(sbguicanvas, width, height, fullscreen, bitDepth, refreshRate, antialiasLevel);
}
/// <summary>
/// Gets the current position of the selector)
/// 
/// </summary>

public string fn_GuiColorPickerCtrl_getSelectorPos (string guicolorpickerctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiColorPickerCtrl_getSelectorPos'" + string.Format("\"{0}\" ",guicolorpickerctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicolorpickerctrl = null;
if (guicolorpickerctrl != null)
     sbguicolorpickerctrl = new StringBuilder(guicolorpickerctrl, 1024);

SafeNativeMethods.mwle_fn_GuiColorPickerCtrl_getSelectorPos(sbguicolorpickerctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Sets the current position of the selector)
/// 
/// </summary>

public void fn_GuiColorPickerCtrl_setSelectorPos (string guicolorpickerctrl, string newPos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiColorPickerCtrl_setSelectorPos'" + string.Format("\"{0}\" \"{1}\" ",guicolorpickerctrl,newPos));
StringBuilder sbguicolorpickerctrl = null;
if (guicolorpickerctrl != null)
     sbguicolorpickerctrl = new StringBuilder(guicolorpickerctrl, 1024);
StringBuilder sbnewPos = null;
if (newPos != null)
     sbnewPos = new StringBuilder(newPos, 1024);

SafeNativeMethods.mwle_fn_GuiColorPickerCtrl_setSelectorPos(sbguicolorpickerctrl, sbnewPos);
}
/// <summary>
/// Forces update of pick color)
/// 
/// </summary>

public void fn_GuiColorPickerCtrl_updateColor (string guicolorpickerctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiColorPickerCtrl_updateColor'" + string.Format("\"{0}\" ",guicolorpickerctrl));
StringBuilder sbguicolorpickerctrl = null;
if (guicolorpickerctrl != null)
     sbguicolorpickerctrl = new StringBuilder(guicolorpickerctrl, 1024);

SafeNativeMethods.mwle_fn_GuiColorPickerCtrl_updateColor(sbguicolorpickerctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public string fn_GuiControl_getBounds (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControl_getBounds'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fn_GuiControl_getBounds(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public string fn_GuiControl_getValue (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControl_getValue'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fn_GuiControl_getValue(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public bool fn_GuiControl_isActive (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControl_isActive'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fn_GuiControl_isActive(sbguicontrol)>=1;
}
/// <summary>
/// (bool isFirst))
/// 
/// </summary>

public void fn_GuiControl_makeFirstResponder (string guicontrol, bool isFirst)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControl_makeFirstResponder'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,isFirst));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fn_GuiControl_makeFirstResponder(sbguicontrol, isFirst);
}
/// <summary>
///  Set the width and height of the control.
///    @hide )
/// 
/// </summary>

public void fn_GuiControl_setExtent (string guicontrol, string ext)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControl_setExtent'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,ext));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbext = null;
if (ext != null)
     sbext = new StringBuilder(ext, 1024);

SafeNativeMethods.mwle_fn_GuiControl_setExtent(sbguicontrol, sbext);
}
/// <summary>
/// ( pString ) )
/// 
/// </summary>

public int fn_GuiControlProfile_getStringWidth (string guicontrolprofile, string pString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiControlProfile_getStringWidth'" + string.Format("\"{0}\" \"{1}\" ",guicontrolprofile,pString));
StringBuilder sbguicontrolprofile = null;
if (guicontrolprofile != null)
     sbguicontrolprofile = new StringBuilder(guicontrolprofile, 1024);
StringBuilder sbpString = null;
if (pString != null)
     sbpString = new StringBuilder(pString, 1024);

return  SafeNativeMethods.mwle_fn_GuiControlProfile_getStringWidth(sbguicontrolprofile, sbpString);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_dropSelectionAtScreenCenter (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_dropSelectionAtScreenCenter'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_dropSelectionAtScreenCenter(sbguiconvexeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_handleDelete (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_handleDelete'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_handleDelete(sbguiconvexeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_handleDeselect (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_handleDeselect'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_handleDeselect(sbguiconvexeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiConvexEditorCtrl_hasSelection (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_hasSelection'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_hasSelection(sbguiconvexeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_hollowSelection (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_hollowSelection'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_hollowSelection(sbguiconvexeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_recenterSelection (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_recenterSelection'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_recenterSelection(sbguiconvexeditorctrl);
}
/// <summary>
/// ( ConvexShape ) )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_selectConvex (string guiconvexeditorctrl, string convex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_selectConvex'" + string.Format("\"{0}\" \"{1}\" ",guiconvexeditorctrl,convex));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);
StringBuilder sbconvex = null;
if (convex != null)
     sbconvex = new StringBuilder(convex, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_selectConvex(sbguiconvexeditorctrl, sbconvex);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiConvexEditorCtrl_splitSelectedFace (string guiconvexeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiConvexEditorCtrl_splitSelectedFace'" + string.Format("\"{0}\" ",guiconvexeditorctrl));
StringBuilder sbguiconvexeditorctrl = null;
if (guiconvexeditorctrl != null)
     sbguiconvexeditorctrl = new StringBuilder(guiconvexeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiConvexEditorCtrl_splitSelectedFace(sbguiconvexeditorctrl);
}
/// <summary>
/// deleteSelectedDecalDatablock( String datablock ) )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_deleteDecalDatablock (string guidecaleditorctrl, string datablock)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_deleteDecalDatablock'" + string.Format("\"{0}\" \"{1}\" ",guidecaleditorctrl,datablock));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);
StringBuilder sbdatablock = null;
if (datablock != null)
     sbdatablock = new StringBuilder(datablock, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_deleteDecalDatablock(sbguidecaleditorctrl, sbdatablock);
}
/// <summary>
/// deleteSelectedDecal() )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_deleteSelectedDecal (string guidecaleditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_deleteSelectedDecal'" + string.Format("\"{0}\" ",guidecaleditorctrl));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_deleteSelectedDecal(sbguidecaleditorctrl);
}
/// <summary>
/// editDecalDetails( S32 )() )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_editDecalDetails (string guidecaleditorctrl, uint id, string pos, string tan, float size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_editDecalDetails'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guidecaleditorctrl,id,pos,tan,size));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbtan = null;
if (tan != null)
     sbtan = new StringBuilder(tan, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_editDecalDetails(sbguidecaleditorctrl, id, sbpos, sbtan, size);
}
/// <summary>
/// getDecalCount() )
/// 
/// </summary>

public int fn_GuiDecalEditorCtrl_getDecalCount (string guidecaleditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_getDecalCount'" + string.Format("\"{0}\" ",guidecaleditorctrl));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_getDecalCount(sbguidecaleditorctrl);
}
/// <summary>
/// getDecalLookupName( S32 )() )
/// 
/// </summary>

public string fn_GuiDecalEditorCtrl_getDecalLookupName (string guidecaleditorctrl, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_getDecalLookupName'" + string.Format("\"{0}\" \"{1}\" ",guidecaleditorctrl,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_getDecalLookupName(sbguidecaleditorctrl, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getDecalTransform() )
/// 
/// </summary>

public string fn_GuiDecalEditorCtrl_getDecalTransform (string guidecaleditorctrl, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_getDecalTransform'" + string.Format("\"{0}\" \"{1}\" ",guidecaleditorctrl,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_getDecalTransform(sbguidecaleditorctrl, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// getMode() )
/// 
/// </summary>

public string fn_GuiDecalEditorCtrl_getMode (string guidecaleditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_getMode'" + string.Format("\"{0}\" ",guidecaleditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_getMode(sbguidecaleditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiDecalEditorCtrl_getSelectionCount (string guidecaleditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_getSelectionCount'" + string.Format("\"{0}\" ",guidecaleditorctrl));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_getSelectionCount(sbguidecaleditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_retargetDecalDatablock (string guidecaleditorctrl, string dbFrom, string dbTo)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_retargetDecalDatablock'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guidecaleditorctrl,dbFrom,dbTo));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);
StringBuilder sbdbFrom = null;
if (dbFrom != null)
     sbdbFrom = new StringBuilder(dbFrom, 1024);
StringBuilder sbdbTo = null;
if (dbTo != null)
     sbdbTo = new StringBuilder(dbTo, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_retargetDecalDatablock(sbguidecaleditorctrl, sbdbFrom, sbdbTo);
}
/// <summary>
/// selectDecal( S32 )() )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_selectDecal (string guidecaleditorctrl, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_selectDecal'" + string.Format("\"{0}\" \"{1}\" ",guidecaleditorctrl,id));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_selectDecal(sbguidecaleditorctrl, id);
}
/// <summary>
/// setMode( String mode )() )
/// 
/// </summary>

public void fn_GuiDecalEditorCtrl_setMode (string guidecaleditorctrl, string newMode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiDecalEditorCtrl_setMode'" + string.Format("\"{0}\" \"{1}\" ",guidecaleditorctrl,newMode));
StringBuilder sbguidecaleditorctrl = null;
if (guidecaleditorctrl != null)
     sbguidecaleditorctrl = new StringBuilder(guidecaleditorctrl, 1024);
StringBuilder sbnewMode = null;
if (newMode != null)
     sbnewMode = new StringBuilder(newMode, 1024);

SafeNativeMethods.mwle_fn_GuiDecalEditorCtrl_setMode(sbguidecaleditorctrl, sbnewMode);
}
/// <summary>
/// (GuiControl ctrl))
/// 
/// </summary>

public void fn_GuiEditCtrl_addNewCtrl (string guieditctrl, string ctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_addNewCtrl'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,ctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_addNewCtrl(sbguieditctrl, sbctrl);
}
/// <summary>
/// selects a control.)
/// 
/// </summary>

public void fn_GuiEditCtrl_addSelection (string guieditctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_addSelection'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,id));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_addSelection(sbguieditctrl, id);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_GuiEditCtrl_bringToFront (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_bringToFront'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_bringToFront(sbguieditctrl);
}
/// <summary>
/// ( [ int axis ] ) - Clear all currently set guide lines. )
/// 
/// </summary>

public void fn_GuiEditCtrl_clearGuides (string guieditctrl, int axis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_clearGuides'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,axis));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_clearGuides(sbguieditctrl, axis);
}
/// <summary>
/// Clear selected controls list.)
/// 
/// </summary>

public void fn_GuiEditCtrl_clearSelection (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_clearSelection'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_clearSelection(sbguieditctrl);
}
/// <summary>
/// () - Delete the selected controls.)
/// 
/// </summary>

public void fn_GuiEditCtrl_deleteSelection (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_deleteSelection'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_deleteSelection(sbguieditctrl);
}
/// <summary>
/// ( bool width=true, bool height=true ) - Fit selected controls into their parents. )
/// 
/// </summary>

public void fn_GuiEditCtrl_fitIntoParents (string guieditctrl, bool width, bool height)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_fitIntoParents'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guieditctrl,width,height));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_fitIntoParents(sbguieditctrl, width, height);
}
/// <summary>
/// () - Return the toplevel control edited inside the GUI editor. )
/// 
/// </summary>

public int fn_GuiEditCtrl_getContentControl (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_getContentControl'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiEditCtrl_getContentControl(sbguieditctrl);
}
/// <summary>
/// Returns the set to which new controls will be added)
/// 
/// </summary>

public int fn_GuiEditCtrl_getCurrentAddSet (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_getCurrentAddSet'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiEditCtrl_getCurrentAddSet(sbguieditctrl);
}
/// <summary>
/// () - Return the current mouse mode. )
/// 
/// </summary>

public string fn_GuiEditCtrl_getMouseMode (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_getMouseMode'" + string.Format("\"{0}\" ",guieditctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_getMouseMode(sbguieditctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Return the number of controls currently selected. )
/// 
/// </summary>

public int fn_GuiEditCtrl_getNumSelected (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_getNumSelected'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiEditCtrl_getNumSelected(sbguieditctrl);
}
/// <summary>
/// () - Returns global bounds of current selection as vector 'x y width height'. )
/// 
/// </summary>

public string fn_GuiEditCtrl_getSelectionGlobalBounds (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_getSelectionGlobalBounds'" + string.Format("\"{0}\" ",guieditctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_getSelectionGlobalBounds(sbguieditctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int mode) )
/// 
/// </summary>

public void fn_GuiEditCtrl_justify (string guieditctrl, uint mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_justify'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,mode));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_justify(sbguieditctrl, mode);
}
/// <summary>
/// ( string fileName=null ) - Load selection from file or clipboard.)
/// 
/// </summary>

public void fn_GuiEditCtrl_loadSelection (string guieditctrl, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_loadSelection'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,filename));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_loadSelection(sbguieditctrl, sbfilename);
}
/// <summary>
/// Move all controls in the selection by (dx,dy) pixels.)
/// 
/// </summary>

public void fn_GuiEditCtrl_moveSelection (string guieditctrl, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_moveSelection'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,pos));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_moveSelection(sbguieditctrl, sbpos);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_GuiEditCtrl_pushToBack (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_pushToBack'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_pushToBack(sbguieditctrl);
}
/// <summary>
/// ( GuiControl ctrl [, int axis ] ) - Read the guides from the given control. )
/// 
/// </summary>

public void fn_GuiEditCtrl_readGuides (string guieditctrl, string ctrl, int axis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_readGuides'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guieditctrl,ctrl,axis));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_readGuides(sbguieditctrl, sbctrl, axis);
}
/// <summary>
/// deselects a control.)
/// 
/// </summary>

public void fn_GuiEditCtrl_removeSelection (string guieditctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_removeSelection'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,id));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_removeSelection(sbguieditctrl, id);
}
/// <summary>
/// ( string fileName=null ) - Save selection to file or clipboard.)
/// 
/// </summary>

public void fn_GuiEditCtrl_saveSelection (string guieditctrl, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_saveSelection'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,filename));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_saveSelection(sbguieditctrl, sbfilename);
}
/// <summary>
/// (GuiControl ctrl))
/// 
/// </summary>

public void fn_GuiEditCtrl_select (string guieditctrl, string ctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_select'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,ctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_select(sbguieditctrl, sbctrl);
}
/// <summary>
/// ())
/// 
/// </summary>

public void fn_GuiEditCtrl_selectAll (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_selectAll'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_selectAll(sbguieditctrl);
}
/// <summary>
/// ( bool addToSelection=false ) - Select children of currently selected controls. )
/// 
/// </summary>

public void fn_GuiEditCtrl_selectChildren (string guieditctrl, bool addToSelection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_selectChildren'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,addToSelection));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_selectChildren(sbguieditctrl, addToSelection);
}
/// <summary>
/// ( bool addToSelection=false ) - Select parents of currently selected controls. )
/// 
/// </summary>

public void fn_GuiEditCtrl_selectParents (string guieditctrl, bool addToSelection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_selectParents'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,addToSelection));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_selectParents(sbguieditctrl, addToSelection);
}
/// <summary>
/// ( GuiControl ctrl ) - Set the toplevel control to edit in the GUI editor. )
/// 
/// </summary>

public void fn_GuiEditCtrl_setContentControl (string guieditctrl, string ctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_setContentControl'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,ctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_setContentControl(sbguieditctrl, sbctrl);
}
/// <summary>
/// (GuiControl ctrl))
/// 
/// </summary>

public void fn_GuiEditCtrl_setCurrentAddSet (string guieditctrl, string addSet)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_setCurrentAddSet'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,addSet));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbaddSet = null;
if (addSet != null)
     sbaddSet = new StringBuilder(addSet, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_setCurrentAddSet(sbguieditctrl, sbaddSet);
}
/// <summary>
/// GuiEditCtrl.setSnapToGrid(gridsize))
/// 
/// </summary>

public void fn_GuiEditCtrl_setSnapToGrid (string guieditctrl, uint gridsize)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_setSnapToGrid'" + string.Format("\"{0}\" \"{1}\" ",guieditctrl,gridsize));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_setSnapToGrid(sbguieditctrl, gridsize);
}
/// <summary>
/// Toggle activation.)
/// 
/// </summary>

public void fn_GuiEditCtrl_toggle (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_toggle'" + string.Format("\"{0}\" ",guieditctrl));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_toggle(sbguieditctrl);
}
/// <summary>
/// ( GuiControl ctrl [, int axis ] ) - Write the guides to the given control. )
/// 
/// </summary>

public void fn_GuiEditCtrl_writeGuides (string guieditctrl, string ctrl, int axis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiEditCtrl_writeGuides'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guieditctrl,ctrl,axis));
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fn_GuiEditCtrl_writeGuides(sbguieditctrl, sbctrl, axis);
}
/// <summary>
/// getSelectedPath() - returns the currently selected path in the tree)
/// 
/// </summary>

public string fn_GuiFileTreeCtrl_getSelectedPath (string guifiletreectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiFileTreeCtrl_getSelectedPath'" + string.Format("\"{0}\" ",guifiletreectrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguifiletreectrl = null;
if (guifiletreectrl != null)
     sbguifiletreectrl = new StringBuilder(guifiletreectrl, 1024);

SafeNativeMethods.mwle_fn_GuiFileTreeCtrl_getSelectedPath(sbguifiletreectrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Reread the directory tree hierarchy. )
/// 
/// </summary>

public void fn_GuiFileTreeCtrl_reload (string guifiletreectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiFileTreeCtrl_reload'" + string.Format("\"{0}\" ",guifiletreectrl));
StringBuilder sbguifiletreectrl = null;
if (guifiletreectrl != null)
     sbguifiletreectrl = new StringBuilder(guifiletreectrl, 1024);

SafeNativeMethods.mwle_fn_GuiFileTreeCtrl_reload(sbguifiletreectrl);
}
/// <summary>
/// setSelectedPath(path) - expands the tree to the specified path)
/// 
/// </summary>

public bool fn_GuiFileTreeCtrl_setSelectedPath (string guifiletreectrl, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiFileTreeCtrl_setSelectedPath'" + string.Format("\"{0}\" \"{1}\" ",guifiletreectrl,path));
StringBuilder sbguifiletreectrl = null;
if (guifiletreectrl != null)
     sbguifiletreectrl = new StringBuilder(guifiletreectrl, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

return  SafeNativeMethods.mwle_fn_GuiFileTreeCtrl_setSelectedPath(sbguifiletreectrl, sbpath)>=1;
}
/// <summary>
/// Return a tuple containing all the values in the filter.
/// 			  @internal)
/// 
/// </summary>

public string fn_GuiFilterCtrl_getValue (string guifilterctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiFilterCtrl_getValue'" + string.Format("\"{0}\" ",guifilterctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguifilterctrl = null;
if (guifilterctrl != null)
     sbguifilterctrl = new StringBuilder(guifilterctrl, 1024);

SafeNativeMethods.mwle_fn_GuiFilterCtrl_getValue(sbguifilterctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Reset the filtering.
/// 			  @internal)
/// 
/// </summary>

public void fn_GuiFilterCtrl_identity (string guifilterctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiFilterCtrl_identity'" + string.Format("\"{0}\" ",guifilterctrl));
StringBuilder sbguifilterctrl = null;
if (guifilterctrl != null)
     sbguifilterctrl = new StringBuilder(guifilterctrl, 1024);

SafeNativeMethods.mwle_fn_GuiFilterCtrl_identity(sbguifilterctrl);
}
/// <summary>
/// Get color value)
/// 
/// </summary>

public string fn_GuiGradientCtrl_getColor (string guigradientctrl, int idx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiGradientCtrl_getColor'" + string.Format("\"{0}\" \"{1}\" ",guigradientctrl,idx));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguigradientctrl = null;
if (guigradientctrl != null)
     sbguigradientctrl = new StringBuilder(guigradientctrl, 1024);

SafeNativeMethods.mwle_fn_GuiGradientCtrl_getColor(sbguigradientctrl, idx, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get color count)
/// 
/// </summary>

public int fn_GuiGradientCtrl_getColorCount (string guigradientctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiGradientCtrl_getColorCount'" + string.Format("\"{0}\" ",guigradientctrl));
StringBuilder sbguigradientctrl = null;
if (guigradientctrl != null)
     sbguigradientctrl = new StringBuilder(guigradientctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiGradientCtrl_getColorCount(sbguigradientctrl);
}
/// <summary>
/// ()
/// 			  @internal)
/// 
/// </summary>

public void fn_GuiIdleCamFadeBitmapCtrl_fadeIn (string guiidlecamfadebitmapctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiIdleCamFadeBitmapCtrl_fadeIn'" + string.Format("\"{0}\" ",guiidlecamfadebitmapctrl));
StringBuilder sbguiidlecamfadebitmapctrl = null;
if (guiidlecamfadebitmapctrl != null)
     sbguiidlecamfadebitmapctrl = new StringBuilder(guiidlecamfadebitmapctrl, 1024);

SafeNativeMethods.mwle_fn_GuiIdleCamFadeBitmapCtrl_fadeIn(sbguiidlecamfadebitmapctrl);
}
/// <summary>
/// ()
/// 			  @internal)
/// 
/// </summary>

public void fn_GuiIdleCamFadeBitmapCtrl_fadeOut (string guiidlecamfadebitmapctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiIdleCamFadeBitmapCtrl_fadeOut'" + string.Format("\"{0}\" ",guiidlecamfadebitmapctrl));
StringBuilder sbguiidlecamfadebitmapctrl = null;
if (guiidlecamfadebitmapctrl != null)
     sbguiidlecamfadebitmapctrl = new StringBuilder(guiidlecamfadebitmapctrl, 1024);

SafeNativeMethods.mwle_fn_GuiIdleCamFadeBitmapCtrl_fadeOut(sbguiidlecamfadebitmapctrl);
}
/// <summary>
/// ( id object, (bool autoSync = true) ) - Add the object to the list of objects being inspected. )
/// 
/// </summary>

public void fn_GuiInspector_addInspect (string guiinspector, string className, bool autoSync)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_addInspect'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiinspector,className,autoSync));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_addInspect(sbguiinspector, sbclassName, autoSync);
}
/// <summary>
/// apply() - Force application of inspected object's attributes )
/// 
/// </summary>

public void fn_GuiInspector_apply (string guiinspector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_apply'" + string.Format("\"{0}\" ",guiinspector));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_apply(sbguiinspector);
}
/// <summary>
/// getInspectObject( int index=0 ) - Returns currently inspected object )
/// 
/// </summary>

public string fn_GuiInspector_getInspectObject (string guiinspector, uint index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_getInspectObject'" + string.Format("\"{0}\" \"{1}\" ",guiinspector,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_getInspectObject(sbguiinspector, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Return the number of objects currently being inspected. )
/// 
/// </summary>

public int fn_GuiInspector_getNumInspectObjects (string guiinspector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_getNumInspectObjects'" + string.Format("\"{0}\" ",guiinspector));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);

return  SafeNativeMethods.mwle_fn_GuiInspector_getNumInspectObjects(sbguiinspector);
}
/// <summary>
/// Inspect(Object))
/// 
/// </summary>

public void fn_GuiInspector_inspect (string guiinspector, string className)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_inspect'" + string.Format("\"{0}\" \"{1}\" ",guiinspector,className));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_inspect(sbguiinspector, sbclassName);
}
/// <summary>
/// Reinspect the currently selected object. )
/// 
/// </summary>

public void fn_GuiInspector_refresh (string guiinspector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_refresh'" + string.Format("\"{0}\" ",guiinspector));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_refresh(sbguiinspector);
}
/// <summary>
/// ( id object ) - Remove the object from the list of objects being inspected. )
/// 
/// </summary>

public void fn_GuiInspector_removeInspect (string guiinspector, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_removeInspect'" + string.Format("\"{0}\" \"{1}\" ",guiinspector,obj));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_removeInspect(sbguiinspector, sbobj);
}
/// <summary>
/// setName(NewObjectName))
/// 
/// </summary>

public void fn_GuiInspector_setName (string guiinspector, string newObjectName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_setName'" + string.Format("\"{0}\" \"{1}\" ",guiinspector,newObjectName));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);
StringBuilder sbnewObjectName = null;
if (newObjectName != null)
     sbnewObjectName = new StringBuilder(newObjectName, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_setName(sbguiinspector, sbnewObjectName);
}
/// <summary>
/// setObjectField( fieldname, data ) - Set a named fields value on the inspected object if it exists. This triggers all the usual callbacks that would occur if the field had been changed through the gui. )
/// 
/// </summary>

public void fn_GuiInspector_setObjectField (string guiinspector, string fieldname, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspector_setObjectField'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiinspector,fieldname,data));
StringBuilder sbguiinspector = null;
if (guiinspector != null)
     sbguiinspector = new StringBuilder(guiinspector, 1024);
StringBuilder sbfieldname = null;
if (fieldname != null)
     sbfieldname = new StringBuilder(fieldname, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

SafeNativeMethods.mwle_fn_GuiInspector_setObjectField(sbguiinspector, sbfieldname, sbdata);
}
/// <summary>
/// field.renameField(newDynamicFieldName); )
/// 
/// </summary>

public void fn_GuiInspectorDynamicField_renameField (string guiinspectordynamicfield, string newDynamicFieldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorDynamicField_renameField'" + string.Format("\"{0}\" \"{1}\" ",guiinspectordynamicfield,newDynamicFieldName));
StringBuilder sbguiinspectordynamicfield = null;
if (guiinspectordynamicfield != null)
     sbguiinspectordynamicfield = new StringBuilder(guiinspectordynamicfield, 1024);
StringBuilder sbnewDynamicFieldName = null;
if (newDynamicFieldName != null)
     sbnewDynamicFieldName = new StringBuilder(newDynamicFieldName, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorDynamicField_renameField(sbguiinspectordynamicfield, sbnewDynamicFieldName);
}
/// <summary>
/// obj.addDynamicField(); )
/// 
/// </summary>

public void fn_GuiInspectorDynamicGroup_addDynamicField (string guiinspectordynamicgroup)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorDynamicGroup_addDynamicField'" + string.Format("\"{0}\" ",guiinspectordynamicgroup));
StringBuilder sbguiinspectordynamicgroup = null;
if (guiinspectordynamicgroup != null)
     sbguiinspectordynamicgroup = new StringBuilder(guiinspectordynamicgroup, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorDynamicGroup_addDynamicField(sbguiinspectordynamicgroup);
}
/// <summary>
/// Refreshes the dynamic fields in the inspector.)
/// 
/// </summary>

public bool fn_GuiInspectorDynamicGroup_inspectGroup (string guiinspectordynamicgroup)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorDynamicGroup_inspectGroup'" + string.Format("\"{0}\" ",guiinspectordynamicgroup));
StringBuilder sbguiinspectordynamicgroup = null;
if (guiinspectordynamicgroup != null)
     sbguiinspectordynamicgroup = new StringBuilder(guiinspectordynamicgroup, 1024);

return  SafeNativeMethods.mwle_fn_GuiInspectorDynamicGroup_inspectGroup(sbguiinspectordynamicgroup)>=1;
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiInspectorDynamicGroup_removeDynamicField (string guiinspectordynamicgroup)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorDynamicGroup_removeDynamicField'" + string.Format("\"{0}\" ",guiinspectordynamicgroup));
StringBuilder sbguiinspectordynamicgroup = null;
if (guiinspectordynamicgroup != null)
     sbguiinspectordynamicgroup = new StringBuilder(guiinspectordynamicgroup, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorDynamicGroup_removeDynamicField(sbguiinspectordynamicgroup);
}
/// <summary>
/// , true), ( string newValue, bool callbacks=true ) - Set the field's value. Suppress callbacks for undo if callbacks=false. )
/// 
/// </summary>

public void fn_GuiInspectorField_apply (string guiinspectorfield, string newValue, bool callbacks)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_apply'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiinspectorfield,newValue,callbacks));
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);
StringBuilder sbnewValue = null;
if (newValue != null)
     sbnewValue = new StringBuilder(newValue, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_apply(sbguiinspectorfield, sbnewValue, callbacks);
}
/// <summary>
/// () - Set field value without recording undo (same as 'apply( value, false )'). )
/// 
/// </summary>

public void fn_GuiInspectorField_applyWithoutUndo (string guiinspectorfield, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_applyWithoutUndo'" + string.Format("\"{0}\" \"{1}\" ",guiinspectorfield,data));
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_applyWithoutUndo(sbguiinspectorfield, sbdata);
}
/// <summary>
/// () - Return the value currently displayed on the field. )
/// 
/// </summary>

public string fn_GuiInspectorField_getData (string guiinspectorfield)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_getData'" + string.Format("\"{0}\" ",guiinspectorfield));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_getData(sbguiinspectorfield, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Return the name of the field edited by this inspector field. )
/// 
/// </summary>

public string fn_GuiInspectorField_getInspectedFieldName (string guiinspectorfield)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_getInspectedFieldName'" + string.Format("\"{0}\" ",guiinspectorfield));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_getInspectedFieldName(sbguiinspectorfield, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Return the type of the field edited by this inspector field. )
/// 
/// </summary>

public string fn_GuiInspectorField_getInspectedFieldType (string guiinspectorfield)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_getInspectedFieldType'" + string.Format("\"{0}\" ",guiinspectorfield));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_getInspectedFieldType(sbguiinspectorfield, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () - Return the GuiInspector to which this field belongs. )
/// 
/// </summary>

public int fn_GuiInspectorField_getInspector (string guiinspectorfield)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_getInspector'" + string.Format("\"{0}\" ",guiinspectorfield));
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);

return  SafeNativeMethods.mwle_fn_GuiInspectorField_getInspector(sbguiinspectorfield);
}
/// <summary>
/// () - Reset to default value. )
/// 
/// </summary>

public void fn_GuiInspectorField_reset (string guiinspectorfield)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiInspectorField_reset'" + string.Format("\"{0}\" ",guiinspectorfield));
StringBuilder sbguiinspectorfield = null;
if (guiinspectorfield != null)
     sbguiinspectorfield = new StringBuilder(guiinspectorfield, 1024);

SafeNativeMethods.mwle_fn_GuiInspectorField_reset(sbguiinspectorfield);
}
/// <summary>
/// ( string materialName )
///                Set the material to be displayed in the control. )
/// 
/// </summary>

public bool fn_GuiMaterialCtrl_setMaterial (string guimaterialctrl, string materialName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMaterialCtrl_setMaterial'" + string.Format("\"{0}\" \"{1}\" ",guimaterialctrl,materialName));
StringBuilder sbguimaterialctrl = null;
if (guimaterialctrl != null)
     sbguimaterialctrl = new StringBuilder(guimaterialctrl, 1024);
StringBuilder sbmaterialName = null;
if (materialName != null)
     sbmaterialName = new StringBuilder(materialName, 1024);

return  SafeNativeMethods.mwle_fn_GuiMaterialCtrl_setMaterial(sbguimaterialctrl, sbmaterialName)>=1;
}
/// <summary>
/// deleteNode() )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_deleteNode (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_deleteNode'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_deleteNode(sbguimeshroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiMeshRoadEditorCtrl_getMode (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getMode'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getMode(sbguimeshroadeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public float fn_GuiMeshRoadEditorCtrl_getNodeDepth (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getNodeDepth'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getNodeDepth(sbguimeshroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiMeshRoadEditorCtrl_getNodeNormal (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getNodeNormal'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getNodeNormal(sbguimeshroadeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiMeshRoadEditorCtrl_getNodePosition (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getNodePosition'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getNodePosition(sbguimeshroadeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public float fn_GuiMeshRoadEditorCtrl_getNodeWidth (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getNodeWidth'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getNodeWidth(sbguimeshroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiMeshRoadEditorCtrl_getSelectedRoad (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_getSelectedRoad'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_getSelectedRoad(sbguimeshroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_matchTerrainToRoad (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_matchTerrainToRoad'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_matchTerrainToRoad(sbguimeshroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_regenerate (string guimeshroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_regenerate'" + string.Format("\"{0}\" ",guimeshroadeditorctrl));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_regenerate(sbguimeshroadeditorctrl);
}
/// <summary>
/// setMode( String mode ) )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setMode (string guimeshroadeditorctrl, string mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setMode'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,mode));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);
StringBuilder sbmode = null;
if (mode != null)
     sbmode = new StringBuilder(mode, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setMode(sbguimeshroadeditorctrl, sbmode);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setNodeDepth (string guimeshroadeditorctrl, float depth)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setNodeDepth'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,depth));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setNodeDepth(sbguimeshroadeditorctrl, depth);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setNodeNormal (string guimeshroadeditorctrl, string normal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setNodeNormal'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,normal));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);
StringBuilder sbnormal = null;
if (normal != null)
     sbnormal = new StringBuilder(normal, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setNodeNormal(sbguimeshroadeditorctrl, sbnormal);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setNodePosition (string guimeshroadeditorctrl, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setNodePosition'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,pos));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setNodePosition(sbguimeshroadeditorctrl, sbpos);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setNodeWidth (string guimeshroadeditorctrl, float width)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setNodeWidth'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,width));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setNodeWidth(sbguimeshroadeditorctrl, width);
}
/// <summary>
/// ),  )
/// 
/// </summary>

public void fn_GuiMeshRoadEditorCtrl_setSelectedRoad (string guimeshroadeditorctrl, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMeshRoadEditorCtrl_setSelectedRoad'" + string.Format("\"{0}\" \"{1}\" ",guimeshroadeditorctrl,objName));
StringBuilder sbguimeshroadeditorctrl = null;
if (guimeshroadeditorctrl != null)
     sbguimeshroadeditorctrl = new StringBuilder(guimeshroadeditorctrl, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_GuiMeshRoadEditorCtrl_setSelectedRoad(sbguimeshroadeditorctrl, sbobjName);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiMissionAreaEditorCtrl_getSelectedMissionArea (string guimissionareaeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMissionAreaEditorCtrl_getSelectedMissionArea'" + string.Format("\"{0}\" ",guimissionareaeditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguimissionareaeditorctrl = null;
if (guimissionareaeditorctrl != null)
     sbguimissionareaeditorctrl = new StringBuilder(guimissionareaeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiMissionAreaEditorCtrl_getSelectedMissionArea(sbguimissionareaeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ),  )
/// 
/// </summary>

public void fn_GuiMissionAreaEditorCtrl_setSelectedMissionArea (string guimissionareaeditorctrl, string missionAreaName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiMissionAreaEditorCtrl_setSelectedMissionArea'" + string.Format("\"{0}\" \"{1}\" ",guimissionareaeditorctrl,missionAreaName));
StringBuilder sbguimissionareaeditorctrl = null;
if (guimissionareaeditorctrl != null)
     sbguimissionareaeditorctrl = new StringBuilder(guimissionareaeditorctrl, 1024);
StringBuilder sbmissionAreaName = null;
if (missionAreaName != null)
     sbmissionAreaName = new StringBuilder(missionAreaName, 1024);

SafeNativeMethods.mwle_fn_GuiMissionAreaEditorCtrl_setSelectedMissionArea(sbguimissionareaeditorctrl, sbmissionAreaName);
}
/// <summary>
/// )
/// 
/// </summary>

public string fn_GuiNavEditorCtrl_getMode (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiNavEditorCtrl_getMode'" + string.Format("\"{0}\" ",guinaveditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiNavEditorCtrl_getMode(sbguinaveditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// setMode(String mode))
/// 
/// </summary>

public void fn_GuiNavEditorCtrl_setMode (string guinaveditorctrl, string newMode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiNavEditorCtrl_setMode'" + string.Format("\"{0}\" \"{1}\" ",guinaveditorctrl,newMode));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);
StringBuilder sbnewMode = null;
if (newMode != null)
     sbnewMode = new StringBuilder(newMode, 1024);

SafeNativeMethods.mwle_fn_GuiNavEditorCtrl_setMode(sbguinaveditorctrl, sbnewMode);
}
/// <summary>
/// (int plotID, float x, float y, bool setAdded = true;)
///               Add a data point to the given plot.
/// 			  @return)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_addPlotPoint (string guiparticlegraphctrl, int plotID, float x, float y, bool setAdded)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_addPlotPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guiparticlegraphctrl,plotID,x,y,setAdded));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_addPlotPoint(sbguiparticlegraphctrl, plotID, x, y, setAdded, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID, int i, float x, float y)
///               Change a data point to the given plot and plot position.
/// 			  @param plotID The plot you want to access
/// 			  @param i The data point.
/// 			  @param x,y The plot position.
/// 			  @return No return value.)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_changePlotPoint (string guiparticlegraphctrl, int plotID, int i, float x, float y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_changePlotPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guiparticlegraphctrl,plotID,i,x,y));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_changePlotPoint(sbguiparticlegraphctrl, plotID, i, x, y, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
///               Clear all of the graphs.
/// 			  @return No return value)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_clearAllGraphs (string guiparticlegraphctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_clearAllGraphs'" + string.Format("\"{0}\" ",guiparticlegraphctrl));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_clearAllGraphs(sbguiparticlegraphctrl);
}
/// <summary>
/// (int plotID)
///               Clear the graph of the given plot.
/// 			  @return No return value)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_clearGraph (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_clearGraph'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_clearGraph(sbguiparticlegraphctrl, plotID);
}
/// <summary>
/// (int plotID)
///               Get the color of the graph passed.
/// 			  @return Returns the color of the graph as a string of RGB values formatted as \"R G B\")
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getGraphColor (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getGraphColor'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getGraphColor(sbguiparticlegraphctrl, plotID, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID) 
/// 			  Get the maximum values of the graph ranges.
/// 			  @return Returns the maximum of the range formatted as \"x-max y-max\")
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getGraphMax (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getGraphMax'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getGraphMax(sbguiparticlegraphctrl, plotID, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID) 
///               Get the minimum values of the graph ranges.
/// 			  @return Returns the minimum of the range formatted as \"x-min y-min\")
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getGraphMin (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getGraphMin'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getGraphMin(sbguiparticlegraphctrl, plotID, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID) 
///               Get the name of the graph passed.
/// 			  @return Returns the name of the plot)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getGraphName (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getGraphName'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getGraphName(sbguiparticlegraphctrl, plotID, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID, float x, float y)
///               Gets the index of the point passed on the plotID passed (graph ID).
/// 			  @param plotID The plot you wish to check.
/// 			  @param x,y The coordinates of the point to get.
/// 			  @return Returns the index of the point.)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getPlotIndex (string guiparticlegraphctrl, int plotID, float x, float y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getPlotIndex'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guiparticlegraphctrl,plotID,x,y));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getPlotIndex(sbguiparticlegraphctrl, plotID, x, y, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID, int samples)
///               Get a data point from the plot specified, samples from the start of the graph.
/// 			  @return The data point ID)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getPlotPoint (string guiparticlegraphctrl, int plotID, int samples)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getPlotPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,samples));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getPlotPoint(sbguiparticlegraphctrl, plotID, samples, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () 
///               Gets the selected Plot (a.k.a. graph).
/// 			  @return The plot's ID.)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getSelectedPlot (string guiparticlegraphctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getSelectedPlot'" + string.Format("\"{0}\" ",guiparticlegraphctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getSelectedPlot(sbguiparticlegraphctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
///               Gets the selected Point on the Plot (a.k.a. graph).
/// 			  @return The last selected point ID)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_getSelectedPoint (string guiparticlegraphctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_getSelectedPoint'" + string.Format("\"{0}\" ",guiparticlegraphctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_getSelectedPoint(sbguiparticlegraphctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int plotID, int i, float x, float y)
///               Insert a data point to the given plot and plot position.
/// 			  @param plotID The plot you want to access
/// 			  @param i The data point.
/// 			  @param x,y The plot position.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_insertPlotPoint (string guiparticlegraphctrl, int plotID, int i, float x, float y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_insertPlotPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guiparticlegraphctrl,plotID,i,x,y));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_insertPlotPoint(sbguiparticlegraphctrl, plotID, i, x, y);
}
/// <summary>
/// (int plotID, int samples)
///               @return Returns true or false whether or not the point in the plot passed is an existing point.)
/// 
/// </summary>

public string fn_GuiParticleGraphCtrl_isExistingPoint (string guiparticlegraphctrl, int plotID, int samples)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_isExistingPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,samples));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_isExistingPoint(sbguiparticlegraphctrl, plotID, samples, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
/// 			  This will reset the currently selected point to nothing.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_resetSelectedPoint (string guiparticlegraphctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_resetSelectedPoint'" + string.Format("\"{0}\" ",guiparticlegraphctrl));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_resetSelectedPoint(sbguiparticlegraphctrl);
}
/// <summary>
/// (bool autoMax) 
/// 			  Set whether the max will automatically be set when adding points 
/// 			  (ie if you add a value over the current max, the max is increased to that value).
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setAutoGraphMax (string guiparticlegraphctrl, bool autoMax)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setAutoGraphMax'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,autoMax));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setAutoGraphMax(sbguiparticlegraphctrl, autoMax);
}
/// <summary>
/// (bool autoRemove) 
/// 			  Set whether or not a point should be deleted when you drag another one over it.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setAutoRemove (string guiparticlegraphctrl, bool autoRemove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setAutoRemove'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,autoRemove));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setAutoRemove(sbguiparticlegraphctrl, autoRemove);
}
/// <summary>
/// (int plotID, bool isHidden)
/// 			  Set whether the graph number passed is hidden or not.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphHidden (string guiparticlegraphctrl, int plotID, bool isHidden)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphHidden'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,isHidden));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphHidden(sbguiparticlegraphctrl, plotID, isHidden);
}
/// <summary>
/// (int plotID, float maxX, float maxY) 
/// 			  Set the max values of the graph of plotID.
/// 			  @param plotID The plot to modify
/// 			  @param maxX,maxY The maximum bound of the value range.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMax (string guiparticlegraphctrl, int plotID, float maxX, float maxY)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMax'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guiparticlegraphctrl,plotID,maxX,maxY));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMax(sbguiparticlegraphctrl, plotID, maxX, maxY);
}
/// <summary>
/// (int plotID, float maxX)
/// 			  Set the max X value of the graph of plotID.
/// 			  @param plotID The plot to modify.
/// 			  @param maxX The maximum x value.
/// 			  @return No return Value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMaxX (string guiparticlegraphctrl, int plotID, float maxX)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMaxX'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,maxX));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMaxX(sbguiparticlegraphctrl, plotID, maxX);
}
/// <summary>
/// (int plotID, float maxY)
/// 			  Set the max Y value of the graph of plotID.
/// 			  @param plotID The plot to modify.
/// 			  @param maxY The maximum y value.
/// 			  @return No return Value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMaxY (string guiparticlegraphctrl, int plotID, float maxX)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMaxY'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,maxX));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMaxY(sbguiparticlegraphctrl, plotID, maxX);
}
/// <summary>
/// (int plotID, float minX, float minY) 
/// 			  Set the min values of the graph of plotID.
/// 			  @param plotID The plot to modify
/// 			  @param minX,minY The minimum bound of the value range.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMin (string guiparticlegraphctrl, int plotID, float minX, float minY)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMin'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guiparticlegraphctrl,plotID,minX,minY));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMin(sbguiparticlegraphctrl, plotID, minX, minY);
}
/// <summary>
/// (int plotID, float minX) 
/// 			  Set the min X value of the graph of plotID.
/// 			  @param plotID The plot to modify.
/// 			  @param minX The minimum x value.
/// 			  @return No return Value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMinX (string guiparticlegraphctrl, int plotID, float minX)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMinX'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,minX));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMinX(sbguiparticlegraphctrl, plotID, minX);
}
/// <summary>
/// (int plotID, float minY) 
/// 			  Set the min Y value of the graph of plotID.
/// 			  @param plotID The plot to modify.
/// 			  @param minY The minimum y value.
/// 			  @return No return Value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphMinY (string guiparticlegraphctrl, int plotID, float minX)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphMinY'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,minX));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphMinY(sbguiparticlegraphctrl, plotID, minX);
}
/// <summary>
/// (int plotID, string graphName) 
/// 			  Set the name of the given plot.
/// 			  @param plotID The plot to modify.
/// 			  @param graphName The name to set on the plot.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setGraphName (string guiparticlegraphctrl, int plotID, string graphName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setGraphName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiparticlegraphctrl,plotID,graphName));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);
StringBuilder sbgraphName = null;
if (graphName != null)
     sbgraphName = new StringBuilder(graphName, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setGraphName(sbguiparticlegraphctrl, plotID, sbgraphName);
}
/// <summary>
/// (bool clamped)
/// 			  Set whether the x position of the selected graph point should be clamped
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setPointXMovementClamped (string guiparticlegraphctrl, bool autoRemove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setPointXMovementClamped'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,autoRemove));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setPointXMovementClamped(sbguiparticlegraphctrl, autoRemove);
}
/// <summary>
/// (bool renderAll)
/// 			  Set whether or not a position should be rendered on every point or just the last selected.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setRenderAll (string guiparticlegraphctrl, bool autoRemove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setRenderAll'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,autoRemove));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setRenderAll(sbguiparticlegraphctrl, autoRemove);
}
/// <summary>
/// (bool renderGraphTooltip)
/// 			  Set whether or not to render the graph tooltip.
/// 			  @return No return value.)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setRenderGraphTooltip (string guiparticlegraphctrl, bool autoRemove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setRenderGraphTooltip'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,autoRemove));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setRenderGraphTooltip(sbguiparticlegraphctrl, autoRemove);
}
/// <summary>
/// (int plotID)
///               Set the selected plot (a.k.a. graph).
/// 			  @return No return value )
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setSelectedPlot (string guiparticlegraphctrl, int plotID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setSelectedPlot'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,plotID));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setSelectedPlot(sbguiparticlegraphctrl, plotID);
}
/// <summary>
/// (int point)
///               Set the selected point on the graph.
/// 			  @return No return value)
/// 
/// </summary>

public void fn_GuiParticleGraphCtrl_setSelectedPoint (string guiparticlegraphctrl, int point)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiParticleGraphCtrl_setSelectedPoint'" + string.Format("\"{0}\" \"{1}\" ",guiparticlegraphctrl,point));
StringBuilder sbguiparticlegraphctrl = null;
if (guiparticlegraphctrl != null)
     sbguiparticlegraphctrl = new StringBuilder(guiparticlegraphctrl, 1024);

SafeNativeMethods.mwle_fn_GuiParticleGraphCtrl_setSelectedPoint(sbguiparticlegraphctrl, point);
}
/// <summary>
/// , -1, 0), (string name, int idNum, int scheme=0))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_add (string guipopupmenuctrl, string name, int idNum, uint scheme)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_add'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guipopupmenuctrl,name,idNum,scheme));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_add(sbguipopupmenuctrl, sbname, idNum, scheme);
}
/// <summary>
/// (int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_addScheme (string guipopupmenuctrl, uint id, string fontColor, string fontColorHL, string fontColorSEL)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_addScheme'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guipopupmenuctrl,id,fontColor,fontColorHL,fontColorSEL));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);
StringBuilder sbfontColor = null;
if (fontColor != null)
     sbfontColor = new StringBuilder(fontColor, 1024);
StringBuilder sbfontColorHL = null;
if (fontColorHL != null)
     sbfontColorHL = new StringBuilder(fontColorHL, 1024);
StringBuilder sbfontColorSEL = null;
if (fontColorSEL != null)
     sbfontColorSEL = new StringBuilder(fontColorSEL, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_addScheme(sbguipopupmenuctrl, id, sbfontColor, sbfontColorHL, sbfontColorSEL);
}
/// <summary>
/// ( int id, string text ) )
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_changeTextById (string guipopupmenuctrl, int id, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_changeTextById'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guipopupmenuctrl,id,text));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_changeTextById(sbguipopupmenuctrl, id, sbtext);
}
/// <summary>
/// Clear the popup list.)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_clear (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_clear'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_clear(sbguipopupmenuctrl);
}
/// <summary>
/// (S32 entry))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_clearEntry (string guipopupmenuctrl, int entry)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_clearEntry'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrl,entry));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_clearEntry(sbguipopupmenuctrl, entry);
}
/// <summary>
/// (string text)
///               Returns the position of the first entry containing the specified text.)
/// 
/// </summary>

public int fn_GuiPopUpMenuCtrl_findText (string guipopupmenuctrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_findText'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrl,text));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_findText(sbguipopupmenuctrl, sbtext);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_forceClose (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_forceClose'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_forceClose(sbguipopupmenuctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_forceOnAction (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_forceOnAction'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_forceOnAction(sbguipopupmenuctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public int fn_GuiPopUpMenuCtrl_getSelected (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_getSelected'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_getSelected(sbguipopupmenuctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public string fn_GuiPopUpMenuCtrl_getText (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_getText'" + string.Format("\"{0}\" ",guipopupmenuctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_getText(sbguipopupmenuctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int id))
/// 
/// </summary>

public string fn_GuiPopUpMenuCtrl_getTextById (string guipopupmenuctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_getTextById'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrl,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_getTextById(sbguipopupmenuctrl, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (bool doReplaceText))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_replaceText (string guipopupmenuctrl, bool doReplaceText)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_replaceText'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrl,doReplaceText));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_replaceText(sbguipopupmenuctrl, doReplaceText);
}
/// <summary>
/// (string class, string enum)
///               This fills the popup with a classrep's field enumeration type info.
///               More of a helper function than anything.   If console access to the field list is added, 
///               at least for the enumerated types, then this should go away..)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_setEnumContent (string guipopupmenuctrl, string className, string enumName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_setEnumContent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guipopupmenuctrl,className,enumName));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);
StringBuilder sbenumName = null;
if (enumName != null)
     sbenumName = new StringBuilder(enumName, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_setEnumContent(sbguipopupmenuctrl, sbclassName, sbenumName);
}
/// <summary>
/// ([scriptCallback=true]))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_setFirstSelected (string guipopupmenuctrl, bool scriptCallback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_setFirstSelected'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrl,scriptCallback));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_setFirstSelected(sbguipopupmenuctrl, scriptCallback);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_setNoneSelected (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_setNoneSelected'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_setNoneSelected(sbguipopupmenuctrl);
}
/// <summary>
/// (int id, [scriptCallback=true]))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_setSelected (string guipopupmenuctrl, int id, bool scriptCallback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_setSelected'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guipopupmenuctrl,id,scriptCallback));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_setSelected(sbguipopupmenuctrl, id, scriptCallback);
}
/// <summary>
/// Get the size of the menu - the number of entries in it.)
/// 
/// </summary>

public int fn_GuiPopUpMenuCtrl_size (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_size'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_size(sbguipopupmenuctrl);
}
/// <summary>
/// Sort the list alphabetically.)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_sort (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_sort'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_sort(sbguipopupmenuctrl);
}
/// <summary>
/// Sort the list by ID.)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrl_sortID (string guipopupmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrl_sortID'" + string.Format("\"{0}\" ",guipopupmenuctrl));
StringBuilder sbguipopupmenuctrl = null;
if (guipopupmenuctrl != null)
     sbguipopupmenuctrl = new StringBuilder(guipopupmenuctrl, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrl_sortID(sbguipopupmenuctrl);
}
/// <summary>
/// , -1, 0), (string name, int idNum, int scheme=0))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_add (string guipopupmenuctrlex, string name, int idNum, uint scheme)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_add'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guipopupmenuctrlex,name,idNum,scheme));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_add(sbguipopupmenuctrlex, sbname, idNum, scheme);
}
/// <summary>
/// (S32 entry))
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_clearEntry (string guipopupmenuctrlex, int entry)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_clearEntry'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,entry));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_clearEntry(sbguipopupmenuctrlex, entry);
}
/// <summary>
/// (string text)
///               Returns the id of the first entry containing the specified text or -1 if not found.
/// 			  @param text String value used for the query
/// 			  @return Numerical ID of entry containing the text.)
/// 
/// </summary>

public int fn_GuiPopUpMenuCtrlEx_findText (string guipopupmenuctrlex, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_findText'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,text));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_findText(sbguipopupmenuctrlex, sbtext);
}
/// <summary>
/// @brief Get color of an entry's box
/// 			  @param id ID number of entry to query
/// 			  @return ColorI in the format of \"Red Green Blue Alpha\", each of with is a value between 0 - 255)
/// 
/// </summary>

public string fn_GuiPopUpMenuCtrlEx_getColorById (string guipopupmenuctrlex, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_getColorById'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,id));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_getColorById(sbguipopupmenuctrlex, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Flag that causes each new text addition to replace the current entry
/// 			  @param True to turn on replacing, false to disable it)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_replaceText (string guipopupmenuctrlex, int boolVal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_replaceText'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,boolVal));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_replaceText(sbguipopupmenuctrlex, boolVal);
}
/// <summary>
/// @brief This fills the popup with a classrep's field enumeration type info.
///               More of a helper function than anything.   If console access to the field list is added, 
///               at least for the enumerated types, then this should go away.
/// 			  @param class Name of the class containing the enum
/// 			  @param enum Name of the enum value to acces)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_setEnumContent (string guipopupmenuctrlex, string className, string enumName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_setEnumContent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guipopupmenuctrlex,className,enumName));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);
StringBuilder sbenumName = null;
if (enumName != null)
     sbenumName = new StringBuilder(enumName, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_setEnumContent(sbguipopupmenuctrlex, sbclassName, sbenumName);
}
/// <summary>
/// ([scriptCallback=true])
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_setFirstSelected (string guipopupmenuctrlex, bool scriptCallback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_setFirstSelected'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,scriptCallback));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_setFirstSelected(sbguipopupmenuctrlex, scriptCallback);
}
/// <summary>
/// (int id, [scriptCallback=true])
/// 			  @hide)
/// 
/// </summary>

public void fn_GuiPopUpMenuCtrlEx_setSelected (string guipopupmenuctrlex, int id, bool scriptCallback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_setSelected'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guipopupmenuctrlex,id,scriptCallback));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_setSelected(sbguipopupmenuctrlex, id, scriptCallback);
}
/// <summary>
/// @brief Get the size of the menu
/// 			  @return Number of entries in the menu)
/// 
/// </summary>

public int fn_GuiPopUpMenuCtrlEx_size (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiPopUpMenuCtrlEx_size'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

return  SafeNativeMethods.mwle_fn_GuiPopUpMenuCtrlEx_size(sbguipopupmenuctrlex);
}
/// <summary>
/// deleteNode() )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_deleteNode (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_deleteNode'" + string.Format("\"{0}\" ",guirivereditorctrl));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_deleteNode(sbguirivereditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiRiverEditorCtrl_getMode (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getMode'" + string.Format("\"{0}\" ",guirivereditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getMode(sbguirivereditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public float fn_GuiRiverEditorCtrl_getNodeDepth (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getNodeDepth'" + string.Format("\"{0}\" ",guirivereditorctrl));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getNodeDepth(sbguirivereditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiRiverEditorCtrl_getNodeNormal (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getNodeNormal'" + string.Format("\"{0}\" ",guirivereditorctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getNodeNormal(sbguirivereditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiRiverEditorCtrl_getNodePosition (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getNodePosition'" + string.Format("\"{0}\" ",guirivereditorctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getNodePosition(sbguirivereditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public float fn_GuiRiverEditorCtrl_getNodeWidth (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getNodeWidth'" + string.Format("\"{0}\" ",guirivereditorctrl));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getNodeWidth(sbguirivereditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiRiverEditorCtrl_getSelectedRiver (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_getSelectedRiver'" + string.Format("\"{0}\" ",guirivereditorctrl));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_getSelectedRiver(sbguirivereditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_regenerate (string guirivereditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_regenerate'" + string.Format("\"{0}\" ",guirivereditorctrl));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_regenerate(sbguirivereditorctrl);
}
/// <summary>
/// setMode( String mode ) )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setMode (string guirivereditorctrl, string mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setMode'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,mode));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);
StringBuilder sbmode = null;
if (mode != null)
     sbmode = new StringBuilder(mode, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setMode(sbguirivereditorctrl, sbmode);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setNodeDepth (string guirivereditorctrl, float depth)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setNodeDepth'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,depth));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setNodeDepth(sbguirivereditorctrl, depth);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setNodeNormal (string guirivereditorctrl, string normal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setNodeNormal'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,normal));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);
StringBuilder sbnormal = null;
if (normal != null)
     sbnormal = new StringBuilder(normal, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setNodeNormal(sbguirivereditorctrl, sbnormal);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setNodePosition (string guirivereditorctrl, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setNodePosition'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,pos));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setNodePosition(sbguirivereditorctrl, sbpos);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setNodeWidth (string guirivereditorctrl, float width)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setNodeWidth'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,width));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setNodeWidth(sbguirivereditorctrl, width);
}
/// <summary>
/// ),  )
/// 
/// </summary>

public void fn_GuiRiverEditorCtrl_setSelectedRiver (string guirivereditorctrl, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRiverEditorCtrl_setSelectedRiver'" + string.Format("\"{0}\" \"{1}\" ",guirivereditorctrl,objName));
StringBuilder sbguirivereditorctrl = null;
if (guirivereditorctrl != null)
     sbguirivereditorctrl = new StringBuilder(guirivereditorctrl, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_GuiRiverEditorCtrl_setSelectedRiver(sbguirivereditorctrl, sbobjName);
}
/// <summary>
/// deleteNode() )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_deleteNode (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_deleteNode'" + string.Format("\"{0}\" ",guiroadeditorctrl));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_deleteNode(sbguiroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_deleteRoad (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_deleteRoad'" + string.Format("\"{0}\" ",guiroadeditorctrl));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_deleteRoad(sbguiroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiRoadEditorCtrl_getMode (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_getMode'" + string.Format("\"{0}\" ",guiroadeditorctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_getMode(sbguiroadeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public string fn_GuiRoadEditorCtrl_getNodePosition (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_getNodePosition'" + string.Format("\"{0}\" ",guiroadeditorctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_getNodePosition(sbguiroadeditorctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public float fn_GuiRoadEditorCtrl_getNodeWidth (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_getNodeWidth'" + string.Format("\"{0}\" ",guiroadeditorctrl));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_getNodeWidth(sbguiroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiRoadEditorCtrl_getSelectedNode (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_getSelectedNode'" + string.Format("\"{0}\" ",guiroadeditorctrl));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_getSelectedNode(sbguiroadeditorctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fn_GuiRoadEditorCtrl_getSelectedRoad (string guiroadeditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_getSelectedRoad'" + string.Format("\"{0}\" ",guiroadeditorctrl));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_getSelectedRoad(sbguiroadeditorctrl);
}
/// <summary>
/// setMode( String mode ) )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_setMode (string guiroadeditorctrl, string mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_setMode'" + string.Format("\"{0}\" \"{1}\" ",guiroadeditorctrl,mode));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);
StringBuilder sbmode = null;
if (mode != null)
     sbmode = new StringBuilder(mode, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_setMode(sbguiroadeditorctrl, sbmode);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_setNodePosition (string guiroadeditorctrl, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_setNodePosition'" + string.Format("\"{0}\" \"{1}\" ",guiroadeditorctrl,pos));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_setNodePosition(sbguiroadeditorctrl, sbpos);
}
/// <summary>
///  )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_setNodeWidth (string guiroadeditorctrl, float width)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_setNodeWidth'" + string.Format("\"{0}\" \"{1}\" ",guiroadeditorctrl,width));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_setNodeWidth(sbguiroadeditorctrl, width);
}
/// <summary>
/// ),  )
/// 
/// </summary>

public void fn_GuiRoadEditorCtrl_setSelectedRoad (string guiroadeditorctrl, string pathRoad)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiRoadEditorCtrl_setSelectedRoad'" + string.Format("\"{0}\" \"{1}\" ",guiroadeditorctrl,pathRoad));
StringBuilder sbguiroadeditorctrl = null;
if (guiroadeditorctrl != null)
     sbguiroadeditorctrl = new StringBuilder(guiroadeditorctrl, 1024);
StringBuilder sbpathRoad = null;
if (pathRoad != null)
     sbpathRoad = new StringBuilder(pathRoad, 1024);

SafeNativeMethods.mwle_fn_GuiRoadEditorCtrl_setSelectedRoad(sbguiroadeditorctrl, sbpathRoad);
}
/// <summary>
/// Return a Point2F containing the position of the origin.)
/// 
/// </summary>

public string fn_GuiTerrPreviewCtrl_getOrigin (string guiterrpreviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_getOrigin'" + string.Format("\"{0}\" ",guiterrpreviewctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_getOrigin(sbguiterrpreviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return a Point2F representing the position of the root.)
/// 
/// </summary>

public string fn_GuiTerrPreviewCtrl_getRoot (string guiterrpreviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_getRoot'" + string.Format("\"{0}\" ",guiterrpreviewctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_getRoot(sbguiterrpreviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns a 4-tuple containing: root_x root_y origin_x origin_y)
/// 
/// </summary>

public string fn_GuiTerrPreviewCtrl_getValue (string guiterrpreviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_getValue'" + string.Format("\"{0}\" ",guiterrpreviewctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_getValue(sbguiterrpreviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Reset the view of the terrain.)
/// 
/// </summary>

public void fn_GuiTerrPreviewCtrl_reset (string guiterrpreviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_reset'" + string.Format("\"{0}\" ",guiterrpreviewctrl));
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_reset(sbguiterrpreviewctrl);
}
/// <summary>
/// (float x, float y)
///               Set the origin of the view.)
/// 
/// </summary>

public void fn_GuiTerrPreviewCtrl_setOrigin (string guiterrpreviewctrl, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_setOrigin'" + string.Format("\"{0}\" \"{1}\" ",guiterrpreviewctrl,pos));
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_setOrigin(sbguiterrpreviewctrl, sbpos);
}
/// <summary>
/// Add the origin to the root and reset the origin.)
/// 
/// </summary>

public void fn_GuiTerrPreviewCtrl_setRoot (string guiterrpreviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_setRoot'" + string.Format("\"{0}\" ",guiterrpreviewctrl));
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_setRoot(sbguiterrpreviewctrl);
}
/// <summary>
/// Accepts a 4-tuple in the same form as getValue returns.
///               @see GuiTerrPreviewCtrl::getValue())
/// 
/// </summary>

public void fn_GuiTerrPreviewCtrl_setValue (string guiterrpreviewctrl, string tuple)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTerrPreviewCtrl_setValue'" + string.Format("\"{0}\" \"{1}\" ",guiterrpreviewctrl,tuple));
StringBuilder sbguiterrpreviewctrl = null;
if (guiterrpreviewctrl != null)
     sbguiterrpreviewctrl = new StringBuilder(guiterrpreviewctrl, 1024);
StringBuilder sbtuple = null;
if (tuple != null)
     sbtuple = new StringBuilder(tuple, 1024);

SafeNativeMethods.mwle_fn_GuiTerrPreviewCtrl_setValue(sbguiterrpreviewctrl, sbtuple);
}
/// <summary>
/// textEditCtrl.selectText( %startBlock, %endBlock ) )
/// 
/// </summary>

public void fn_GuiTextEditCtrl_selectText (string guitexteditctrl, int startBlock, int endBlock)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTextEditCtrl_selectText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitexteditctrl,startBlock,endBlock));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTextEditCtrl_selectText(sbguitexteditctrl, startBlock, endBlock);
}
/// <summary>
/// ( [tick = true] ) - This will set this object to either be processing ticks or not )
/// 
/// </summary>

public void fn_GuiTickCtrl_setProcessTicks (string guitickctrl, bool tick)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTickCtrl_setProcessTicks'" + string.Format("\"{0}\" \"{1}\" ",guitickctrl,tick));
StringBuilder sbguitickctrl = null;
if (guitickctrl != null)
     sbguitickctrl = new StringBuilder(guitickctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTickCtrl_setProcessTicks(sbguitickctrl, tick);
}
/// <summary>
/// ( filepath name ) sets the bitmap that shows when the button is disabled)
/// 
/// </summary>

public void fn_GuiToolboxButtonCtrl_setHoverBitmap (string guitoolboxbuttonctrl, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiToolboxButtonCtrl_setHoverBitmap'" + string.Format("\"{0}\" \"{1}\" ",guitoolboxbuttonctrl,name));
StringBuilder sbguitoolboxbuttonctrl = null;
if (guitoolboxbuttonctrl != null)
     sbguitoolboxbuttonctrl = new StringBuilder(guitoolboxbuttonctrl, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_GuiToolboxButtonCtrl_setHoverBitmap(sbguitoolboxbuttonctrl, sbname);
}
/// <summary>
/// ( filepath name ) sets the bitmap that shows when the button is disabled)
/// 
/// </summary>

public void fn_GuiToolboxButtonCtrl_setLoweredBitmap (string guitoolboxbuttonctrl, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiToolboxButtonCtrl_setLoweredBitmap'" + string.Format("\"{0}\" \"{1}\" ",guitoolboxbuttonctrl,name));
StringBuilder sbguitoolboxbuttonctrl = null;
if (guitoolboxbuttonctrl != null)
     sbguitoolboxbuttonctrl = new StringBuilder(guitoolboxbuttonctrl, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_GuiToolboxButtonCtrl_setLoweredBitmap(sbguitoolboxbuttonctrl, sbname);
}
/// <summary>
/// ( filepath name ) sets the bitmap that shows when the button is active)
/// 
/// </summary>

public void fn_GuiToolboxButtonCtrl_setNormalBitmap (string guitoolboxbuttonctrl, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiToolboxButtonCtrl_setNormalBitmap'" + string.Format("\"{0}\" \"{1}\" ",guitoolboxbuttonctrl,name));
StringBuilder sbguitoolboxbuttonctrl = null;
if (guitoolboxbuttonctrl != null)
     sbguitoolboxbuttonctrl = new StringBuilder(guitoolboxbuttonctrl, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_GuiToolboxButtonCtrl_setNormalBitmap(sbguitoolboxbuttonctrl, sbname);
}
/// <summary>
/// addChildSelectionByValue(TreeItemId parent, value))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_addChildSelectionByValue (string guitreeviewctrl, int id, string tableEntry)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_addChildSelectionByValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,tableEntry));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbtableEntry = null;
if (tableEntry != null)
     sbtableEntry = new StringBuilder(tableEntry, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_addChildSelectionByValue(sbguitreeviewctrl, id, sbtableEntry);
}
/// <summary>
/// (builds an icon table))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_buildIconTable (string guitreeviewctrl, string icons)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_buildIconTable'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,icons));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbicons = null;
if (icons != null)
     sbicons = new StringBuilder(icons, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_buildIconTable(sbguitreeviewctrl, sbicons)>=1;
}
/// <summary>
/// Build the visible tree)
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_buildVisibleTree (string guitreeviewctrl, bool forceFullUpdate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_buildVisibleTree'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,forceFullUpdate));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_buildVisibleTree(sbguitreeviewctrl, forceFullUpdate);
}
/// <summary>
/// For internal use. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_cancelRename (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_cancelRename'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_cancelRename(sbguitreeviewctrl);
}
/// <summary>
/// () - empty tree)
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_clear (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_clear'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_clear(sbguitreeviewctrl);
}
/// <summary>
/// (TreeItemId item, string newText, string newValue))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_editItem (string guitreeviewctrl, int item, string newText, string newValue)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_editItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guitreeviewctrl,item,newText,newValue));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbnewText = null;
if (newText != null)
     sbnewText = new StringBuilder(newText, 1024);
StringBuilder sbnewValue = null;
if (newValue != null)
     sbnewValue = new StringBuilder(newValue, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_editItem(sbguitreeviewctrl, item, sbnewText, sbnewValue)>=1;
}
/// <summary>
/// (TreeItemId item, bool expand=true))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_expandItem (string guitreeviewctrl, int id, bool expand)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_expandItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,expand));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_expandItem(sbguitreeviewctrl, id, expand)>=1;
}
/// <summary>
/// (find item by object id and returns the mId))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_findItemByObjectId (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_findItemByObjectId'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_findItemByObjectId(sbguitreeviewctrl, itemId);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getChild (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getChild'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getChild(sbguitreeviewctrl, itemId);
}
/// <summary>
/// Get id for root item.)
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getFirstRootItem (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getFirstRootItem'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getFirstRootItem(sbguitreeviewctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getItemCount (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getItemCount'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getItemCount(sbguitreeviewctrl);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public string fn_GuiTreeViewCtrl_getItemText (string guitreeviewctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getItemText'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getItemText(sbguitreeviewctrl, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public string fn_GuiTreeViewCtrl_getItemValue (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getItemValue'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getItemValue(sbguitreeviewctrl, itemId, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getNextSibling (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getNextSibling'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getNextSibling(sbguitreeviewctrl, itemId);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getParentItem (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getParentItem'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getParentItem(sbguitreeviewctrl, itemId);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getPrevSibling (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getPrevSibling'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getPrevSibling(sbguitreeviewctrl, itemId);
}
/// <summary>
/// ( int index=0 ) - Return the selected item at the given index.)
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getSelectedItem (string guitreeviewctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getSelectedItem'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,index));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getSelectedItem(sbguitreeviewctrl, index);
}
/// <summary>
/// returns a space seperated list of mulitple item ids)
/// 
/// </summary>

public string fn_GuiTreeViewCtrl_getSelectedItemList (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getSelectedItemList'" + string.Format("\"{0}\" ",guitreeviewctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getSelectedItemList(sbguitreeviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getSelectedItemsCount (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getSelectedItemsCount'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getSelectedItemsCount(sbguitreeviewctrl);
}
/// <summary>
/// ( int index=0 ) - Return the currently selected SimObject at the given index in inspector mode or -1)
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_getSelectedObject (string guitreeviewctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getSelectedObject'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,index));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getSelectedObject(sbguitreeviewctrl, index);
}
/// <summary>
/// Returns a space sperated list of all selected object ids.)
/// 
/// </summary>

public string fn_GuiTreeViewCtrl_getSelectedObjectList (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getSelectedObjectList'" + string.Format("\"{0}\" ",guitreeviewctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getSelectedObjectList(sbguitreeviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (TreeItemId item,Delimiter=none) gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally)
/// 
/// </summary>

public string fn_GuiTreeViewCtrl_getTextToRoot (string guitreeviewctrl, int itemId, string delimiter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_getTextToRoot'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,itemId,delimiter));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbdelimiter = null;
if (delimiter != null)
     sbdelimiter = new StringBuilder(delimiter, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_getTextToRoot(sbguitreeviewctrl, itemId, sbdelimiter, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( int id ) - Returns true if the given item contains child items. )
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_isParentItem (string guitreeviewctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_isParentItem'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,id));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_isParentItem(sbguitreeviewctrl, id)>=1;
}
/// <summary>
/// (TreeItemId item, bool mark=true))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_markItem (string guitreeviewctrl, int id, bool mark)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_markItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,mark));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_markItem(sbguitreeviewctrl, id, mark)>=1;
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_moveItemDown (string guitreeviewctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_moveItemDown'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,index));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_moveItemDown(sbguitreeviewctrl, index);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_moveItemUp (string guitreeviewctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_moveItemUp'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,index));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_moveItemUp(sbguitreeviewctrl, index);
}
/// <summary>
/// For internal use. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_onRenameValidate (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_onRenameValidate'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_onRenameValidate(sbguitreeviewctrl);
}
/// <summary>
/// (SimSet obj, bool okToEdit=true) Set the root of the tree view to the specified object, or to the root set.)
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_open (string guitreeviewctrl, string objName, bool okToEdit)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_open'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,objName,okToEdit));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_open(sbguitreeviewctrl, sbobjName, okToEdit);
}
/// <summary>
/// removeAllChildren(TreeItemId parent))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_removeAllChildren (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_removeAllChildren'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_removeAllChildren(sbguitreeviewctrl, itemId);
}
/// <summary>
/// removeChildSelectionByValue(TreeItemId parent, value))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_removeChildSelectionByValue (string guitreeviewctrl, int id, string tableEntry)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_removeChildSelectionByValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,tableEntry));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbtableEntry = null;
if (tableEntry != null)
     sbtableEntry = new StringBuilder(tableEntry, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_removeChildSelectionByValue(sbguitreeviewctrl, id, sbtableEntry);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_removeItem (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_removeItem'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_removeItem(sbguitreeviewctrl, itemId)>=1;
}
/// <summary>
/// (deselects an item))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_removeSelection (string guitreeviewctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_removeSelection'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,id));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_removeSelection(sbguitreeviewctrl, id);
}
/// <summary>
/// (TreeItemId item))
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_scrollVisible (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_scrollVisible'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_scrollVisible(sbguitreeviewctrl, itemId);
}
/// <summary>
/// (show item by object id. returns true if sucessful.))
/// 
/// </summary>

public int fn_GuiTreeViewCtrl_scrollVisibleByObjectId (string guitreeviewctrl, int itemId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_scrollVisibleByObjectId'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,itemId));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_scrollVisibleByObjectId(sbguitreeviewctrl, itemId);
}
/// <summary>
/// (TreeItemId item, bool select=true))
/// 
/// </summary>

public bool fn_GuiTreeViewCtrl_selectItem (string guitreeviewctrl, int id, bool select)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_selectItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,select));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_selectItem(sbguitreeviewctrl, id, select)>=1;
}
/// <summary>
/// ( bool value=true ) - Enable/disable debug output. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_setDebug (string guitreeviewctrl, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_setDebug'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,value));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_setDebug(sbguitreeviewctrl, value);
}
/// <summary>
/// ( int id, int normalImage, int expandedImage ) - Sets the normal and expanded images to show for the given item. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_setItemImages (string guitreeviewctrl, int id, sbyte normalImage, sbyte expandedImage)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_setItemImages'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guitreeviewctrl,id,normalImage,expandedImage));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_setItemImages(sbguitreeviewctrl, id, normalImage, expandedImage);
}
/// <summary>
/// ( int id, string text ) - Set the tooltip to show for the given item. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_setItemTooltip (string guitreeviewctrl, int id, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_setItemTooltip'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,text));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_setItemTooltip(sbguitreeviewctrl, id, sbtext);
}
/// <summary>
/// ( TreeItemId id ) - Show the rename text field for the given item (only one at a time). )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_showItemRenameCtrl (string guitreeviewctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_showItemRenameCtrl'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,id));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_showItemRenameCtrl(sbguitreeviewctrl, id);
}
/// <summary>
/// ( int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true ) - Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy. )
/// 
/// </summary>

public void fn_GuiTreeViewCtrl_sort (string guitreeviewctrl, int parent, bool traverseHierarchy, bool parentsFirst, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiTreeViewCtrl_sort'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guitreeviewctrl,parent,traverseHierarchy,parentsFirst,caseSensitive));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fn_GuiTreeViewCtrl_sort(sbguitreeviewctrl, parent, traverseHierarchy, parentsFirst, caseSensitive);
}
/// <summary>
/// loadVars( searchString ) )
/// 
/// </summary>

public void fn_GuiVariableInspector_loadVars (string guivariableinspector, string searchString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_GuiVariableInspector_loadVars'" + string.Format("\"{0}\" \"{1}\" ",guivariableinspector,searchString));
StringBuilder sbguivariableinspector = null;
if (guivariableinspector != null)
     sbguivariableinspector = new StringBuilder(guivariableinspector, 1024);
StringBuilder sbsearchString = null;
if (searchString != null)
     sbsearchString = new StringBuilder(searchString, 1024);

SafeNativeMethods.mwle_fn_GuiVariableInspector_loadVars(sbguivariableinspector, sbsearchString);
}
/// <summary>
/// Import an image strip from exportCachedFont. Call with the 
///    same parameters you called exportCachedFont.
///    @param faceName The name of the font face.
///    @param fontSize The size of the font in pixels.
///    @param fileName The file name and path for the input PNG.
///    @param padding The padding between characters.   
///    @param kerning The kerning between characters.   
///    @ingroup Font )
/// 
/// </summary>

public void fn_importCachedFont (string faceName, int fontSize, string fileName, int padding, int kerning)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_importCachedFont'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",faceName,fontSize,fileName,padding,kerning));
StringBuilder sbfaceName = null;
if (faceName != null)
     sbfaceName = new StringBuilder(faceName, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_importCachedFont(sbfaceName, fontSize, sbfileName, padding, kerning);
}
/// <summary>
/// @brief Start a search for items at the given position and within the given radius, filtering by mask.
/// 
///    @param pos Center position for the search
///    @param radius Search radius
///    @param mask Bitmask of object types to include in the search
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
/// 
///    @see containerSearchNext 
///    @ingroup Game)
/// 
/// </summary>

public void fn_initContainerRadiusSearch (string pos, float radius, uint mask, bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_initContainerRadiusSearch'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",pos,radius,mask,useClientContainer));
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_initContainerRadiusSearch(sbpos, radius, mask, useClientContainer);
}
/// <summary>
/// @brief Start a search for all items of the types specified by the bitset mask.
/// 
///    @param mask Bitmask of object types to include in the search
///    @param useClientContainer Optionally indicates the search should be within the 
///    client container.
/// 
///    @see containerSearchNext 
///    @ingroup Game)
/// 
/// </summary>

public void fn_initContainerTypeSearch (uint mask, bool useClientContainer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_initContainerTypeSearch'" + string.Format("\"{0}\" \"{1}\" ",mask,useClientContainer));

SafeNativeMethods.mwle_fn_initContainerTypeSearch(mask, useClientContainer);
}
/// <summary>
/// ()
/// 				@brief Initializes variables that track device and vendor information/IDs
/// 				@ingroup Rendering)
/// 
/// </summary>

public void fn_initDisplayDeviceInfo ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_initDisplayDeviceInfo'");


SafeNativeMethods.mwle_fn_initDisplayDeviceInfo();
}
/// <summary>
/// Test whether the character at the given position is an alpha-numeric character.
///    Alpha-numeric characters are characters that are either alphabetic (a-z, A-Z) or numbers (0-9).
///    @param str The string to test.
///    @param index The index of a character in @a str.
///    @return True if the character at the given index in @a str is an alpha-numeric character; false otherwise.
///    @see isspace
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_isalnum (string str, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isalnum'" + string.Format("\"{0}\" \"{1}\" ",str,index));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_isalnum(sbstr, index)>=1;
}
/// <summary>
/// @brief Returns true if the passed identifier is the name of a declared class.
/// 				@ingroup Console)
/// 
/// </summary>

public bool fn_isClass (string identifier)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isClass'" + string.Format("\"{0}\" ",identifier));
StringBuilder sbidentifier = null;
if (identifier != null)
     sbidentifier = new StringBuilder(identifier, 1024);

return  SafeNativeMethods.mwle_fn_isClass(sbidentifier)>=1;
}
/// <summary>
/// () 
///    Returns true if the calling script is a tools script.
///    @hide)
/// 
/// </summary>

public bool fn_isCurrentScriptToolScript ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isCurrentScriptToolScript'");


return  SafeNativeMethods.mwle_fn_isCurrentScriptToolScript()>=1;
}
/// <summary>
/// Test whether the engine has been compiled with TORQUE_DEBUG, i.e. if it includes debugging functionality.
///    @return True if this is a debug build; false otherwise.
///    @ingroup Platform )
/// 
/// </summary>

public bool fn_isDebugBuild ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isDebugBuild'");


return  SafeNativeMethods.mwle_fn_isDebugBuild()>=1;
}
/// <summary>
/// ) , (string varName) 
/// 	@brief Determines if a variable exists and contains a value
/// 	@param varName Name of the variable to search for
/// 	@return True if the variable was defined in script, false if not
///    @tsexample
///       isDefined( \"$myVar\" );
///    @endtsexample
/// 	@ingroup Scripting)
/// 
/// </summary>

public bool fn_isDefined (string varName, string varValue)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isDefined'" + string.Format("\"{0}\" \"{1}\" ",varName,varValue));
StringBuilder sbvarName = null;
if (varName != null)
     sbvarName = new StringBuilder(varName, 1024);
StringBuilder sbvarValue = null;
if (varValue != null)
     sbvarValue = new StringBuilder(varValue, 1024);

return  SafeNativeMethods.mwle_fn_isDefined(sbvarName, sbvarValue)>=1;
}
/// <summary>
/// )
/// 
/// </summary>

public bool fn_isDemo ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isDemo'");


return  SafeNativeMethods.mwle_fn_isDemo()>=1;
}
/// <summary>
/// @brief Determines if a specified directory exists or not
/// 
/// 	@param directory String containing path in the form of \"foo/bar\"
///    @return Returns true if the directory was found.
/// 
/// 	@note Do not include a trailing slash '/'.
/// 
/// 	@ingroup FileSystem)
/// 
/// </summary>

public bool fn_IsDirectory (string directory)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_IsDirectory'" + string.Format("\"{0}\" ",directory));
StringBuilder sbdirectory = null;
if (directory != null)
     sbdirectory = new StringBuilder(directory, 1024);

return  SafeNativeMethods.mwle_fn_IsDirectory(sbdirectory)>=1;
}
/// <summary>
/// isEventPending(%scheduleId);)
/// 
/// </summary>

public bool fn_isEventPending (int scheduleId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isEventPending'" + string.Format("\"{0}\" ",scheduleId));

return  SafeNativeMethods.mwle_fn_isEventPending(scheduleId)>=1;
}
/// <summary>
/// @brief Determines if the specified file exists or not
///    
///    @param fileName The path to the file.
///    @return Returns true if the file was found.
///    
///    @ingroup FileSystem)
/// 
/// </summary>

public bool fn_isFile (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isFile'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_isFile(sbfileName)>=1;
}
/// <summary>
/// (string funcName) 
/// 	@brief Determines if a function exists or not
/// 	@param funcName String containing name of the function
/// 	@return True if the function exists, false if not
/// 	@ingroup Scripting)
/// 
/// </summary>

public bool fn_isFunction (string funcName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isFunction'" + string.Format("\"{0}\" ",funcName));
StringBuilder sbfuncName = null;
if (funcName != null)
     sbfuncName = new StringBuilder(funcName, 1024);

return  SafeNativeMethods.mwle_fn_isFunction(sbfuncName)>=1;
}
/// <summary>
/// isJoystickDetected())
/// 
/// </summary>

public bool fn_isJoystickDetected ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isJoystickDetected'");


return  SafeNativeMethods.mwle_fn_isJoystickDetected()>=1;
}
/// <summary>
/// ()
/// 				@brief Queries input manager to see if a joystick is enabled
/// 				@return 1 if a joystick exists and is enabled, 0 if it's not.
/// 				@ingroup Input)
/// 
/// </summary>

public bool fn_isJoystickEnabled ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isJoystickEnabled'");


return  SafeNativeMethods.mwle_fn_isJoystickEnabled()>=1;
}
/// <summary>
/// isKoreanBuild())
/// 
/// </summary>

public bool fn_isKoreanBuild ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isKoreanBuild'");


return  SafeNativeMethods.mwle_fn_isKoreanBuild()>=1;
}
/// <summary>
/// @brief Returns true if the class is derived from the super class.
///    If either class doesn't exist this returns false.
///    @param className The class name.
///    @param superClassName The super class to look for.
///    @ingroup Console)
/// 
/// </summary>

public bool fn_isMemberOfClass (string className, string superClassName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isMemberOfClass'" + string.Format("\"{0}\" \"{1}\" ",className,superClassName));
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);
StringBuilder sbsuperClassName = null;
if (superClassName != null)
     sbsuperClassName = new StringBuilder(superClassName, 1024);

return  SafeNativeMethods.mwle_fn_isMemberOfClass(sbclassName, sbsuperClassName)>=1;
}
/// <summary>
/// (string namespace, string method) 
/// 	@brief Determines if a class/namespace method exists
/// 	@param namespace Class or namespace, such as Player
/// 	@param method Name of the function to search for
/// 	@return True if the method exists, false if not
/// 	@ingroup Scripting)
/// 
/// </summary>

public bool fn_isMethod (string nameSpace, string method)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isMethod'" + string.Format("\"{0}\" \"{1}\" ",nameSpace,method));
StringBuilder sbnameSpace = null;
if (nameSpace != null)
     sbnameSpace = new StringBuilder(nameSpace, 1024);
StringBuilder sbmethod = null;
if (method != null)
     sbmethod = new StringBuilder(method, 1024);

return  SafeNativeMethods.mwle_fn_isMethod(sbnameSpace, sbmethod)>=1;
}
/// <summary>
/// isObject(object))
/// 
/// </summary>

public bool fn_isObject (string objectName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isObject'" + string.Format("\"{0}\" ",objectName));
StringBuilder sbobjectName = null;
if (objectName != null)
     sbobjectName = new StringBuilder(objectName, 1024);

return  SafeNativeMethods.mwle_fn_isObject(sbobjectName)>=1;
}
/// <summary>
/// @brief Returns true if the identifier is the name of a declared package.
///    @ingroup Packages)
/// 
/// </summary>

public bool fn_isPackage (string identifier)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isPackage'" + string.Format("\"{0}\" ",identifier));
StringBuilder sbidentifier = null;
if (identifier != null)
     sbidentifier = new StringBuilder(identifier, 1024);

return  SafeNativeMethods.mwle_fn_isPackage(sbidentifier)>=1;
}
/// <summary>
/// (string queueName)
/// 				@brief Determines if a dispatcher queue exists
/// 				@param queueName String containing the name of queue
/// 				@ingroup Messaging)
/// 
/// </summary>

public bool fn_isQueueRegistered (string queueName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isQueueRegistered'" + string.Format("\"{0}\" ",queueName));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);

return  SafeNativeMethods.mwle_fn_isQueueRegistered(sbqueueName)>=1;
}
/// <summary>
/// Test whether the engine has been compiled with TORQUE_SHIPPING, i.e. in a form meant for final release.
///    @return True if this is a shipping build; false otherwise.
///    @ingroup Platform )
/// 
/// </summary>

public bool fn_isShippingBuild ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isShippingBuild'");


return  SafeNativeMethods.mwle_fn_isShippingBuild()>=1;
}
/// <summary>
/// Test whether the character at the given position is a whitespace character.
///    Characters such as tab, space, or newline are considered whitespace.
///    @param str The string to test.
///    @param index The index of a character in @a str.
///    @return True if the character at the given index in @a str is a whitespace character; false otherwise.
///    @see isalnum
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_isspace (string str, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isspace'" + string.Format("\"{0}\" \"{1}\" ",str,index));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_isspace(sbstr, index)>=1;
}
/// <summary>
/// Test whether the engine has been compiled with TORQUE_TOOLS, i.e. if it includes tool-related functionality.
///    @return True if this is a tool build; false otherwise.
///    @ingroup Platform )
/// 
/// </summary>

public bool fn_isToolBuild ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isToolBuild'");


return  SafeNativeMethods.mwle_fn_isToolBuild()>=1;
}
/// <summary>
/// ( string name )
/// 				@brief Return true if the given name makes for a valid object name.
/// 				@param name Name of object
/// 				@return True if name is allowed, false if denied (usually because it starts with a number, _, or invalid character
/// 				@ingroup Console)
/// 
/// </summary>

public bool fn_isValidObjectName (string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isValidObjectName'" + string.Format("\"{0}\" ",name));
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fn_isValidObjectName(sbname)>=1;
}
/// <summary>
/// )
/// 
/// </summary>

public bool fn_isWebDemo ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isWebDemo'");


return  SafeNativeMethods.mwle_fn_isWebDemo()>=1;
}
/// <summary>
/// @brief Determines if a file name can be written to using File I/O
/// 
/// 	@param fileName Name and path of file to check
/// 	@return Returns true if the file can be written to.
/// 
/// 	@ingroup FileSystem)
/// 
/// </summary>

public bool fn_isWriteableFileName (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isWriteableFileName'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_isWriteableFileName(sbfileName)>=1;
}
/// <summary>
/// ( int controllerID )
/// 				@brief Checks to see if an Xbox 360 controller is connected
/// 				@param controllerID Zero-based index of the controller to check.
///             @return 1 if the controller is connected, 0 if it isn't, and 205 if XInput 
///             hasn't been initialized.
/// 				@ingroup Input)
/// 
/// </summary>

public bool fn_isXInputConnected (int controllerID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_isXInputConnected'" + string.Format("\"{0}\" ",controllerID));

return  SafeNativeMethods.mwle_fn_isXInputConnected(controllerID)>=1;
}
/// <summary>
/// , ), 
/// 			  (string filename, [string languageName])
/// 			  @brief Adds a language to the table
/// 			  @param filename Name and path to the language file
/// 			  @param languageName Optional name to assign to the new language entry
/// 			  @return True If file was successfully found and language created
/// 			  )
/// 
/// </summary>

public int fn_LangTable_addLanguage (string langtable, string filename, string languageName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_addLanguage'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",langtable,filename,languageName));
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sblanguageName = null;
if (languageName != null)
     sblanguageName = new StringBuilder(languageName, 1024);

return  SafeNativeMethods.mwle_fn_LangTable_addLanguage(sblangtable, sbfilename, sblanguageName);
}
/// <summary>
/// ()
/// 			  @brief Get the ID of the current language table
/// 			  @return Numerical ID of the current language table)
/// 
/// </summary>

public int fn_LangTable_getCurrentLanguage (string langtable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_getCurrentLanguage'" + string.Format("\"{0}\" ",langtable));
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

return  SafeNativeMethods.mwle_fn_LangTable_getCurrentLanguage(sblangtable);
}
/// <summary>
/// (int language)
/// 			  @brief Return the readable name of the language table
/// 			  @param language Numerical ID of the language table to access
/// 			  @return String containing the name of the table, NULL if ID was invalid or name was never specified)
/// 
/// </summary>

public string fn_LangTable_getLangName (string langtable, int langId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_getLangName'" + string.Format("\"{0}\" \"{1}\" ",langtable,langId));
var returnbuff = new StringBuilder(16384);
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

SafeNativeMethods.mwle_fn_LangTable_getLangName(sblangtable, langId, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ()
/// 			  @brief Used to find out how many languages are in the table
/// 			  @return Size of the vector containing the languages, numerical)
/// 
/// </summary>

public int fn_LangTable_getNumLang (string langtable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_getNumLang'" + string.Format("\"{0}\" ",langtable));
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

return  SafeNativeMethods.mwle_fn_LangTable_getNumLang(sblangtable);
}
/// <summary>
/// (string filename)
/// 			  @brief Grabs a string from the specified table
/// 			  If an invalid is passed, the function will attempt to 
/// 			  to grab from the default table
/// 			  @param filename Name of the language table to access
/// 			  @return Text from the specified language table, \"\" if ID was invalid and default table is not set)
/// 
/// </summary>

public string fn_LangTable_getString (string langtable, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_getString'" + string.Format("\"{0}\" \"{1}\" ",langtable,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

SafeNativeMethods.mwle_fn_LangTable_getString(sblangtable, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (int language)
/// 			  @brief Sets the current language table for grabbing text
/// 			  @param language ID of the table)
/// 
/// </summary>

public void fn_LangTable_setCurrentLanguage (string langtable, int langId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_setCurrentLanguage'" + string.Format("\"{0}\" \"{1}\" ",langtable,langId));
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

SafeNativeMethods.mwle_fn_LangTable_setCurrentLanguage(sblangtable, langId);
}
/// <summary>
/// (int language)
/// 			  @brief Sets the default language table
/// 			  @param language ID of the table)
/// 
/// </summary>

public void fn_LangTable_setDefaultLanguage (string langtable, int langId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LangTable_setDefaultLanguage'" + string.Format("\"{0}\" \"{1}\" ",langtable,langId));
StringBuilder sblangtable = null;
if (langtable != null)
     sblangtable = new StringBuilder(langtable, 1024);

SafeNativeMethods.mwle_fn_LangTable_setDefaultLanguage(sblangtable, langId);
}
/// <summary>
/// Stops the light animation. )
/// 
/// </summary>

public void fn_LightBase_pauseAnimation (string lightbase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LightBase_pauseAnimation'" + string.Format("\"{0}\" ",lightbase));
StringBuilder sblightbase = null;
if (lightbase != null)
     sblightbase = new StringBuilder(lightbase, 1024);

SafeNativeMethods.mwle_fn_LightBase_pauseAnimation(sblightbase);
}
/// <summary>
/// ), ( [LightAnimData anim] )\t
///    Plays a light animation on the light.  If no LightAnimData is passed the 
///    existing one is played.
///    @hide)
/// 
/// </summary>

public void fn_LightBase_playAnimation (string lightbase, string anim)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_LightBase_playAnimation'" + string.Format("\"{0}\" \"{1}\" ",lightbase,anim));
StringBuilder sblightbase = null;
if (lightbase != null)
     sblightbase = new StringBuilder(lightbase, 1024);
StringBuilder sbanim = null;
if (anim != null)
     sbanim = new StringBuilder(anim, 1024);

SafeNativeMethods.mwle_fn_LightBase_playAnimation(sblightbase, sbanim);
}
/// <summary>
/// Will generate static lighting for the scene if supported by the active light manager.
///    If mode is \"forceAlways\", the lightmaps will be regenerated regardless of whether 
///    lighting cache files can be written to. If mode is \"forceWritable\", then the lightmaps 
///    will be regenerated only if the lighting cache files can be written.
///    @param completeCallbackFn The name of the function to execute when the lighting is complete.
///    @param mode One of \"forceAlways\",  \"forceWritable\" or \"loadOnly\".
///    @return Returns true if the scene lighting process was started.
///    @ingroup Lighting )
/// 
/// </summary>

public bool fn_lightScene (string completeCallbackFn, string mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_lightScene'" + string.Format("\"{0}\" \"{1}\" ",completeCallbackFn,mode));
StringBuilder sbcompleteCallbackFn = null;
if (completeCallbackFn != null)
     sbcompleteCallbackFn = new StringBuilder(completeCallbackFn, 1024);
StringBuilder sbmode = null;
if (mode != null)
     sbmode = new StringBuilder(mode, 1024);

return  SafeNativeMethods.mwle_fn_lightScene(sbcompleteCallbackFn, sbmode)>=1;
}
/// <summary>
/// Returns a list of the unflagged GFX resources. See flagCurrentGFXResources for usage details.
///    @ingroup GFX
///    @see flagCurrentGFXResources, clearGFXResourceFlags, describeGFXResources )
/// 
/// </summary>

public void fn_listGFXResources (bool unflaggedOnly)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_listGFXResources'" + string.Format("\"{0}\" ",unflaggedOnly));

SafeNativeMethods.mwle_fn_listGFXResources(unflaggedOnly);
}
/// <summary>
/// , ), 
///    (string filename, SimGroup parentGroup=MissionGroup, SimObject baseObject=-1)
///    Load all light instances from a COLLADA (.dae) file and add to the scene.
///    @param filename COLLADA filename to load lights from
///    @param parentGroup (optional) name of an existing simgroup to add the new 
///    lights to (defaults to MissionGroup)
///    @param baseObject (optional) name of an object to use as the origin (useful 
///    if you are loading the lights for a collada scene and have moved or rotated 
///    the geometry)
///    @return true if successful, false otherwise
///    @tsexample
///    // load the lights in room.dae
///    loadColladaLights( \"art/shapes/collada/room.dae\" );
///    // load the lights in room.dae and add them to the RoomLights group
///    loadColladaLights( \"art/shapes/collada/room.dae\", \"RoomLights\" );
///    // load the lights in room.dae and use the transform of the \"Room\"
///    object as the origin
///    loadColladaLights( \"art/shapes/collada/room.dae\", \"\", \"Room\" );
///    @endtsexample
///    @note Currently for editor use only
///    @ingroup Editors
///    @internal)
/// 
/// </summary>

public bool fn_loadColladaLights (string filename, string parentGroup, string baseObject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_loadColladaLights'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",filename,parentGroup,baseObject));
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbparentGroup = null;
if (parentGroup != null)
     sbparentGroup = new StringBuilder(parentGroup, 1024);
StringBuilder sbbaseObject = null;
if (baseObject != null)
     sbbaseObject = new StringBuilder(baseObject, 1024);

return  SafeNativeMethods.mwle_fn_loadColladaLights(sbfilename, sbparentGroup, sbbaseObject)>=1;
}
/// <summary>
/// @brief Loads a serialized object from a file.
/// 				@param Name and path to text file containing the object
/// 				@ingroup Console)
/// 
/// </summary>

public string fn_loadObject (string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_loadObject'" + string.Format("\"{0}\" ",filename));
var returnbuff = new StringBuilder(1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_loadObject(sbfilename, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (bool isLocked) 
///             @brief Lock or unlock the mouse to the window.
///             When true, prevents the mouse from leaving the bounds of the game window.
///             @ingroup Input)
/// 
/// </summary>

public void fn_lockMouse (bool isLocked)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_lockMouse'" + string.Format("\"{0}\" ",isLocked));

SafeNativeMethods.mwle_fn_lockMouse(isLocked);
}
/// <summary>
/// @brief Logs a message to the console.
///    @param message The message text.
///    @note By default, messages will appear white in the console.
///    @ingroup Logging)
/// 
/// </summary>

public void fn_log (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_log'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_log(sbmessage);
}
/// <summary>
/// @brief Logs an error message to the console.
///    @param message The message text.
///    @note By default, errors will appear red in the console.
///    @ingroup Logging)
/// 
/// </summary>

public void fn_logError (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_logError'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_logError(sbmessage);
}
/// <summary>
/// @brief Logs a warning message to the console.
///    @param message The message text.
///    @note By default, warnings will appear turquoise in the console.
///    @ingroup Logging)
/// 
/// </summary>

public void fn_logWarning (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_logWarning'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_logWarning(sbmessage);
}
/// <summary>
/// Remove leading whitespace from the string.
///    @param str A string.
///    @return A string that is the same as @a str but with any leading (i.e. leftmost) whitespace removed.
///    @tsexample
///    ltrim( \"   string  \" ); // Returns \"string  \".
///    @endtsexample
///    @see rtrim
///    @see trim
///    @ingroup Strings )
/// 
/// </summary>

public string fn_ltrim (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ltrim'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_ltrim(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the value of 2*PI (full-circle in radians).
///     @returns The value of 2*PI.
///     @ingroup Math )
/// 
/// </summary>

public float fn_m2Pi ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_m2Pi'");


return  SafeNativeMethods.mwle_fn_m2Pi();
}
/// <summary>
/// Calculate absolute value of specified value.
///     @param v Input Value.
///     @returns Absolute value of specified value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mAbs (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mAbs'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mAbs(v);
}
/// <summary>
/// Calculate the arc-cosine of v.
///     @param v Input Value (in radians).
///     @returns The arc-cosine of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mAcos (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mAcos'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mAcos(v);
}
/// <summary>
/// ),
/// 	@brief Converts a relative file path to a full path
/// 
/// 	For example, \"./console.log\" becomes \"C:/Torque/t3d/examples/FPS Example/game/console.log\"
/// 	@param path Name of file or path to check
///    @param cwd Optional current working directory from which to build the full path.
/// 	@return String containing non-relative directory of path
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_makeFullPath (string path, string cwd)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_makeFullPath'" + string.Format("\"{0}\" \"{1}\" ",path,cwd));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);
StringBuilder sbcwd = null;
if (cwd != null)
     sbcwd = new StringBuilder(cwd, 1024);

SafeNativeMethods.mwle_fn_makeFullPath(sbpath, sbcwd, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ),
/// 	@brief Turns a full or local path to a relative one
/// 
///    For example, \"./game/art\" becomes \"game/art\"
///    @param path Full path (may include a file) to convert
///    @param to Optional base path used for the conversion.  If not supplied the current 
///    working directory is used.
/// 	@returns String containing relative path
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_makeRelativePath (string path, string to)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_makeRelativePath'" + string.Format("\"{0}\" \"{1}\" ",path,to));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);
StringBuilder sbto = null;
if (to != null)
     sbto = new StringBuilder(to, 1024);

SafeNativeMethods.mwle_fn_makeRelativePath(sbpath, sbto, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Calculate the arc-sine of v.
///     @param v Input Value (in radians).
///     @returns The arc-sine of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mAsin (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mAsin'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mAsin(v);
}
/// <summary>
/// Calculate the arc-tangent (slope) of a line defined by rise and run.
///     @param rise of line.
///     @param run of line.
///     @returns The arc-tangent (slope) of a line defined by rise and run.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mAtan (float rise, float run)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mAtan'" + string.Format("\"{0}\" \"{1}\" ",rise,run));

return  SafeNativeMethods.mwle_fn_mAtan(rise, run);
}
/// <summary>
/// Dumps a formatted list of the currently allocated material instances for this material to the console. )
/// 
/// </summary>

public void fn_Material_dumpInstances (string material)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_dumpInstances'" + string.Format("\"{0}\" ",material));
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_dumpInstances(sbmaterial);
}
/// <summary>
/// Flushes all material instances that use this material. )
/// 
/// </summary>

public void fn_Material_flush (string material)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_flush'" + string.Format("\"{0}\" ",material));
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_flush(sbmaterial);
}
/// <summary>
///  )
/// 
/// </summary>

public string fn_Material_getAnimFlags (string material, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_getAnimFlags'" + string.Format("\"{0}\" \"{1}\" ",material,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_getAnimFlags(sbmaterial, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get filename of material)
/// 
/// </summary>

public string fn_Material_getFilename (string material)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_getFilename'" + string.Format("\"{0}\" ",material));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_getFilename(sbmaterial, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns true if this Material was automatically generated by MaterialList::mapMaterials() )
/// 
/// </summary>

public bool fn_Material_isAutoGenerated (string material)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_isAutoGenerated'" + string.Format("\"{0}\" ",material));
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

return  SafeNativeMethods.mwle_fn_Material_isAutoGenerated(sbmaterial)>=1;
}
/// <summary>
/// Reloads all material instances that use this material. )
/// 
/// </summary>

public void fn_Material_reload (string material)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_reload'" + string.Format("\"{0}\" ",material));
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_reload(sbmaterial);
}
/// <summary>
/// setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated. )
/// 
/// </summary>

public void fn_Material_setAutoGenerated (string material, bool isAutoGenerated)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Material_setAutoGenerated'" + string.Format("\"{0}\" \"{1}\" ",material,isAutoGenerated));
StringBuilder sbmaterial = null;
if (material != null)
     sbmaterial = new StringBuilder(material, 1024);

SafeNativeMethods.mwle_fn_Material_setAutoGenerated(sbmaterial, isAutoGenerated);
}
/// <summary>
/// Create a transform from the given translation and orientation.
///    @param position The translation vector for the transform.
///    @param orientation The axis and rotation that orients the transform.
///    @return A transform based on the given position and orientation.
///    @ingroup Matrices )
/// 
/// </summary>

public string fn_MatrixCreate (string position, string orientation)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MatrixCreate'" + string.Format("\"{0}\" \"{1}\" ",position,orientation));
var returnbuff = new StringBuilder(1024);
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);
StringBuilder sborientation = null;
if (orientation != null)
     sborientation = new StringBuilder(orientation, 1024);

SafeNativeMethods.mwle_fn_MatrixCreate(sbposition, sborientation, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @Create a matrix from the given rotations.
///    @param Vector3F X, Y, and Z rotation in *radians*.
///    @return A transform based on the given orientation.
///    @ingroup Matrices )
/// 
/// </summary>

public string fn_MatrixCreateFromEuler (string angles)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MatrixCreateFromEuler'" + string.Format("\"{0}\" ",angles));
var returnbuff = new StringBuilder(1024);
StringBuilder sbangles = null;
if (angles != null)
     sbangles = new StringBuilder(angles, 1024);

SafeNativeMethods.mwle_fn_MatrixCreateFromEuler(sbangles, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Multiply the given point by the given transform assuming that w=1.
///    This function will multiply the given vector such that translation with take effect.
///    @param transform A transform.
///    @param point A vector.
///    @return The transformed vector.
///    @ingroup Matrices)
/// 
/// </summary>

public string fn_MatrixMulPoint (string transform, string point)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MatrixMulPoint'" + string.Format("\"{0}\" \"{1}\" ",transform,point));
var returnbuff = new StringBuilder(1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbpoint = null;
if (point != null)
     sbpoint = new StringBuilder(point, 1024);

SafeNativeMethods.mwle_fn_MatrixMulPoint(sbtransform, sbpoint, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Multiply the two matrices.
///    @param left First transform.
///    @param right Right transform.
///    @return Concatenation of the two transforms.
///    @ingroup Matrices )
/// 
/// </summary>

public string fn_MatrixMultiply (string left, string right)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MatrixMultiply'" + string.Format("\"{0}\" \"{1}\" ",left,right));
var returnbuff = new StringBuilder(1024);
StringBuilder sbleft = null;
if (left != null)
     sbleft = new StringBuilder(left, 1024);
StringBuilder sbright = null;
if (right != null)
     sbright = new StringBuilder(right, 1024);

SafeNativeMethods.mwle_fn_MatrixMultiply(sbleft, sbright, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Multiply the vector by the transform assuming that w=0.
///    This function will multiply the given vector by the given transform such that translation will 
///    not affect the vector.
///    @param transform A transform.
///    @param vector A vector.
///    @return The transformed vector.
///    @ingroup Matrices)
/// 
/// </summary>

public string fn_MatrixMulVector (string transform, string vector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MatrixMulVector'" + string.Format("\"{0}\" \"{1}\" ",transform,vector));
var returnbuff = new StringBuilder(1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbvector = null;
if (vector != null)
     sbvector = new StringBuilder(vector, 1024);

SafeNativeMethods.mwle_fn_MatrixMulVector(sbtransform, sbvector, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Round v up to the nearest integer.
///     @param v Number to convert to integer.
///     @returns Number converted to integer.
///     @ingroup Math )
/// 
/// </summary>

public int fn_mCeil (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mCeil'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mCeil(v);
}
/// <summary>
/// Clamp the specified value between two bounds.
///     @param v Input value.
///     @param min Minimum Bound.
///     @param max Maximum Bound.
///     @returns The specified value clamped to the specified bounds.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mClamp (float v, float min, float max)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mClamp'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",v,min,max));

return  SafeNativeMethods.mwle_fn_mClamp(v, min, max);
}
/// <summary>
/// Calculate the cosine of v.
///     @param v Input Value (in radians).
///     @returns The cosine of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mCos (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mCos'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mCos(v);
}
/// <summary>
/// Convert specified degrees into radians.
///     @param degrees Input Value (in degrees).
///     @returns The specified degrees value converted to radians.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mDegToRad (float degrees)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mDegToRad'" + string.Format("\"{0}\" ",degrees));

return  SafeNativeMethods.mwle_fn_mDegToRad(degrees);
}
/// <summary>
/// ( SimObject obj ))
/// 
/// </summary>

public void fn_MECreateUndoAction_addObject (string mecreateundoaction, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MECreateUndoAction_addObject'" + string.Format("\"{0}\" \"{1}\" ",mecreateundoaction,obj));
StringBuilder sbmecreateundoaction = null;
if (mecreateundoaction != null)
     sbmecreateundoaction = new StringBuilder(mecreateundoaction, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fn_MECreateUndoAction_addObject(sbmecreateundoaction, sbobj);
}
/// <summary>
/// ( SimObject obj ))
/// 
/// </summary>

public void fn_MEDeleteUndoAction_deleteObject (string medeleteundoaction, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MEDeleteUndoAction_deleteObject'" + string.Format("\"{0}\" \"{1}\" ",medeleteundoaction,obj));
StringBuilder sbmedeleteundoaction = null;
if (medeleteundoaction != null)
     sbmedeleteundoaction = new StringBuilder(medeleteundoaction, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fn_MEDeleteUndoAction_deleteObject(sbmedeleteundoaction, sbobj);
}
/// <summary>
/// (GuiCanvas, pos))
/// 
/// </summary>

public void fn_MenuBar_attachToCanvas (string menubar, string canvas, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MenuBar_attachToCanvas'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",menubar,canvas,pos));
StringBuilder sbmenubar = null;
if (menubar != null)
     sbmenubar = new StringBuilder(menubar, 1024);
StringBuilder sbcanvas = null;
if (canvas != null)
     sbcanvas = new StringBuilder(canvas, 1024);

SafeNativeMethods.mwle_fn_MenuBar_attachToCanvas(sbmenubar, sbcanvas, pos);
}
/// <summary>
/// (object, pos) insert object at position)
/// 
/// </summary>

public void fn_MenuBar_insert (string menubar, string pObject, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MenuBar_insert'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",menubar,pObject,pos));
StringBuilder sbmenubar = null;
if (menubar != null)
     sbmenubar = new StringBuilder(menubar, 1024);
StringBuilder sbpObject = null;
if (pObject != null)
     sbpObject = new StringBuilder(pObject, 1024);

SafeNativeMethods.mwle_fn_MenuBar_insert(sbmenubar, sbpObject, pos);
}
/// <summary>
/// ())
/// 
/// </summary>

public void fn_MenuBar_removeFromCanvas (string menubar)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MenuBar_removeFromCanvas'" + string.Format("\"{0}\" ",menubar));
StringBuilder sbmenubar = null;
if (menubar != null)
     sbmenubar = new StringBuilder(menubar, 1024);

SafeNativeMethods.mwle_fn_MenuBar_removeFromCanvas(sbmenubar);
}
/// <summary>
/// () Increment the reference count for this message)
/// 
/// </summary>

public void fn_Message_addReference (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Message_addReference'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_Message_addReference(sbmessage);
}
/// <summary>
/// () Decrement the reference count for this message)
/// 
/// </summary>

public void fn_Message_freeReference (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Message_freeReference'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_Message_freeReference(sbmessage);
}
/// <summary>
/// () Get message type (script class name or C++ class name if no script defined class))
/// 
/// </summary>

public string fn_Message_getType (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Message_getType'" + string.Format("\"{0}\" ",message));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_Message_getType(sbmessage, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Display a modal message box using the platform's native message box implementation.
///    @param title The title to display on the message box window.
///    @param message The text message to display in the box.
///    @param buttons Which buttons to put on the message box.
///    @param icons Which icon to show next to the message.
///    @return One of $MROK, $MRCancel, $MRRetry, and $MRDontSave identifying the button that the user pressed.
///    @tsexample
///       messageBox( \"Error\", \"\" );    @endtsexample
///    @ingroup Platform )
/// 
/// </summary>

public int fn_messageBox (string title, string message, int buttons, int icons)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_messageBox'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",title,message,buttons,icons));
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

return  SafeNativeMethods.mwle_fn_messageBox(sbtitle, sbmessage, buttons, icons);
}
/// <summary>
/// ), (string filename, string header=NULL)
///               Dump the message vector to a file, optionally prefixing a header.
/// 			  @hide)
/// 
/// </summary>

public void fn_MessageVector_dump (string messagevector, string filename, string header)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_MessageVector_dump'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",messagevector,filename,header));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbheader = null;
if (header != null)
     sbheader = new StringBuilder(header, 1024);

SafeNativeMethods.mwle_fn_MessageVector_dump(sbmessagevector, sbfilename, sbheader);
}
/// <summary>
/// Formats the specified number to the given number of decimal places.
///     @param v Number to format.
///     @param precision Number of decimal places to format to (1-9).
///     @returns Number formatted to the specified number of decimal places.
///     @ingroup Math )
/// 
/// </summary>

public string fn_mFloatLength (float v, uint precision)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mFloatLength'" + string.Format("\"{0}\" \"{1}\" ",v,precision));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_mFloatLength(v, precision, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Round v down to the nearest integer.
///     @param v Number to convert to integer.
///     @returns Number converted to integer.
///     @ingroup Math )
/// 
/// </summary>

public int fn_mFloor (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mFloor'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mFloor(v);
}
/// <summary>
/// Calculate the remainder of v/d.
///     @param v Input Value.
///     @param d Divisor Value.
///     @returns The remainder of v/d.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mFMod (float v, float d)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mFMod'" + string.Format("\"{0}\" \"{1}\" ",v,d));

return  SafeNativeMethods.mwle_fn_mFMod(v, d);
}
/// <summary>
/// Returns whether the value is an exact power of two.
///     @param v Input value.
///     @returns Whether the specified value is an exact power of two.
///     @ingroup Math )
/// 
/// </summary>

public bool fn_mIsPow2 (int v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mIsPow2'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mIsPow2(v)>=1;
}
/// <summary>
/// Calculate linearly interpolated value between two specified numbers using specified normalized time.
///     @param v1 Interpolate From Input value.
///     @param v2 Interpolate To Input value.
///     @param time Normalized time used to interpolate values (0-1).
///     @returns The interpolated value between the two specified values at normalized time t.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mLerp (float v1, float v2, float time)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mLerp'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",v1,v2,time));

return  SafeNativeMethods.mwle_fn_mLerp(v1, v2, time);
}
/// <summary>
/// Calculate the natural logarithm of v.
///     @param v Input Value.
///     @returns The natural logarithm of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mLog (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mLog'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mLog(v);
}
/// <summary>
/// Return the value of PI (half-circle in radians).
///     @returns The value of PI.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mPi ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mPi'");


return  SafeNativeMethods.mwle_fn_mPi();
}
/// <summary>
/// Calculate b raised to the p-th power.
///     @param v Input Value.
///     @param p Power to raise value by.
///     @returns v raised to the p-th power.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mPow (float v, float p)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mPow'" + string.Format("\"{0}\" \"{1}\" ",v,p));

return  SafeNativeMethods.mwle_fn_mPow(v, p);
}
/// <summary>
/// Convert specified radians into degrees.
///     @param radians Input Value (in radians).
///     @returns The specified radians value converted to degrees.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mRadToDeg (float radians)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mRadToDeg'" + string.Format("\"{0}\" ",radians));

return  SafeNativeMethods.mwle_fn_mRadToDeg(radians);
}
/// <summary>
/// Round v to the nth decimal place or the nearest whole number by default.  
///     @param v Value to roundn  
///     @param n Number of decimal places to round to, 0 by defaultn  
///     @return The rounded value as a S32.  
///     @ingroup Math )  
/// 
/// </summary>

public float fn_mRound (float v, int n)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mRound'" + string.Format("\"{0}\" \"{1}\" ",v,n));

return  SafeNativeMethods.mwle_fn_mRound(v, n);
}
/// <summary>
/// Clamp the specified value between 0 and 1 (inclusive).
///     @param v Input value.
///     @returns The specified value clamped between 0 and 1 (inclusive).
///     @ingroup Math )
/// 
/// </summary>

public float fn_mSaturate (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSaturate'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mSaturate(v);
}
/// <summary>
/// Calculate the sine of v.
///     @param v Input Value (in radians).
///     @returns The sine of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mSin (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSin'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mSin(v);
}
/// <summary>
/// Solve a cubic equation (3rd degree polynomial) of form a*x^3 + b*x^2 + c*x + d = 0.
///     @param a First Coefficient.
///     @param b Second Coefficient.
///     @param c Third Coefficient.
///     @param d Fourth Coefficient.
///     @returns A 4-tuple, containing: (sol x0 x1 x2). (sol) is the number of solutions
///     (being 0, 1, 2 or 3), and (x0), (x1) and (x2) are the solutions, if any.
///     @ingroup Math )
/// 
/// </summary>

public string fn_mSolveCubic (float a, float b, float c, float d)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSolveCubic'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",a,b,c,d));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_mSolveCubic(a, b, c, d, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Solve a quadratic equation (2nd degree polynomial) of form a*x^2 + b*x + c = 0.
///     @param a First Coefficient.
///     @param b Second Coefficient.
///     @param c Third Coefficient.
///     @returns A triple, containing: (sol x0 x1). (sol) is the number of solutions
///     (being 0, 1, or 2), and (x0) and (x1) are the solutions, if any.
///     @ingroup Math )
/// 
/// </summary>

public string fn_mSolveQuadratic (float a, float b, float c)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSolveQuadratic'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",a,b,c));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_mSolveQuadratic(a, b, c, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Solve a quartic equation (4th degree polynomial) of form a*x^4 + b*x^3 + c*x^2 + d*x + e = 0.
///     @param a First Coefficient.
///     @param b Second Coefficient.
///     @param c Third Coefficient.
///     @param d Fourth Coefficient.
///     @param e Fifth Coefficient.
///     @returns A 5-tuple, containing: (sol x0 x1 x2 c3). (sol) is the number of solutions
///     (being 0, 1, 2, 3 or 4), and (x0), (x1), (x2) and (x3) are the solutions, if any.
///     @ingroup Math )
/// 
/// </summary>

public string fn_mSolveQuartic (float a, float b, float c, float d, float e)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSolveQuartic'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",a,b,c,d,e));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_mSolveQuartic(a, b, c, d, e, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Calculate the square-root of v.
///     @param v Input Value.
///     @returns The square-root of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mSqrt (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mSqrt'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mSqrt(v);
}
/// <summary>
/// Calculate the tangent of v.
///     @param v Input Value (in radians).
///     @returns The tangent of the input value.
///     @ingroup Math )
/// 
/// </summary>

public float fn_mTan (float v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_mTan'" + string.Format("\"{0}\" ",v));

return  SafeNativeMethods.mwle_fn_mTan(v);
}
/// <summary>
/// nameToID(object))
/// 
/// </summary>

public int fn_nameToID (string objectName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_nameToID'" + string.Format("\"{0}\" ",objectName));
StringBuilder sbobjectName = null;
if (objectName != null)
     sbobjectName = new StringBuilder(objectName, 1024);

return  SafeNativeMethods.mwle_fn_nameToID(sbobjectName);
}
/// <summary>
/// ( string str, string token, string delimiters ) 
///    Tokenize a string using a set of delimiting characters.
///    This function first skips all leading charaters in @a str that are contained in @a delimiters. 
///    From that position, it then scans for the next character in @a str that is contained in @a delimiters and stores all characters 
///    from the starting position up to the first delimiter in a variable in the current scope called @a token.  Finally, it 
///    skips all characters in @a delimiters after the token and then returns the remaining string contents in @a str.
///    To scan out all tokens in a string, call this function repeatedly by passing the result it returns each time as the new @a str 
///    until the function returns \"\".
///    @param str A string.
///    @param token The name of the variable in which to store the current token.  This variable is set in the 
///       scope in which nextToken is called.
///    @param delimiters A string of characters.  Each character is considered a delimiter.
///    @return The remainder of @a str after the token has been parsed out or \"\" if no more tokens were found in @a str.
///    @tsexample
///       // Prints:
///       // a
///       // b
///       // c
///       %str = \"a   b c\";
///       while ( %str !$= \"\" )
///       {
///          // First time, stores \"a\" in the variable %token and sets %str to \"b c\".
///          %str = nextToken( %str, \"token\", \" \" );
///          echo( %token );
///       }
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_nextToken (string str1, string token, string delim)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_nextToken'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str1,token,delim));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr1 = null;
if (str1 != null)
     sbstr1 = new StringBuilder(str1, 1024);
StringBuilder sbtoken = null;
if (token != null)
     sbtoken = new StringBuilder(token, 1024);
StringBuilder sbdelim = null;
if (delim != null)
     sbdelim = new StringBuilder(delim, 1024);

SafeNativeMethods.mwle_fn_nextToken(sbstr1, sbtoken, sbdelim, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Open the given @a file through the system.  This will usually open the file in its 
///    associated application.
///    @param file %Path of the file to open.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public void fn_openFile (string file)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_openFile'" + string.Format("\"{0}\" ",file));
StringBuilder sbfile = null;
if (file != null)
     sbfile = new StringBuilder(file, 1024);

SafeNativeMethods.mwle_fn_openFile(sbfile);
}
/// <summary>
/// @brief Open the given folder in the system's file manager.
///    @param path full path to a directory.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public void fn_openFolder (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_openFolder'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_openFolder(sbpath);
}
/// <summary>
/// @brief Combines two separate strings containing a file path and file name together into a single string
/// 
/// 	@param path String containing file path
/// 	@param file String containing file name
/// 	@return String containing concatenated file name and path
/// 	@ingroup FileSystem)
/// 
/// </summary>

public string fn_pathConcat (string path, string file)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_pathConcat'" + string.Format("\"{0}\" \"{1}\" ",path,file));
var returnbuff = new StringBuilder(1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);
StringBuilder sbfile = null;
if (file != null)
     sbfile = new StringBuilder(file, 1024);

SafeNativeMethods.mwle_fn_pathConcat(sbpath, sbfile, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Copy a file to a new location.
///    @param fromFile %Path of the file to copy.
///    @param toFile %Path where to copy @a fromFile to.
///    @param noOverwrite If true, then @a fromFile will not overwrite a file that may already exist at @a toFile.
///    @return True if the file was successfully copied, false otherwise.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public bool fn_pathCopy (string fromFile, string toFile, bool noOverwrite)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_pathCopy'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",fromFile,toFile,noOverwrite));
StringBuilder sbfromFile = null;
if (fromFile != null)
     sbfromFile = new StringBuilder(fromFile, 1024);
StringBuilder sbtoFile = null;
if (toFile != null)
     sbtoFile = new StringBuilder(toFile, 1024);

return  SafeNativeMethods.mwle_fn_pathCopy(sbfromFile, sbtoFile, noOverwrite)>=1;
}
/// <summary>
/// @brief Load all Path information from the mission.
/// 
///    This function is usually called from the loadMissionStage2() server-side function 
///    after the mission file has loaded.  Internally it places all Paths into the server's 
///    PathManager.  From this point the Paths are ready for transmission to the clients.
/// 
///    @tsexample
///       // Inform the engine to load all Path information from the mission.
///       pathOnMissionLoadDone();
///    @endtsexample
/// 
///    @see NetConnection::transmitPaths()
///    @see NetConnection::clearPaths()
///    @see Path
/// 
///    @ingroup Networking)
/// 
/// </summary>

public void fn_pathOnMissionLoadDone ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_pathOnMissionLoadDone'");


SafeNativeMethods.mwle_fn_pathOnMissionLoadDone();
}
/// <summary>
/// ()
///               Clears all the tracked objects without saving them. )
/// 
/// </summary>

public void fn_PersistenceManager_clearAll (string persistencemanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_clearAll'" + string.Format("\"{0}\" ",persistencemanager));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_clearAll(sbpersistencemanager);
}
/// <summary>
/// ( fileName )
///               Delete all of the objects that are created from the given file. )
/// 
/// </summary>

public void fn_PersistenceManager_deleteObjectsFromFile (string persistencemanager, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_deleteObjectsFromFile'" + string.Format("\"{0}\" \"{1}\" ",persistencemanager,fileName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_deleteObjectsFromFile(sbpersistencemanager, sbfileName);
}
/// <summary>
/// ( index )
///               Returns the ith dirty object. )
/// 
/// </summary>

public int fn_PersistenceManager_getDirtyObject (string persistencemanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_getDirtyObject'" + string.Format("\"{0}\" \"{1}\" ",persistencemanager,index));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_getDirtyObject(sbpersistencemanager, index);
}
/// <summary>
/// ()
///               Returns the number of dirty objects. )
/// 
/// </summary>

public int fn_PersistenceManager_getDirtyObjectCount (string persistencemanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_getDirtyObjectCount'" + string.Format("\"{0}\" ",persistencemanager));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_getDirtyObjectCount(sbpersistencemanager);
}
/// <summary>
/// ()
///               Returns true if the manager has dirty objects to save. )
/// 
/// </summary>

public bool fn_PersistenceManager_hasDirty (string persistencemanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_hasDirty'" + string.Format("\"{0}\" ",persistencemanager));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_hasDirty(sbpersistencemanager)>=1;
}
/// <summary>
/// (SimObject object)
///               Returns true if the SimObject is on the dirty list.)
/// 
/// </summary>

public bool fn_PersistenceManager_isDirty (string persistencemanager, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_isDirty'" + string.Format("\"{0}\" \"{1}\" ",persistencemanager,objName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_isDirty(sbpersistencemanager, sbobjName)>=1;
}
/// <summary>
/// ()
///               Prints the dirty list to the console.)
/// 
/// </summary>

public void fn_PersistenceManager_listDirty (string persistencemanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_listDirty'" + string.Format("\"{0}\" ",persistencemanager));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_listDirty(sbpersistencemanager);
}
/// <summary>
/// (SimObject object)
///               Remove a SimObject from the dirty list.)
/// 
/// </summary>

public void fn_PersistenceManager_removeDirty (string persistencemanager, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_removeDirty'" + string.Format("\"{0}\" \"{1}\" ",persistencemanager,objName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_removeDirty(sbpersistencemanager, sbobjName);
}
/// <summary>
/// (SimObject object, string fieldName)
///               Remove a specific field from an object declaration.)
/// 
/// </summary>

public void fn_PersistenceManager_removeField (string persistencemanager, string objName, string fieldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_removeField'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",persistencemanager,objName,fieldName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_removeField(sbpersistencemanager, sbobjName, sbfieldName);
}
/// <summary>
/// ) , (SimObject object, [filename])
///               Remove an existing SimObject from a file (can optionally specify a different file than \
///                the one it was created in.)
/// 
/// </summary>

public void fn_PersistenceManager_removeObjectFromFile (string persistencemanager, string objName, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_removeObjectFromFile'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",persistencemanager,objName,filename));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_removeObjectFromFile(sbpersistencemanager, sbobjName, sbfilename);
}
/// <summary>
/// ()
///               Saves all of the SimObject's on the dirty list to their respective files.)
/// 
/// </summary>

public bool fn_PersistenceManager_saveDirty (string persistencemanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_saveDirty'" + string.Format("\"{0}\" ",persistencemanager));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_saveDirty(sbpersistencemanager)>=1;
}
/// <summary>
/// (SimObject object)
///               Save a dirty SimObject to it's file.)
/// 
/// </summary>

public bool fn_PersistenceManager_saveDirtyObject (string persistencemanager, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_saveDirtyObject'" + string.Format("\"{0}\" \"{1}\" ",persistencemanager,objName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

return  SafeNativeMethods.mwle_fn_PersistenceManager_saveDirtyObject(sbpersistencemanager, sbobjName)>=1;
}
/// <summary>
/// ), (SimObject object, [filename])
///               Mark an existing SimObject as dirty (will be written out when saveDirty() is called).)
/// 
/// </summary>

public void fn_PersistenceManager_setDirty (string persistencemanager, string objName, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PersistenceManager_setDirty'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",persistencemanager,objName,fileName));
StringBuilder sbpersistencemanager = null;
if (persistencemanager != null)
     sbpersistencemanager = new StringBuilder(persistencemanager, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_PersistenceManager_setDirty(sbpersistencemanager, sbobjName, sbfileName);
}
/// <summary>
/// @brief Loads some information to have readily available at simulation time.
///    Forces generation of shaders, materials, and other data used by the %PhysicsDebris object. 
///    This function should be used while a level is loading in order to shorten 
///    the amount of time to create a PhysicsDebris in game.)
/// 
/// </summary>

public void fn_PhysicsDebrisData_preload (string physicsdebrisdata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PhysicsDebrisData_preload'" + string.Format("\"{0}\" ",physicsdebrisdata));
StringBuilder sbphysicsdebrisdata = null;
if (physicsdebrisdata != null)
     sbphysicsdebrisdata = new StringBuilder(physicsdebrisdata, 1024);

SafeNativeMethods.mwle_fn_PhysicsDebrisData_preload(sbphysicsdebrisdata);
}
/// <summary>
/// physicsDebugDraw( bool enable ))
/// 
/// </summary>

public void fn_physicsDebugDraw (bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsDebugDraw'" + string.Format("\"{0}\" ",enable));

SafeNativeMethods.mwle_fn_physicsDebugDraw(enable);
}
/// <summary>
/// physicsDestroy())
/// 
/// </summary>

public void fn_physicsDestroy ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsDestroy'");


SafeNativeMethods.mwle_fn_physicsDestroy();
}
/// <summary>
/// physicsDestroyWorld( String worldName ))
/// 
/// </summary>

public void fn_physicsDestroyWorld (string worldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsDestroyWorld'" + string.Format("\"{0}\" ",worldName));
StringBuilder sbworldName = null;
if (worldName != null)
     sbworldName = new StringBuilder(worldName, 1024);

SafeNativeMethods.mwle_fn_physicsDestroyWorld(sbworldName);
}
/// <summary>
/// physicsGetTimeScale())
/// 
/// </summary>

public float fn_physicsGetTimeScale ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsGetTimeScale'");


return  SafeNativeMethods.mwle_fn_physicsGetTimeScale();
}
/// <summary>
/// ), physicsInit( [string library] ))
/// 
/// </summary>

public bool fn_physicsInit (string library)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsInit'" + string.Format("\"{0}\" ",library));
StringBuilder sblibrary = null;
if (library != null)
     sblibrary = new StringBuilder(library, 1024);

return  SafeNativeMethods.mwle_fn_physicsInit(sblibrary)>=1;
}
/// <summary>
/// physicsInitWorld( String worldName ))
/// 
/// </summary>

public bool fn_physicsInitWorld (string worldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsInitWorld'" + string.Format("\"{0}\" ",worldName));
StringBuilder sbworldName = null;
if (worldName != null)
     sbworldName = new StringBuilder(worldName, 1024);

return  SafeNativeMethods.mwle_fn_physicsInitWorld(sbworldName)>=1;
}
/// <summary>
/// physicsPluginPresent()
///    @brief Returns true if a physics plugin exists and is initialized.
///    @ingroup Physics )
/// 
/// </summary>

public bool fn_physicsPluginPresent ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsPluginPresent'");


return  SafeNativeMethods.mwle_fn_physicsPluginPresent()>=1;
}
/// <summary>
/// physicsRestoreState())
/// 
/// </summary>

public void fn_physicsRestoreState ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsRestoreState'");


SafeNativeMethods.mwle_fn_physicsRestoreState();
}
/// <summary>
/// physicsSetTimeScale( F32 scale ))
/// 
/// </summary>

public void fn_physicsSetTimeScale (float scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsSetTimeScale'" + string.Format("\"{0}\" ",scale));

SafeNativeMethods.mwle_fn_physicsSetTimeScale(scale);
}
/// <summary>
/// physicsStopSimulation( String worldName ))
/// 
/// </summary>

public bool fn_physicsSimulationEnabled ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsSimulationEnabled'");


return  SafeNativeMethods.mwle_fn_physicsSimulationEnabled()>=1;
}
/// <summary>
/// physicsStartSimulation( String worldName ))
/// 
/// </summary>

public void fn_physicsStartSimulation (string worldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsStartSimulation'" + string.Format("\"{0}\" ",worldName));
StringBuilder sbworldName = null;
if (worldName != null)
     sbworldName = new StringBuilder(worldName, 1024);

SafeNativeMethods.mwle_fn_physicsStartSimulation(sbworldName);
}
/// <summary>
/// physicsStopSimulation( String worldName ))
/// 
/// </summary>

public void fn_physicsStopSimulation (string worldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsStopSimulation'" + string.Format("\"{0}\" ",worldName));
StringBuilder sbworldName = null;
if (worldName != null)
     sbworldName = new StringBuilder(worldName, 1024);

SafeNativeMethods.mwle_fn_physicsStopSimulation(sbworldName);
}
/// <summary>
/// physicsStoreState())
/// 
/// </summary>

public void fn_physicsStoreState ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_physicsStoreState'");


SafeNativeMethods.mwle_fn_physicsStoreState();
}
/// <summary>
/// (string filename) 
///                 @brief Begin playback of a journal from a specified field.
/// 				@param filename Name and path of file journal file
/// 				@ingroup Platform)
/// 
/// </summary>

public void fn_playJournal (string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_playJournal'" + string.Format("\"{0}\" ",filename));
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_playJournal(sbfilename);
}
/// <summary>
/// THEORA, 30.0f, Point2I::Zero ),
///    Load a journal file and capture it video.
///    @ingroup Rendering )
/// 
/// </summary>

public void fn_playJournalToVideo (string journalFile, string videoFile, string encoder, float framerate, string resolution)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_playJournalToVideo'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",journalFile,videoFile,encoder,framerate,resolution));
StringBuilder sbjournalFile = null;
if (journalFile != null)
     sbjournalFile = new StringBuilder(journalFile, 1024);
StringBuilder sbvideoFile = null;
if (videoFile != null)
     sbvideoFile = new StringBuilder(videoFile, 1024);
StringBuilder sbencoder = null;
if (encoder != null)
     sbencoder = new StringBuilder(encoder, 1024);
StringBuilder sbresolution = null;
if (resolution != null)
     sbresolution = new StringBuilder(resolution, 1024);

SafeNativeMethods.mwle_fn_playJournalToVideo(sbjournalFile, sbvideoFile, sbencoder, framerate, sbresolution);
}
/// <summary>
/// () 
/// 				@brief Pop and restore the last setting of $instantGroup off the stack.
/// 				@note Currently only used for editors
/// 				@ingroup Editors
/// 				@internal)
/// 
/// </summary>

public void fn_popInstantGroup ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_popInstantGroup'");


SafeNativeMethods.mwle_fn_popInstantGroup();
}
/// <summary>
/// Populate the font cache for all fonts with Unicode code points in the specified range.
///    @param rangeStart The start Unicode point.
///    @param rangeEnd The end Unicode point.
///    @note We only support BMP-0, so code points range from 0 to 65535.
///    @ingroup Font )
/// 
/// </summary>

public void fn_populateAllFontCacheRange (uint rangeStart, uint rangeEnd)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_populateAllFontCacheRange'" + string.Format("\"{0}\" \"{1}\" ",rangeStart,rangeEnd));

SafeNativeMethods.mwle_fn_populateAllFontCacheRange(rangeStart, rangeEnd);
}
/// <summary>
/// Populate the font cache for all fonts with characters from the specified string.
///    @ingroup Font )
/// 
/// </summary>

public void fn_populateAllFontCacheString (string stringx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_populateAllFontCacheString'" + string.Format("\"{0}\" ",stringx));
StringBuilder sbstringx = null;
if (stringx != null)
     sbstringx = new StringBuilder(stringx, 1024);

SafeNativeMethods.mwle_fn_populateAllFontCacheString(sbstringx);
}
/// <summary>
/// Populate the font cache for the specified font with Unicode code points in the specified range.
///    @param faceName The name of the font face.
///    @param fontSize The size of the font in pixels.
///    @param rangeStart The start Unicode point.
///    @param rangeEnd The end Unicode point.
///    @note We only support BMP-0, so code points range from 0 to 65535.
///    @ingroup Font )
/// 
/// </summary>

public void fn_populateFontCacheRange (string faceName, int fontSize, uint rangeStart, uint rangeEnd)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_populateFontCacheRange'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",faceName,fontSize,rangeStart,rangeEnd));
StringBuilder sbfaceName = null;
if (faceName != null)
     sbfaceName = new StringBuilder(faceName, 1024);

SafeNativeMethods.mwle_fn_populateFontCacheRange(sbfaceName, fontSize, rangeStart, rangeEnd);
}
/// <summary>
/// Populate the font cache for the specified font with characters from the specified string.
///     @param faceName The name of the font face.
///     @param fontSize The size of the font in pixels.
///     @param string The string to populate.
///     @ingroup Font )
/// 
/// </summary>

public void fn_populateFontCacheString (string faceName, int fontSize, string stringx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_populateFontCacheString'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",faceName,fontSize,stringx));
StringBuilder sbfaceName = null;
if (faceName != null)
     sbfaceName = new StringBuilder(faceName, 1024);
StringBuilder sbstringx = null;
if (stringx != null)
     sbstringx = new StringBuilder(stringx, 1024);

SafeNativeMethods.mwle_fn_populateFontCacheString(sbfaceName, fontSize, sbstringx);
}
/// <summary>
/// (GuiCanvas, pos, title))
/// 
/// </summary>

public void fn_PopupMenu_attachToMenuBar (string popupmenu, string canvasName, int pos, string title)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_attachToMenuBar'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,canvasName,pos,title));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);
StringBuilder sbcanvasName = null;
if (canvasName != null)
     sbcanvasName = new StringBuilder(canvasName, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_attachToMenuBar(sbpopupmenu, sbcanvasName, pos, sbtitle);
}
/// <summary>
/// (pos, checked))
/// 
/// </summary>

public void fn_PopupMenu_checkItem (string popupmenu, int pos, bool checkedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_checkItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",popupmenu,pos,checkedx));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_checkItem(sbpopupmenu, pos, checkedx);
}
/// <summary>
/// (firstPos, lastPos, checkPos))
/// 
/// </summary>

public void fn_PopupMenu_checkRadioItem (string popupmenu, int firstPos, int lastPos, int checkPos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_checkRadioItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,firstPos,lastPos,checkPos));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_checkRadioItem(sbpopupmenu, firstPos, lastPos, checkPos);
}
/// <summary>
/// (pos, enabled))
/// 
/// </summary>

public void fn_PopupMenu_enableItem (string popupmenu, int pos, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_enableItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",popupmenu,pos,enabled));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_enableItem(sbpopupmenu, pos, enabled);
}
/// <summary>
/// ())
/// 
/// </summary>

public int fn_PopupMenu_getItemCount (string popupmenu)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_getItemCount'" + string.Format("\"{0}\" ",popupmenu));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

return  SafeNativeMethods.mwle_fn_PopupMenu_getItemCount(sbpopupmenu);
}
/// <summary>
/// , ), (pos[, title][, accelerator]))
/// 
/// </summary>

public int fn_PopupMenu_insertItem (string popupmenu, int pos, string title, string accelerator)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_insertItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,pos,title,accelerator));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);
StringBuilder sbaccelerator = null;
if (accelerator != null)
     sbaccelerator = new StringBuilder(accelerator, 1024);

return  SafeNativeMethods.mwle_fn_PopupMenu_insertItem(sbpopupmenu, pos, sbtitle, sbaccelerator);
}
/// <summary>
/// (pos, title, subMenu))
/// 
/// </summary>

public int fn_PopupMenu_insertSubMenu (string popupmenu, int pos, string title, string subMenu)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_insertSubMenu'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,pos,title,subMenu));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);
StringBuilder sbsubMenu = null;
if (subMenu != null)
     sbsubMenu = new StringBuilder(subMenu, 1024);

return  SafeNativeMethods.mwle_fn_PopupMenu_insertSubMenu(sbpopupmenu, pos, sbtitle, sbsubMenu);
}
/// <summary>
/// (pos))
/// 
/// </summary>

public bool fn_PopupMenu_isItemChecked (string popupmenu, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_isItemChecked'" + string.Format("\"{0}\" \"{1}\" ",popupmenu,pos));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

return  SafeNativeMethods.mwle_fn_PopupMenu_isItemChecked(sbpopupmenu, pos)>=1;
}
/// <summary>
/// ())
/// 
/// </summary>

public void fn_PopupMenu_removeFromMenuBar (string popupmenu)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_removeFromMenuBar'" + string.Format("\"{0}\" ",popupmenu));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_removeFromMenuBar(sbpopupmenu);
}
/// <summary>
/// (pos))
/// 
/// </summary>

public void fn_PopupMenu_removeItem (string popupmenu, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_removeItem'" + string.Format("\"{0}\" \"{1}\" ",popupmenu,pos));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_removeItem(sbpopupmenu, pos);
}
/// <summary>
/// ), (pos, title[, accelerator]))
/// 
/// </summary>

public bool fn_PopupMenu_setItem (string popupmenu, int pos, string title, string accelerator)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_setItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,pos,title,accelerator));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);
StringBuilder sbaccelerator = null;
if (accelerator != null)
     sbaccelerator = new StringBuilder(accelerator, 1024);

return  SafeNativeMethods.mwle_fn_PopupMenu_setItem(sbpopupmenu, pos, sbtitle, sbaccelerator)>=1;
}
/// <summary>
/// (Canvas,[x, y]))
/// 
/// </summary>

public void fn_PopupMenu_showPopup (string popupmenu, string canvasName, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_PopupMenu_showPopup'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",popupmenu,canvasName,x,y));
StringBuilder sbpopupmenu = null;
if (popupmenu != null)
     sbpopupmenu = new StringBuilder(popupmenu, 1024);
StringBuilder sbcanvasName = null;
if (canvasName != null)
     sbcanvasName = new StringBuilder(canvasName, 1024);

SafeNativeMethods.mwle_fn_PopupMenu_showPopup(sbpopupmenu, sbcanvasName, x, y);
}
/// <summary>
/// Preload all datablocks in client mode.
///    (Server parameter is set to false).  This will take some time to complete.)
/// 
/// </summary>

public void fn_preloadClientDataBlocks ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_preloadClientDataBlocks'");


SafeNativeMethods.mwle_fn_preloadClientDataBlocks();
}
/// <summary>
/// @brief Dumps current profiling stats to the console window.
/// 				@note Markers disabled with profilerMarkerEnable() will be skipped over. 
/// 				If the profiler is currently running, it will be disabled.
/// 				@ingroup Debugging)
/// 
/// </summary>

public void fn_profilerDump ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_profilerDump'");


SafeNativeMethods.mwle_fn_profilerDump();
}
/// <summary>
/// @brief Dumps current profiling stats to a file.
/// 				@note If the profiler is currently running, it will be disabled.
/// 				@param fileName Name and path of file to save profiling stats to. Must use forward slashes (/). 
/// 				Will attempt to create the file if it does not already exist.
/// 				@tsexample
/// 				profilerDumpToFile( \"C:/Torque/log1.txt\" );
/// 				@endtsexample
/// 				@ingroup Debugging )
/// 
/// </summary>

public void fn_profilerDumpToFile (string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_profilerDumpToFile'" + string.Format("\"{0}\" ",fileName));
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_profilerDumpToFile(sbfileName);
}
/// <summary>
/// @brief Enables or disables the profiler.
/// 				Data is only gathered while the profiler is enabled.
/// 				@note Profiler is not available in shipping builds.
/// 				T3D has predefined profiling areas surrounded by markers, 
/// 				but you may need to define additional markers (in C++) around areas you wish to profile,
/// 				 by using the PROFILE_START( markerName ); and PROFILE_END(); macros.
/// 				@ingroup Debugging )
/// 
/// </summary>

public void fn_profilerEnable (bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_profilerEnable'" + string.Format("\"{0}\" ",enable));

SafeNativeMethods.mwle_fn_profilerEnable(enable);
}
/// <summary>
/// @brief Enable or disable a specific profile.
///    @param enable     Optional paramater to enable or disable the profile.
///    @param markerName Name of a specific marker to enable or disable.
///    @note Calling this function will first call profilerReset(), clearing all data from profiler. 
///    All profile markers are enabled by default.
///    @ingroup Debugging)
/// 
/// </summary>

public void fn_profilerMarkerEnable (string markerName, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_profilerMarkerEnable'" + string.Format("\"{0}\" \"{1}\" ",markerName,enable));
StringBuilder sbmarkerName = null;
if (markerName != null)
     sbmarkerName = new StringBuilder(markerName, 1024);

SafeNativeMethods.mwle_fn_profilerMarkerEnable(sbmarkerName, enable);
}
/// <summary>
/// @brief Resets the profiler, clearing it of all its data.
/// 				If the profiler is currently running, it will first be disabled. 
/// 				All markers will retain their current enabled/disabled status.
/// 				@ingroup Debugging )
/// 
/// </summary>

public void fn_profilerReset ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_profilerReset'");


SafeNativeMethods.mwle_fn_profilerReset();
}
/// <summary>
/// ) , ([group]) 
/// 				@brief Pushes the current $instantGroup on a stack 
/// 				and sets it to the given value (or clears it).
/// 				@note Currently only used for editors
/// 				@ingroup Editors
/// 				@internal)
/// 
/// </summary>

public void fn_pushInstantGroup (string group)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_pushInstantGroup'" + string.Format("\"{0}\" ",group));
StringBuilder sbgroup = null;
if (group != null)
     sbgroup = new StringBuilder(group, 1024);

SafeNativeMethods.mwle_fn_pushInstantGroup(sbgroup);
}
/// <summary>
/// queryAllServers(...); )
/// 
/// </summary>

public void fn_queryAllServers (uint lanPort, uint flags, string gameType, string missionType, uint minPlayers, uint maxPlayers, uint maxBots, uint regionMask, uint maxPing, uint minCPU, uint filterFlags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_queryAllServers'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" ",lanPort,flags,gameType,missionType,minPlayers,maxPlayers,maxBots,regionMask,maxPing,minCPU,filterFlags));
StringBuilder sbgameType = null;
if (gameType != null)
     sbgameType = new StringBuilder(gameType, 1024);
StringBuilder sbmissionType = null;
if (missionType != null)
     sbmissionType = new StringBuilder(missionType, 1024);

SafeNativeMethods.mwle_fn_queryAllServers(lanPort, flags, sbgameType, sbmissionType, minPlayers, maxPlayers, maxBots, regionMask, maxPing, minCPU, filterFlags);
}
/// <summary>
/// queryLanServers(...); )
/// 
/// 
/// </summary>

public void fn_queryLanServers (uint lanPort, uint flags, string gameType, string missionType, uint minPlayers, uint maxPlayers, uint maxBots, uint regionMask, uint maxPing, uint minCPU, uint filterFlags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_queryLanServers'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" ",lanPort,flags,gameType,missionType,minPlayers,maxPlayers,maxBots,regionMask,maxPing,minCPU,filterFlags));
StringBuilder sbgameType = null;
if (gameType != null)
     sbgameType = new StringBuilder(gameType, 1024);
StringBuilder sbmissionType = null;
if (missionType != null)
     sbmissionType = new StringBuilder(missionType, 1024);

SafeNativeMethods.mwle_fn_queryLanServers(lanPort, flags, sbgameType, sbmissionType, minPlayers, maxPlayers, maxBots, regionMask, maxPing, minCPU, filterFlags);
}
/// <summary>
/// queryMasterServer(...); )
/// 
/// </summary>

public void fn_queryMasterServer (uint lanPort, uint flags, string gameType, string missionType, uint minPlayers, uint maxPlayers, uint maxBots, uint regionMask, uint maxPing, uint minCPU, uint filterFlags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_queryMasterServer'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" ",lanPort,flags,gameType,missionType,minPlayers,maxPlayers,maxBots,regionMask,maxPing,minCPU,filterFlags));
StringBuilder sbgameType = null;
if (gameType != null)
     sbgameType = new StringBuilder(gameType, 1024);
StringBuilder sbmissionType = null;
if (missionType != null)
     sbmissionType = new StringBuilder(missionType, 1024);

SafeNativeMethods.mwle_fn_queryMasterServer(lanPort, flags, sbgameType, sbmissionType, minPlayers, maxPlayers, maxBots, regionMask, maxPing, minCPU, filterFlags);
}
/// <summary>
/// querySingleServer(...); )
/// 
/// </summary>

public void fn_querySingleServer (string addrText, byte flags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_querySingleServer'" + string.Format("\"{0}\" \"{1}\" ",addrText,flags));
StringBuilder sbaddrText = null;
if (addrText != null)
     sbaddrText = new StringBuilder(addrText, 1024);

SafeNativeMethods.mwle_fn_querySingleServer(sbaddrText, flags);
}
/// <summary>
/// Shut down the engine and exit its process.
///    This function cleanly uninitializes the engine and then exits back to the system with a process 
///    exit status indicating a clean exit.
///    @see quitWithErrorMessage
///    @ingroup Platform )
/// 
/// </summary>

public void fn_quit ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_quit'");


SafeNativeMethods.mwle_fn_quit();
}
/// <summary>
/// Display an error message box showing the given @a message and then shut down the engine and exit its process.
///    This function cleanly uninitialized the engine and then exits back to the system with a process 
///    exit status indicating an error.
///    @param message The message to log to the console and show in an error message box.
///    @see quit
///    @ingroup Platform )
/// 
/// </summary>

public void fn_quitWithErrorMessage (string message)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_quitWithErrorMessage'" + string.Format("\"{0}\" ",message));
StringBuilder sbmessage = null;
if (message != null)
     sbmessage = new StringBuilder(message, 1024);

SafeNativeMethods.mwle_fn_quitWithErrorMessage(sbmessage);
}
/// <summary>
/// readXMLObj.readFile();)
/// 
/// </summary>

public bool fn_ReadXML_readFile (string readxml)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_ReadXML_readFile'" + string.Format("\"{0}\" ",readxml));
StringBuilder sbreadxml = null;
if (readxml != null)
     sbreadxml = new StringBuilder(readxml, 1024);

return  SafeNativeMethods.mwle_fn_ReadXML_readFile(sbreadxml)>=1;
}

public void fn_realQuit ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_realQuit'");


SafeNativeMethods.mwle_fn_realQuit();
}
/// <summary>
/// Close the current Redbook device.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public bool fn_redbookClose ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookClose'");


return  SafeNativeMethods.mwle_fn_redbookClose()>=1;
}
/// <summary>
/// get the number of redbook devices.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public int fn_redbookGetDeviceCount ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookGetDeviceCount'");


return  SafeNativeMethods.mwle_fn_redbookGetDeviceCount();
}
/// <summary>
/// (int index) Get name of specified Redbook device.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public string fn_redbookGetDeviceName (int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookGetDeviceName'" + string.Format("\"{0}\" ",index));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_redbookGetDeviceName(index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get a string explaining the last redbook error.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public string fn_redbookGetLastError ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookGetLastError'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_redbookGetLastError(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the number of tracks.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public int fn_redbookGetTrackCount ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookGetTrackCount'");


return  SafeNativeMethods.mwle_fn_redbookGetTrackCount();
}
/// <summary>
/// Get the volume.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public float fn_redbookGetVolume ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookGetVolume'");


return  SafeNativeMethods.mwle_fn_redbookGetVolume();
}
/// <summary>
/// ), (string device=NULL)
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public bool fn_redbookOpen (string device)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookOpen'" + string.Format("\"{0}\" ",device));
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);

return  SafeNativeMethods.mwle_fn_redbookOpen(sbdevice)>=1;
}
/// <summary>
/// (int track) Play the selected track.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public bool fn_redbookPlay (int track)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookPlay'" + string.Format("\"{0}\" ",track));

return  SafeNativeMethods.mwle_fn_redbookPlay(track)>=1;
}
/// <summary>
/// (float volume) Set playback volume.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public bool fn_redbookSetVolume (float volume)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookSetVolume'" + string.Format("\"{0}\" ",volume));

return  SafeNativeMethods.mwle_fn_redbookSetVolume(volume)>=1;
}
/// <summary>
/// Stop playing.
/// 				@brief Deprecated
/// 				@internal)
/// 
/// </summary>

public bool fn_redbookStop ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_redbookStop'");


return  SafeNativeMethods.mwle_fn_redbookStop()>=1;
}
/// <summary>
/// (string queueName, string listener)
/// 				@brief Registers an event message
/// 				@param queueName String containing the name of queue to attach listener to
/// 				@param listener Name of event messenger
/// 				@ingroup Messaging)
/// 
/// </summary>

public bool fn_registerMessageListener (string queueName, string listenerName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_registerMessageListener'" + string.Format("\"{0}\" \"{1}\" ",queueName,listenerName));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);

return  SafeNativeMethods.mwle_fn_registerMessageListener(sbqueueName, sblistenerName)>=1;
}
/// <summary>
/// (string queueName)
/// 				@brief Registeres a dispatcher queue
/// 				@param queueName String containing the name of queue
/// 				@ingroup Messaging)
/// 
/// </summary>

public void fn_registerMessageQueue (string queueName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_registerMessageQueue'" + string.Format("\"{0}\" ",queueName));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);

SafeNativeMethods.mwle_fn_registerMessageQueue(sbqueueName);
}
/// <summary>
/// @brief Flushes all procedural shaders and re-initializes all active material instances. 
///    @ingroup Materials)
/// 
/// </summary>

public void fn_reInitMaterials ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_reInitMaterials'");


SafeNativeMethods.mwle_fn_reInitMaterials();
}
/// <summary>
/// Force the resource at specified input path to be reloaded
///    @param path Path to the resource to be reloaded
///    @tsexample
///    reloadResource( \"art/shapes/box.dts\" );
///    @endtsexample
///    @note Currently used by editors only
///    @ingroup Editors
///    @internal)
/// 
/// </summary>

public void fn_reloadResource (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_reloadResource'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_reloadResource(sbpath);
}
/// <summary>
/// Reload all the textures from disk.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_reloadTextures ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_reloadTextures'");


SafeNativeMethods.mwle_fn_reloadTextures();
}
/// <summary>
/// Remove the field in @a text at the given @a index.
///    Fields in @a text must be separated by newlines and/or tabs.
///    @param text A list of fields separated by newlines and/or tabs.
///    @param index The zero-based index of the field in @a text.
///    @return A new string with the field at the given index removed or the original string if @a index is 
///       out of range.
///    @tsexample
///       removeField( \"a b\" TAB \"c d\" TAB \"e f\", 1 ) // Returns \"a b\" TAB \"e f\"
///    @endtsexample
///    @see removeWord
///    @see removeRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_removeField (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_removeField'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_removeField(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Removes an existing global macro by name.
///    @see addGlobalShaderMacro
///    @ingroup Rendering )
/// 
/// </summary>

public void fn_removeGlobalShaderMacro (string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_removeGlobalShaderMacro'" + string.Format("\"{0}\" ",name));
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_removeGlobalShaderMacro(sbname);
}
/// <summary>
/// Remove the record in @a text at the given @a index.
///    Records in @a text must be separated by newlines.
///    @param text A list of records separated by newlines.
///    @param index The zero-based index of the record in @a text.
///    @return A new string with the record at the given @a index removed or the original string if @a index is 
///       out of range.
///    @tsexample
///       removeRecord( \"a b\" NL \"c d\" NL \"e f\", 1 ) // Returns \"a b\" NL \"e f\"
///    @endtsexample
///    @see removeWord
///    @see removeField
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_removeRecord (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_removeRecord'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_removeRecord(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Remove a tagged string from the Net String Table
/// 
///    @param tag The tag associated with the string
/// 
///    @see \\ref syntaxDataTypes under Tagged %Strings
///    @see addTaggedString()
///    @see getTaggedString()
///    @ingroup Networking)
/// 	
/// </summary>

public void fn_removeTaggedString (int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_removeTaggedString'" + string.Format("\"{0}\" ",tag));

SafeNativeMethods.mwle_fn_removeTaggedString(tag);
}
/// <summary>
/// Remove the word in @a text at the given @a index.
///    Words in @a text must be separated by newlines, spaces, and/or tabs.
///    @param text A whitespace-separated list of words.
///    @param index The zero-based index of the word in @a text.
///    @return A new string with the word at the given index removed or the original string if @a index is 
///       out of range.
///    @tsexample
///       removeWord( \"a b c d\", 2 ) // Returns \"a b d\"
///    @endtsexample
///    @see removeField
///    @see removeRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_removeWord (string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_removeWord'" + string.Format("\"{0}\" \"{1}\" ",text,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_removeWord(sbtext, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Renames the given @a file.
///    @param from %Path of the file to rename from.
///    @param frome %Path of the file to rename to.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public bool fn_renameFile (string from, string to)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_renameFile'" + string.Format("\"{0}\" \"{1}\" ",from,to));
StringBuilder sbfrom = null;
if (from != null)
     sbfrom = new StringBuilder(from, 1024);
StringBuilder sbto = null;
if (to != null)
     sbto = new StringBuilder(to, 1024);

return  SafeNativeMethods.mwle_fn_renameFile(sbfrom, sbto)>=1;
}
/// <summary>
/// ()
///    @brief Reset FPS stats (fps::)
///    @ingroup Game)
/// 
/// </summary>

public void fn_resetFPSTracker ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_resetFPSTracker'");


SafeNativeMethods.mwle_fn_resetFPSTracker();
}
/// <summary>
/// @brief Deactivates and then activates the currently active light manager.
///    This causes most shaders to be regenerated and is often used when global 
///    rendering changes have occured.
///    @ingroup Lighting )
/// 
/// </summary>

public void fn_resetLightManager ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_resetLightManager'");


SafeNativeMethods.mwle_fn_resetLightManager();
}
/// <summary>
/// ()
///             @brief Rebuilds the XInput section of the InputManager
///             Requests a full refresh of events for all controllers. Useful when called at the beginning 
///             of game code after actionMaps are set up to hook up all appropriate events.
///             @ingroup Input)
/// 
/// </summary>

public void fn_resetXInput ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_resetXInput'");


SafeNativeMethods.mwle_fn_resetXInput();
}
/// <summary>
/// Return all but the first word in @a text.
///    @param text A list of words separated by newlines, spaces, and/or tabs.
///    @return @a text with the first word removed.
///    @note This is equal to 
///    @tsexample_nopar
///       getWords( text, 1 )
///    @endtsexample
///    @see getWords
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_restWords (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_restWords'" + string.Format("\"{0}\" ",text));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fn_restWords(sbtext, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Remove trailing whitespace from the string.
///    @param str A string.
///    @return A string that is the same as @a str but with any trailing (i.e. rightmost) whitespace removed.
///    @tsexample
///    rtrim( \"   string  \" ); // Returns \"   string\".
///    @endtsexample
///    @see ltrim
///    @see trim
///    @ingroup Strings )
/// 
/// </summary>

public string fn_rtrim (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_rtrim'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_rtrim(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string device, float xRumble, float yRumble)
///       @brief Activates the vibration motors in the specified controller.
///       The controller will constantly at it's xRumble and yRumble intensities until 
///       changed or told to stop.
///       Valid inputs for xRumble/yRumble are [0 - 1].
///       @param device Name of the device to rumble.
///       @param xRumble Intensity to apply to the left motor.
///       @param yRumble Intensity to apply to the right motor.
///       @note in an Xbox 360 controller, the left motor is low-frequency, 
///       while the right motor is high-frequency.
///       @ingroup Input)
/// 
/// </summary>

public void fn_rumble (string device, float xRumble, float yRumble)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_rumble'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",device,xRumble,yRumble));
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);

SafeNativeMethods.mwle_fn_rumble(sbdevice, xRumble, yRumble);
}
/// <summary>
/// (string filename) 
///                 Save the journal to the specified file.
/// 				@ingroup Platform)
/// 
/// </summary>

public void fn_saveJournal (string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_saveJournal'" + string.Format("\"{0}\" ",filename));
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_saveJournal(sbfilename);
}
/// <summary>
/// @brief Serialize the object to a file.
/// 				@param object The object to serialize.
/// 				@param filename The file name and path.
/// 				@ingroup Console)
/// 
/// </summary>

public bool fn_saveObject (string objectx, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_saveObject'" + string.Format("\"{0}\" \"{1}\" ",objectx,filename));
StringBuilder sbobjectx = null;
if (objectx != null)
     sbobjectx = new StringBuilder(objectx, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fn_saveObject(sbobjectx, sbfilename)>=1;
}
/// <summary>
/// Dump the current zoning states of all zone spaces in the scene to the console.
///    @param updateFirst If true, zoning states are brought up to date first; if false, the zoning states 
///    are dumped as is.
///    @note Only valid on the client.
///    @ingroup Game )
/// 
/// </summary>

public void fn_sceneDumpZoneStates (bool updateFirst)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sceneDumpZoneStates'" + string.Format("\"{0}\" ",updateFirst));

SafeNativeMethods.mwle_fn_sceneDumpZoneStates(updateFirst);
}
/// <summary>
/// Return the SceneObject that contains the given zone.
///    @param zoneId ID of zone.
///    @return A SceneObject or NULL if the given @a zoneId is invalid.
///    @note Only valid on the client.
///    @ingroup Game )
/// 
/// </summary>

public string fn_sceneGetZoneOwner (uint zoneId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sceneGetZoneOwner'" + string.Format("\"{0}\" ",zoneId));
var returnbuff = new StringBuilder(1024);

SafeNativeMethods.mwle_fn_sceneGetZoneOwner(zoneId, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Takes a screenshot with optional tiling to produce huge screenshots.
///    @param file The output image file path.
///    @param format Either JPEG or PNG.
///    @param tileCount If greater than 1 will tile the current screen size to take a large format screenshot.
///    @param tileOverlap The amount of horizontal and vertical overlap between the tiles used to remove tile edge artifacts from post effects.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_screenShot (string file, string format, uint tileCount, float tileOverlap)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_screenShot'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",file,format,tileCount,tileOverlap));
StringBuilder sbfile = null;
if (file != null)
     sbfile = new StringBuilder(file, 1024);
StringBuilder sbformat = null;
if (format != null)
     sbformat = new StringBuilder(format, 1024);

SafeNativeMethods.mwle_fn_screenShot(sbfile, sbformat, tileCount, tileOverlap);
}
/// <summary>
/// @brief Open the given folder in the system's file manager.
///    @param path full path to a directory.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public void fn_selectFile (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_selectFile'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_selectFile(sbpath);
}
/// <summary>
/// (string text)
///                @brief Set the system clipboard.
/// 			   @internal)
/// 
/// </summary>

public bool fn_setClipboard (string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setClipboard'" + string.Format("\"{0}\" ",text));
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fn_setClipboard(sbtext)>=1;
}
/// <summary>
/// (string LangTable)
/// 				@brief Sets the primary LangTable used by the game
/// 				@param LangTable ID of the core LangTable
/// 				@ingroup Localization)
/// 
/// </summary>

public void fn_setCoreLangTable (string lgTable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setCoreLangTable'" + string.Format("\"{0}\" ",lgTable));
StringBuilder sblgTable = null;
if (lgTable != null)
     sblgTable = new StringBuilder(lgTable, 1024);

SafeNativeMethods.mwle_fn_setCoreLangTable(sblgTable);
}
/// <summary>
/// @brief Set the current working directory.
///    @param path The absolute or relative (to the current working directory) path of the directory which should be made the new 
///       working directory.
///    @return True if the working directory was successfully changed to @a path, false otherwise.
///    @note Only present in a Tools build of Torque.
///    @ingroup FileSystem)
/// 
/// </summary>

public bool fn_setCurrentDirectory (string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setCurrentDirectory'" + string.Format("\"{0}\" ",path));
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

return  SafeNativeMethods.mwle_fn_setCurrentDirectory(sbpath)>=1;
}
/// <summary>
/// @brief Set the default FOV for a camera.
///             @param defaultFOV The default field of view in degrees
/// 				@ingroup CameraSystem)
/// 
/// </summary>

public void fn_setDefaultFov (float defaultFOV)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setDefaultFov'" + string.Format("\"{0}\" ",defaultFOV));

SafeNativeMethods.mwle_fn_setDefaultFov(defaultFOV);
}
/// <summary>
/// Sets the clients far clipping.
///    )
/// 
/// </summary>

public void fn_setFarClippingDistance (float dist)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setFarClippingDistance'" + string.Format("\"{0}\" ",dist));

SafeNativeMethods.mwle_fn_setFarClippingDistance(dist);
}
/// <summary>
/// Replace the field in @a text at the given @a index with @a replacement.
///    Fields in @a text must be separated by newlines and/or tabs.
///    @param text A list of fields separated by newlines and/or tabs.
///    @param index The zero-based index of the field to replace.
///    @param replacement The string with which to replace the field.
///    @return A new string with the field at the given @a index replaced by @a replacement or the original 
///       string if @a index is out of range.
///    @tsexample
///       setField( \"a b\" TAB \"c d\" TAB \"e f\", 1, \"g h\" ) // Returns \"a b\" TAB \"g h\" TAB \"e f\"
///    @endtsexample
///    @see getField
///    @see setWord
///    @see setRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_setField (string text, int index, string replacement)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setField'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,index,replacement));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);
StringBuilder sbreplacement = null;
if (replacement != null)
     sbreplacement = new StringBuilder(replacement, 1024);

SafeNativeMethods.mwle_fn_setField(sbtext, index, sbreplacement, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Resizes the rendertargets of the Volumetric Fog object.
/// 	If there are fogobjects in the scene then the function is postponed until
/// 	all fogobjects are deleted.
/// 	@params new_quality new quality for the rendertargets 1 = full size, 2 = halfsize, 3 = 1/3, 4 = 1/4 ...)
/// 
/// </summary>

public int fn_SetFogVolumeQuality (uint new_quality)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SetFogVolumeQuality'" + string.Format("\"{0}\" ",new_quality));

return  SafeNativeMethods.mwle_fn_SetFogVolumeQuality(new_quality);
}
/// <summary>
/// @brief Set the FOV of the camera.
///             @param FOV The camera's new FOV in degrees
/// 				@ingroup CameraSystem)
/// 
/// </summary>

public void fn_setFov (float FOV)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setFov'" + string.Format("\"{0}\" ",FOV));

SafeNativeMethods.mwle_fn_setFov(FOV);
}
/// <summary>
/// @brief .)
/// 
/// </summary>

public void fn_setFrustumOffset (string offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setFrustumOffset'" + string.Format("\"{0}\" ",offset));
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

SafeNativeMethods.mwle_fn_setFrustumOffset(sboffset);
}
/// <summary>
/// Finds and activates the named light manager.
///    @return Returns true if the light manager is found and activated.
///    @ingroup Lighting )
/// 
/// </summary>

public bool fn_setLightManager (string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setLightManager'" + string.Format("\"{0}\" ",name));
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fn_setLightManager(sbname)>=1;
}
/// <summary>
/// @brief Determines how log files are written.
/// 	Sets the operational mode of the console logging system.
///    @param mode Parameter specifying the logging mode.  This can be:
///       - 1: Open and close the console log file for each seperate string of output.  This will ensure that all 
///          parts get written out to disk and that no parts remain in intermediate buffers even if the process crashes.
///       - 2: Keep the log file open and write to it continuously.  This will make the system operate faster but 
///          if the process crashes, parts of the output may not have been written to disk yet and will be missing from 
///          the log.
///          
///       Additionally, when changing the log mode and thus opening a new log file, either of the two mode values may be 
///       combined by binary OR with 0x4 to cause the logging system to flush all console log messages that had already been 
///       issued to the console system into the newly created log file.
/// 
/// 	@note Xbox 360 does not support logging to a file. Use Platform::OutputDebugStr in C++ instead.
/// 	@ingroup Logging )
/// 
/// </summary>

public void fn_setLogMode (int mode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setLogMode'" + string.Format("\"{0}\" ",mode));

SafeNativeMethods.mwle_fn_setLogMode(mode);
}
/// <summary>
/// (int port, bool bind=true) 
///    @brief Set the network port for the game to use.
/// 
///    @param port The port to use.
///    @param bind True if bind() should be called on the port.
/// 
///    @returns True if the port was successfully opened.
/// 
///    This will trigger a windows firewall prompt.  
///    If you don't have firewall tunneling tech you can set this to false to avoid the prompt.
///    @ingroup Networking)
/// 
/// </summary>

public bool fn_setNetPort (int port, bool bind)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setNetPort'" + string.Format("\"{0}\" \"{1}\" ",port,bind));

return  SafeNativeMethods.mwle_fn_setNetPort(port, bind)>=1;
}
/// <summary>
/// @brief Sets the pixel shader version for the active device.
///    This can be used to force a lower pixel shader version than is supported by 
///    the device for testing or performance optimization.
///    @param version The floating point shader version number.
///    @note This will only affect shaders/materials created after the call 
///    and should be used before the game begins.
///    @see $pref::Video::forcedPixVersion
///    @ingroup GFX )
/// 
/// </summary>

public void fn_setPixelShaderVersion (float version)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setPixelShaderVersion'" + string.Format("\"{0}\" ",version));

SafeNativeMethods.mwle_fn_setPixelShaderVersion(version);
}
/// <summary>
/// Set the current seed for the random number generator.
///    Based on this seed, a repeatable sequence of numbers will be produced by getRandom().
///    @param seed The seed with which to initialize the randon number generator with.  The same seed will always leed to
///       the same sequence of pseudo-random numbers.
///       If -1, the current timestamp will be used as the seed which is a good basis for randomization.
///    @ingroup Random )
/// 
/// </summary>

public void fn_setRandomSeed (int seed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setRandomSeed'" + string.Format("\"{0}\" ",seed));

SafeNativeMethods.mwle_fn_setRandomSeed(seed);
}
/// <summary>
/// Replace the record in @a text at the given @a index with @a replacement.
///    Records in @a text must be separated by newlines.
///    @param text A list of records separated by newlines.
///    @param index The zero-based index of the record to replace.
///    @param replacement The string with which to replace the record.
///    @return A new string with the record at the given @a index replaced by @a replacement or the original 
///       string if @a index is out of range.
///    @tsexample
///       setRecord( \"a b\" NL \"c d\" NL \"e f\", 1, \"g h\" ) // Returns \"a b\" NL \"g h\" NL \"e f\"
///    @endtsexample
///    @see getRecord
///    @see setWord
///    @see setField
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_setRecord (string text, int index, string replacement)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setRecord'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,index,replacement));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);
StringBuilder sbreplacement = null;
if (replacement != null)
     sbreplacement = new StringBuilder(replacement, 1024);

SafeNativeMethods.mwle_fn_setRecord(sbtext, index, sbreplacement, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Set the reflection texture format.
///    @ingroup GFX )
/// 
/// </summary>

public void fn_setReflectFormat (int format)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setReflectFormat'" + string.Format("\"{0}\" ",format));

SafeNativeMethods.mwle_fn_setReflectFormat(format);
}
/// <summary>
/// setServerInfo(...); )
/// 
/// </summary>

public bool fn_setServerInfo (uint index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setServerInfo'" + string.Format("\"{0}\" ",index));

return  SafeNativeMethods.mwle_fn_setServerInfo(index)>=1;
}
/// <summary>
/// ), string sShadowSystemName)
/// 
/// </summary>

public bool fn_setShadowManager (string sShadowSystemName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setShadowManager'" + string.Format("\"{0}\" ",sShadowSystemName));
StringBuilder sbsShadowSystemName = null;
if (sShadowSystemName != null)
     sbsShadowSystemName = new StringBuilder(sShadowSystemName, 1024);

return  SafeNativeMethods.mwle_fn_setShadowManager(sbsShadowSystemName)>=1;
}
/// <summary>
/// ), )
/// 
/// </summary>

public string fn_setShadowVizLight (string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setShadowVizLight'" + string.Format("\"{0}\" ",name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_setShadowVizLight(sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// settingObj.beginGroup(groupName, fromStart = false);)
/// 
/// </summary>

public void fn_Settings_beginGroup (string settings, string groupName, bool includeDefaults)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_beginGroup'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",settings,groupName,includeDefaults));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbgroupName = null;
if (groupName != null)
     sbgroupName = new StringBuilder(groupName, 1024);

SafeNativeMethods.mwle_fn_Settings_beginGroup(sbsettings, sbgroupName, includeDefaults);
}
/// <summary>
/// settingObj.clearGroups();)
/// 
/// </summary>

public void fn_Settings_clearGroups (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_clearGroups'" + string.Format("\"{0}\" ",settings));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

SafeNativeMethods.mwle_fn_Settings_clearGroups(sbsettings);
}
/// <summary>
/// settingObj.endGroup();)
/// 
/// </summary>

public void fn_Settings_endGroup (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_endGroup'" + string.Format("\"{0}\" ",settings));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

SafeNativeMethods.mwle_fn_Settings_endGroup(sbsettings);
}
/// <summary>
/// , false, false), settingObj.findFirstValue();)
/// 
/// </summary>

public string fn_Settings_findFirstValue (string settings, string pattern, bool deepSearch, bool includeDefaults)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_findFirstValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",settings,pattern,deepSearch,includeDefaults));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fn_Settings_findFirstValue(sbsettings, sbpattern, deepSearch, includeDefaults, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// settingObj.findNextValue();)
/// 
/// </summary>

public string fn_Settings_findNextValue (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_findNextValue'" + string.Format("\"{0}\" ",settings));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

SafeNativeMethods.mwle_fn_Settings_findNextValue(sbsettings, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// settingObj.getCurrentGroups();)
/// 
/// </summary>

public string fn_Settings_getCurrentGroups (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_getCurrentGroups'" + string.Format("\"{0}\" ",settings));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

SafeNativeMethods.mwle_fn_Settings_getCurrentGroups(sbsettings, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// %success = settingObj.read();)
/// 
/// </summary>

public bool fn_Settings_read (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_read'" + string.Format("\"{0}\" ",settings));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

return  SafeNativeMethods.mwle_fn_Settings_read(sbsettings)>=1;
}
/// <summary>
/// settingObj.remove(settingName, includeDefaults = false);)
/// 
/// </summary>

public void fn_Settings_remove (string settings, string settingName, bool includeDefaults)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_remove'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",settings,settingName,includeDefaults));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbsettingName = null;
if (settingName != null)
     sbsettingName = new StringBuilder(settingName, 1024);

SafeNativeMethods.mwle_fn_Settings_remove(sbsettings, sbsettingName, includeDefaults);
}
/// <summary>
/// settingObj.setDefaultValue(settingName, value);)
/// 
/// </summary>

public void fn_Settings_setDefaultValue (string settings, string settingName, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_setDefaultValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",settings,settingName,value));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbsettingName = null;
if (settingName != null)
     sbsettingName = new StringBuilder(settingName, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fn_Settings_setDefaultValue(sbsettings, sbsettingName, sbvalue);
}
/// <summary>
/// ), settingObj.setValue(settingName, value);)
/// 
/// </summary>

public void fn_Settings_setValue (string settings, string settingName, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_setValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",settings,settingName,value));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbsettingName = null;
if (settingName != null)
     sbsettingName = new StringBuilder(settingName, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fn_Settings_setValue(sbsettings, sbsettingName, sbvalue);
}
/// <summary>
/// ), settingObj.value(settingName, defaultValue);)
/// 
/// </summary>

public string fn_Settings_value (string settings, string settingName, string defaultValue)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Settings_value'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",settings,settingName,defaultValue));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);
StringBuilder sbsettingName = null;
if (settingName != null)
     sbsettingName = new StringBuilder(settingName, 1024);
StringBuilder sbdefaultValue = null;
if (defaultValue != null)
     sbdefaultValue = new StringBuilder(defaultValue, 1024);

SafeNativeMethods.mwle_fn_Settings_value(sbsettings, sbsettingName, sbdefaultValue, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (string varName, string value) 
///    @brief Sets the value of the named variable.
///    @param varName Name of the variable to locate
///    @param value New value of the variable
///    @return True if variable was successfully found and set
///    @ingroup Scripting)
/// 
/// </summary>

public void fn_setVariable (string varName, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setVariable'" + string.Format("\"{0}\" \"{1}\" ",varName,value));
StringBuilder sbvarName = null;
if (varName != null)
     sbvarName = new StringBuilder(varName, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fn_setVariable(sbvarName, sbvalue);
}
/// <summary>
/// Replace the word in @a text at the given @a index with @a replacement.
///    Words in @a text must be separated by newlines, spaces, and/or tabs.
///    @param text A whitespace-separated list of words.
///    @param index The zero-based index of the word to replace.
///    @param replacement The string with which to replace the word.
///    @return A new string with the word at the given @a index replaced by @a replacement or the original 
///       string if @a index is out of range.
///    @tsexample
///       setWord( \"a b c d\", 2, \"f\" ) // Returns \"a b f d\"
///    @endtsexample
///    @see getWord
///    @see setField
///    @see setRecord
///    @ingroup FieldManip )
/// 
/// </summary>

public string fn_setWord (string text, int index, string replacement)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setWord'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",text,index,replacement));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);
StringBuilder sbreplacement = null;
if (replacement != null)
     sbreplacement = new StringBuilder(replacement, 1024);

SafeNativeMethods.mwle_fn_setWord(sbtext, index, sbreplacement, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Set the zoom speed of the camera.
///             This affects how quickly the camera changes from one field of view 
///             to another.
///             @param speed The camera's zoom speed in ms per 90deg FOV change
/// 				@ingroup CameraSystem)
/// 
/// </summary>

public void fn_setZoomSpeed (int speed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_setZoomSpeed'" + string.Format("\"{0}\" ",speed));

SafeNativeMethods.mwle_fn_setZoomSpeed(speed);
}
/// <summary>
/// Try to create a new sound device using the given properties.
///    If a sound device is currently initialized, it will be uninitialized first.  However, be aware that in this case, 
///    if this function fails, it will not restore the previously active device but rather leave the sound system in an 
///    uninitialized state.
///    Sounds that are already playing while the new device is created will be temporarily transitioned to virtualized 
///    playback and then resume normal playback once the device has been created.
///    In the core scripts, sound is automatically set up during startup in the sfxStartup() function.
///    @param provider The name of the device provider as returned by sfxGetAvailableDevices().
///    @param device The name of the device as returned by sfxGetAvailableDevices().
///    @param useHardware Whether to enabled hardware mixing on the device or not.  Only relevant if supported by the given device.
///    @param maxBuffers The maximum number of concurrent voices for this device to use or -1 for the device to pick its own reasonable default.
///    @return True if the initialization was successful, false if not.
///    @note This function must be called before any of the sound playback functions can be used.
///    @see sfxGetAvailableDevices
///    @see sfxGetDeviceInfo
///    @see sfxDeleteDevice
///    @ref SFX_devices
///    @ingroup SFX )
/// 
/// </summary>

public bool fn_sfxCreateDevice (string provider, string device, bool useHardware, int maxBuffers)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxCreateDevice'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",provider,device,useHardware,maxBuffers));
StringBuilder sbprovider = null;
if (provider != null)
     sbprovider = new StringBuilder(provider, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);

return  SafeNativeMethods.mwle_fn_sfxCreateDevice(sbprovider, sbdevice, useHardware, maxBuffers)>=1;
}
/// <summary>
/// , , , ),
///                      ( SFXTrack track | ( SFXDescription description, string filename ) [, float x, float y, float z ] ) 
///                      Creates a new paused sound source using a profile or a description 
///                      and filename.  The return value is the source which must be 
///                      released by delete().
///                      @hide )
/// 
/// </summary>

public int fn_sfxCreateSource (string SFXType, string filename, string x, string y, string z)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxCreateSource'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",SFXType,filename,x,y,z));
StringBuilder sbSFXType = null;
if (SFXType != null)
     sbSFXType = new StringBuilder(SFXType, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbx = null;
if (x != null)
     sbx = new StringBuilder(x, 1024);
StringBuilder sby = null;
if (y != null)
     sby = new StringBuilder(y, 1024);
StringBuilder sbz = null;
if (z != null)
     sbz = new StringBuilder(z, 1024);

return  SafeNativeMethods.mwle_fn_sfxCreateSource(sbSFXType, sbfilename, sbx, sby, sbz);
}
/// <summary>
/// Delete the currently active sound device and release all its resources.
///    SFXSources that are still playing will be transitioned to virtualized playback mode. 
///    When creating a new device, they will automatically transition back to normal playback.
///    In the core scripts, this is done automatically for you during shutdown in the sfxShutdown() function.
///    @see sfxCreateDevice
///    @ref SFX_devices
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxDeleteDevice ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxDeleteDevice'");


SafeNativeMethods.mwle_fn_sfxDeleteDevice();
}
/// <summary>
/// Mark the given @a source for deletion as soon as it moves into stopped state.
///    This function will retroactively turn the given @a source into a play-once source (see @ref SFXSource_playonce).
///    @param source A sound source.
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxDeleteWhenStopped (string source)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxDeleteWhenStopped'" + string.Format("\"{0}\" ",source));
StringBuilder sbsource = null;
if (source != null)
     sbsource = new StringBuilder(source, 1024);

SafeNativeMethods.mwle_fn_sfxDeleteWhenStopped(sbsource);
}
/// <summary>
/// Dump information about all current SFXSource instances to the console.
///    The dump includes information about the playback status for each source, volume levels, virtualization, etc.
///    @param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. 
///       Otherwise only instances of subclasses of SFXSources are included in the dump.
///    @see SFXSource
///    @see sfxDumpSourcesToString
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxDumpSources (bool includeGroups)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxDumpSources'" + string.Format("\"{0}\" ",includeGroups));

SafeNativeMethods.mwle_fn_sfxDumpSources(includeGroups);
}
/// <summary>
/// Dump information about all current SFXSource instances to a string.
///    The dump includes information about the playback status for each source, volume levels, virtualization, etc.
///    @param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. 
///       Otherwise only instances of subclasses of SFXSources are included in the dump.
///    @return A string containing a dump of information about all currently instantiated SFXSources.
///    @see SFXSource
///    @see sfxDumpSources
///    @ingroup SFX )
/// 
/// </summary>

public string fn_sfxDumpSourcesToString (bool includeGroups)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxDumpSourcesToString'" + string.Format("\"{0}\" ",includeGroups));
var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_sfxDumpSourcesToString(includeGroups, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return a newline-separated list of all active states.
///    @return A list of the form
///    @verbatim
///       stateName1 NL stateName2 NL stateName3 ...
///    @endverbatim
///    where each element is the name of an active state object.
///    @tsexample
///       // Disable all active states.
///       foreach$( %state in sfxGetActiveStates() )
///          %state.disable();
///    @endtsexample
///    @ingroup SFX )
/// 
/// </summary>

public string fn_sfxGetActiveStates ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetActiveStates'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_sfxGetActiveStates(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get a list of all available sound devices.
///    The return value will be a newline-separated list of entries where each line describes one available sound 
///    device.  Each such line will have the following format:
///    @verbatim
///       provider TAB device TAB hasHardware TAB numMaxBuffers
///    @endverbatim
///    - provider: The name of the device provider (e.g. \"FMOD\").
///    - device: The name of the device as returned by the device layer.
///    - hasHardware: Whether the device supports hardware mixing or not.
///    - numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit 
///       limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization 
///       will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not 
///       be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
///    @return A newline-separated list of information about all available sound devices.
///    @see sfxCreateDevice
///    @see sfxGetDeviceInfo
///    @see $SFX::DEVICE_INFO_PROVIDER
///    @see $SFX::DEVICE_INFO_NAME
///    @see $SFX::DEVICE_INFO_USEHARDWARE
///    @see $SFX::DEVICE_INFO_MAXBUFFERS
///    @ref SFX_devices
///    @ingroup SFX )
/// 
/// </summary>

public string fn_sfxGetAvailableDevices ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetAvailableDevices'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_sfxGetAvailableDevices(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return information about the currently active sound device.
///    The return value is a tab-delimited string of the following format:
///    @verbatim
///       provider TAB device TAB hasHardware TAB numMaxBuffers TAB caps
///    @endverbatim
///    - provider: The name of the device provider (e.g. \"FMOD\").
///    - device: The name of the device as returned by the device layer.
///    - hasHardware: Whether the device supports hardware mixing or not.
///    - numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit 
///       limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization 
///       will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not 
///       be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
///    - caps: A bitfield of capability flags.
///    @return A tab-separated list of properties of the currently active sound device or the empty string if no sound device has been initialized.
///    @see sfxCreateDevice
///    @see sfxGetAvailableDevices
///    @see $SFX::DEVICE_INFO_PROVIDER
///    @see $SFX::DEVICE_INFO_NAME
///    @see $SFX::DEVICE_INFO_USEHARDWARE
///    @see $SFX::DEVICE_INFO_MAXBUFFERS
///    @see $SFX::DEVICE_INFO_CAPS
///    @see $SFX::DEVICE_CAPS_REVERB
///    @see $SFX::DEVICE_CAPS_VOICEMANAGEMENT
///    @see $SFX::DEVICE_CAPS_OCCLUSION
///    @see $SFX::DEVICE_CAPS_DSPEFFECTS
///    @see $SFX::DEVICE_CAPS_MULTILISTENER
///    @see $SFX::DEVICE_CAPS_FMODDESIGNER
///    @ref SFX_devices
///    @ingroup SFX )
/// 
/// </summary>

public string fn_sfxGetDeviceInfo ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetDeviceInfo'");

var returnbuff = new StringBuilder(16384);

SafeNativeMethods.mwle_fn_sfxGetDeviceInfo(returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the falloff curve type currently being applied to 3D sounds.
///    @return The current distance model type.
///    @ref SFXSource_volume
///    @ref SFX_3d
///    @ingroup SFX )
/// 
/// </summary>

public int fn_sfxGetDistanceModel ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetDistanceModel'");


return  SafeNativeMethods.mwle_fn_sfxGetDistanceModel();
}
/// <summary>
/// Get the current global doppler effect setting.
///    @return The current global doppler effect scale factor (>=0).
///    @see sfxSetDopplerFactor
///    @ref SFXSource_doppler
///    @ingroup SFX )
/// 
/// </summary>

public float fn_sfxGetDopplerFactor ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetDopplerFactor'");


return  SafeNativeMethods.mwle_fn_sfxGetDopplerFactor();
}
/// <summary>
/// Get the current global scale factor applied to volume attenuation of 3D sounds in the logarithmic model.
///    @return The current scale factor for logarithmic 3D sound falloff curves.
///    @see sfxGetDistanceModel
///    @see SFXDistanceModel
///    @ref SFXSource_volume
///    @ref SFX_3d
///    @ingroup SFX )
/// 
/// </summary>

public float fn_sfxGetRolloffFactor ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxGetRolloffFactor'");


return  SafeNativeMethods.mwle_fn_sfxGetRolloffFactor();
}
/// <summary>
/// , , ),
///    Start playing the given source or create a new source for the given track and play it.
///    @hide )
/// 
/// </summary>

public int fn_sfxPlay (string trackName, string pointOrX, string y, string z)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxPlay'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",trackName,pointOrX,y,z));
StringBuilder sbtrackName = null;
if (trackName != null)
     sbtrackName = new StringBuilder(trackName, 1024);
StringBuilder sbpointOrX = null;
if (pointOrX != null)
     sbpointOrX = new StringBuilder(pointOrX, 1024);
StringBuilder sby = null;
if (y != null)
     sby = new StringBuilder(y, 1024);
StringBuilder sbz = null;
if (z != null)
     sbz = new StringBuilder(z, 1024);

return  SafeNativeMethods.mwle_fn_sfxPlay(sbtrackName, sbpointOrX, sby, sbz);
}
/// <summary>
/// , , , -1.0f),
///    SFXSource sfxPlayOnce( ( SFXTrack track | SFXDescription description, string filename ) [, float x, float y, float z, float fadeInTime=-1 ] ) 
///    Create a new play-once source for the given profile or description+filename and start playback of the source.
///    @hide )
/// 
/// </summary>

public int fn_sfxPlayOnce (string SFXType, string filename, string x, string y, string z, float fadeInTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxPlayOnce'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",SFXType,filename,x,y,z,fadeInTime));
StringBuilder sbSFXType = null;
if (SFXType != null)
     sbSFXType = new StringBuilder(SFXType, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbx = null;
if (x != null)
     sbx = new StringBuilder(x, 1024);
StringBuilder sby = null;
if (y != null)
     sby = new StringBuilder(y, 1024);
StringBuilder sbz = null;
if (z != null)
     sbz = new StringBuilder(z, 1024);

return  SafeNativeMethods.mwle_fn_sfxPlayOnce(sbSFXType, sbfilename, sbx, sby, sbz, fadeInTime);
}
/// <summary>
/// Set the falloff curve type to use for distance-based volume attenuation of 3D sounds.
///    @param model The distance model to use for 3D sound.
///    @note This setting takes effect globally and is applied to all 3D sounds.
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxSetDistanceModel (int model)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxSetDistanceModel'" + string.Format("\"{0}\" ",model));

SafeNativeMethods.mwle_fn_sfxSetDistanceModel(model);
}
/// <summary>
/// Set the global doppler effect scale factor.
///    @param value The new doppler shift scale factor.
///    @pre @a value must be >= 0.
///    @see sfxGetDopplerFactor
///    @ref SFXSource_doppler
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxSetDopplerFactor (float value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxSetDopplerFactor'" + string.Format("\"{0}\" ",value));

SafeNativeMethods.mwle_fn_sfxSetDopplerFactor(value);
}
/// <summary>
/// Set the global scale factor to apply to volume attenuation of 3D sounds in the logarithmic model.
///    @param value The new scale factor for logarithmic 3D sound falloff curves.
///    @pre @a value must be > 0.
///    @note This function has no effect if the currently distance model is set to SFXDistanceModel::Linear.
///    @see sfxGetDistanceModel
///    @see SFXDistanceModel
///    @ref SFXSource_volume
///    @ref SFX_3d
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxSetRolloffFactor (float value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxSetRolloffFactor'" + string.Format("\"{0}\" ",value));

SafeNativeMethods.mwle_fn_sfxSetRolloffFactor(value);
}
/// <summary>
///  ),
///    ( vector position [, vector direction ] ) 
///    Set the position and orientation of a 3D sound source.
///    @hide )
/// 
/// </summary>

public void fn_SFXSource_setTransform (string sfxsource, string position, string direction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SFXSource_setTransform'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",sfxsource,position,direction));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);
StringBuilder sbdirection = null;
if (direction != null)
     sbdirection = new StringBuilder(direction, 1024);

SafeNativeMethods.mwle_fn_SFXSource_setTransform(sbsfxsource, sbposition, sbdirection);
}
/// <summary>
/// Stop playback of the given @a source.
///    This is equivalent to calling SFXSource::stop().
///    @param source The source to put into stopped state.
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxStop (string source)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxStop'" + string.Format("\"{0}\" ",source));
StringBuilder sbsource = null;
if (source != null)
     sbsource = new StringBuilder(source, 1024);

SafeNativeMethods.mwle_fn_sfxStop(sbsource);
}
/// <summary>
/// Stop playback of the given @a source (if it is not already stopped) and delete the @a source.
///    The advantage of this function over directly calling delete() is that it will correctly 
///    handle volume fades that may be configured on the source.  Whereas calling delete() would immediately 
///    stop playback and delete the source, this functionality will wait for the fade-out to play and only then 
///    stop the source and delete it.
///    @param source A sound source.
///    @ref SFXSource_fades
///    @ingroup SFX )
/// 
/// </summary>

public void fn_sfxStopAndDelete (string source)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sfxStopAndDelete'" + string.Format("\"{0}\" ",source));
StringBuilder sbsource = null;
if (source != null)
     sbsource = new StringBuilder(source, 1024);

SafeNativeMethods.mwle_fn_sfxStopAndDelete(sbsource);
}
/// <summary>
/// , ), (string executable, string args, string directory)
/// 				@brief Launches an outside executable or batch file
/// 				@param executable Name of the executable or batch file
/// 				@param args Optional list of arguments, in string format, to pass to the executable
/// 				@param directory Optional string containing path to output or shell
/// 				@ingroup Platform)
/// 
/// </summary>

public bool fn_shellExecute (string executable, string args, string directory)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_shellExecute'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",executable,args,directory));
StringBuilder sbexecutable = null;
if (executable != null)
     sbexecutable = new StringBuilder(executable, 1024);
StringBuilder sbargs = null;
if (args != null)
     sbargs = new StringBuilder(args, 1024);
StringBuilder sbdirectory = null;
if (directory != null)
     sbdirectory = new StringBuilder(directory, 1024);

return  SafeNativeMethods.mwle_fn_shellExecute(sbexecutable, sbargs, sbdirectory)>=1;
}
/// <summary>
/// (idx) Get the component corresponding to the given index.
/// 			  @param idx An integer index value corresponding to the desired component.
/// 			  @return The id of the component at the given index as an integer)
/// 
/// </summary>

public int fn_SimComponent_getComponent (string simcomponent, int idx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_getComponent'" + string.Format("\"{0}\" \"{1}\" ",simcomponent,idx));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

return  SafeNativeMethods.mwle_fn_SimComponent_getComponent(sbsimcomponent, idx);
}
/// <summary>
/// () Get the current component count
/// 			  @return The number of components in the list as an integer)
/// 
/// </summary>

public int fn_SimComponent_getComponentCount (string simcomponent)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_getComponentCount'" + string.Format("\"{0}\" ",simcomponent));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

return  SafeNativeMethods.mwle_fn_SimComponent_getComponentCount(sbsimcomponent);
}
/// <summary>
/// () Check whether SimComponent is currently a template
/// 			  @return true if is a template and false if not)
/// 
/// </summary>

public bool fn_SimComponent_getIsTemplate (string simcomponent)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_getIsTemplate'" + string.Format("\"{0}\" ",simcomponent));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

return  SafeNativeMethods.mwle_fn_SimComponent_getIsTemplate(sbsimcomponent)>=1;
}
/// <summary>
/// () Check whether SimComponent is currently enabled
/// 			  @return true if enabled and false if not)
/// 
/// </summary>

public bool fn_SimComponent_isEnabled (string simcomponent)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_isEnabled'" + string.Format("\"{0}\" ",simcomponent));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

return  SafeNativeMethods.mwle_fn_SimComponent_isEnabled(sbsimcomponent)>=1;
}
/// <summary>
/// (enabled) Sets or unsets the enabled flag
/// 			  @param enabled Boolean value
/// 			  @return No return value)
/// 
/// </summary>

public void fn_SimComponent_setEnabled (string simcomponent, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_setEnabled'" + string.Format("\"{0}\" \"{1}\" ",simcomponent,enabled));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

SafeNativeMethods.mwle_fn_SimComponent_setEnabled(sbsimcomponent, enabled);
}
/// <summary>
/// (template) Sets or unsets the template flag
/// 			  @param template Boolean value
/// 			  @return No return value)
/// 
/// </summary>

public void fn_SimComponent_setIsTemplate (string simcomponent, bool templateFlag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimComponent_setIsTemplate'" + string.Format("\"{0}\" \"{1}\" ",simcomponent,templateFlag));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);

SafeNativeMethods.mwle_fn_SimComponent_setIsTemplate(sbsimcomponent, templateFlag);
}
/// <summary>
/// Reload the datablock.  This can only be used with a local client configuration. )
/// 
/// </summary>

public void fn_SimDataBlock_reloadOnLocalClient (string simdatablock)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimDataBlock_reloadOnLocalClient'" + string.Format("\"{0}\" ",simdatablock));
StringBuilder sbsimdatablock = null;
if (simdatablock != null)
     sbsimdatablock = new StringBuilder(simdatablock, 1024);

SafeNativeMethods.mwle_fn_SimDataBlock_reloadOnLocalClient(sbsimdatablock);
}
/// <summary>
/// Copy fields from another object onto this one.  The objects must 
///    be of same type. Everything from the object will overwrite what's 
///    in this object; extra fields in this object will remain. This 
///    includes dynamic fields.
///    @param fromObject The object from which to copy fields. )
/// 
/// </summary>

public void fn_SimObject_assignFieldsFrom (string simobject, string fromObject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_assignFieldsFrom'" + string.Format("\"{0}\" \"{1}\" ",simobject,fromObject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfromObject = null;
if (fromObject != null)
     sbfromObject = new StringBuilder(fromObject, 1024);

SafeNativeMethods.mwle_fn_SimObject_assignFieldsFrom(sbsimobject, sbfromObject);
}
/// <summary>
/// Delete and remove the object. )
/// 
/// </summary>

public void fn_SimObject_delete (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_delete'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_delete(sbsimobject);
}
/// <summary>
/// Dump the native C++ class hierarchy of this object's C++ class to the console. )
/// 
/// </summary>

public void fn_SimObject_dumpClassHierarchy (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_dumpClassHierarchy'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_dumpClassHierarchy(sbsimobject);
}
/// <summary>
/// List the methods defined on this object.
///    Each description is a newline-separated vector with the following elements:
///    - Minimum number of arguments.
///    - Maximum number of arguments.
///    - Prototype string.
///    - Full script file path (if script method).
///    - Line number of method definition in script (if script method).
///    - Documentation string (not including prototype).  This takes up the remainder of the vector.
///    @return An ArrayObject populated with (name,description) pairs of all methods defined on the object. )
/// 
/// </summary>

public string fn_SimObject_dumpMethods (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_dumpMethods'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_dumpMethods(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get whether the object will be included in saves.
///    @return True if the object will be saved; false otherwise. )
/// 
/// </summary>

public bool fn_SimObject_getCanSave (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getCanSave'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_getCanSave(sbsimobject)>=1;
}
/// <summary>
/// Get the name of the C++ class which the object is an instance of.
///    @return The name of the C++ class of the object. )
/// 
/// </summary>

public string fn_SimObject_getClassName (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getClassName'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getClassName(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the class namespace assigned to this object.
///    @return The name of the 'class' namespace. )
/// 
/// </summary>

public string fn_SimObject_getClassNamespace (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getClassNamespace'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getClassNamespace(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the line number at which the object is defined in its file.
///    @return The line number of the object's definition in script.
///    @see getFilename())
/// 
/// </summary>

public int fn_SimObject_getDeclarationLine (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getDeclarationLine'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_getDeclarationLine(sbsimobject);
}
/// <summary>
/// Get a value of a dynamic field by index.
///    @param index The index of the dynamic field.
///    @return The value of the dynamic field at the given index or \"\". )
/// 
/// </summary>

public string fn_SimObject_getDynamicField (string simobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getDynamicField'" + string.Format("\"{0}\" \"{1}\" ",simobject,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getDynamicField(sbsimobject, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of dynamic fields defined on the object.
///    @return The number of dynamic fields defined on the object. )
/// 
/// </summary>

public int fn_SimObject_getDynamicFieldCount (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getDynamicFieldCount'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_getDynamicFieldCount(sbsimobject);
}
/// <summary>
/// Retrieve the value of a static field by index.
///    @param index The index of the static field.
///    @return The value of the static field with the given index or \"\". )
/// 
/// </summary>

public string fn_SimObject_getField (string simobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getField'" + string.Format("\"{0}\" \"{1}\" ",simobject,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getField(sbsimobject, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of static fields on the object.
///    @return The number of static fields defined on the object. )
/// 
/// </summary>

public int fn_SimObject_getFieldCount (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getFieldCount'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_getFieldCount(sbsimobject);
}
/// <summary>
/// Get the console type code of the given field.
///    @return The numeric type code for the underlying console type of the given field. )
/// 
/// </summary>

public string fn_SimObject_getFieldType (string simobject, string fieldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getFieldType'" + string.Format("\"{0}\" \"{1}\" ",simobject,fieldName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);

SafeNativeMethods.mwle_fn_SimObject_getFieldType(sbsimobject, sbfieldName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the value of the given field on this object.
///    @param fieldName The name of the field.  If it includes a field index, the index is parsed out.
///    @param index Optional parameter to specify the index of an array field separately.
///    @return The value of the given field or \"\" if undefined. )
/// 
/// </summary>

public string fn_SimObject_getFieldValue (string simobject, string fieldName, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getFieldValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simobject,fieldName,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);

SafeNativeMethods.mwle_fn_SimObject_getFieldValue(sbsimobject, sbfieldName, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the filename the object is attached to.
///    @return The name of the file the object is associated with; usually the file the object was loaded from. )
/// 
/// </summary>

public string fn_SimObject_getFilename (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getFilename'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getFilename(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the superclass namespace assigned to this object.
///    @return The name of the 'superClass' namespace. )
/// 
/// </summary>

public string fn_SimObject_getSuperClassNamespace (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_getSuperClassNamespace'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_getSuperClassNamespace(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ())
/// 
/// </summary>

public bool fn_SimObject_isEnabled (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isEnabled'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isEnabled(sbsimobject)>=1;
}
/// <summary>
/// Get whether the object has been marked as expanded. (in editor)
///    @return True if the object is marked expanded. )
/// 
/// </summary>

public bool fn_SimObject_isExpanded (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isExpanded'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isExpanded(sbsimobject)>=1;
}
/// <summary>
/// Test whether the given field is defined on this object.
///    @param fieldName The name of the field.
///    @return True if the object implements the given field. )
/// 
/// </summary>

public bool fn_SimObject_isField (string simobject, string fieldName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isField'" + string.Format("\"{0}\" \"{1}\" ",simobject,fieldName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isField(sbsimobject, sbfieldName)>=1;
}
/// <summary>
/// Test whether the namespace of this object is a direct or indirect child to the given namespace.
///    @param name The name of a namespace.
///    @return True if the given namespace name is within the namespace hierarchy of this object. )
/// 
/// </summary>

public bool fn_SimObject_isInNamespaceHierarchy (string simobject, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isInNamespaceHierarchy'" + string.Format("\"{0}\" \"{1}\" ",simobject,name));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isInNamespaceHierarchy(sbsimobject, sbname)>=1;
}
/// <summary>
/// Test whether this object is a member of the specified class.
///    @param className Name of a native C++ class.
///    @return True if this object is an instance of the given C++ class or any of its super classes. )
/// 
/// </summary>

public bool fn_SimObject_isMemberOfClass (string simobject, string className)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isMemberOfClass'" + string.Format("\"{0}\" \"{1}\" ",simobject,className));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isMemberOfClass(sbsimobject, sbclassName)>=1;
}
/// <summary>
/// Test whether the given method is defined on this object.
///    @param The name of the method.
///    @return True if the object implements the given method. )
/// 
/// </summary>

public bool fn_SimObject_isMethod (string simobject, string methodName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_isMethod'" + string.Format("\"{0}\" \"{1}\" ",simobject,methodName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbmethodName = null;
if (methodName != null)
     sbmethodName = new StringBuilder(methodName, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_isMethod(sbsimobject, sbmethodName)>=1;
}
/// <summary>
///  ),
///    Save out the object to the given file.
///    @param fileName The name of the file to save to.
///    @param selectedOnly If true, only objects marked as selected will be saved out.
///    @param preAppendString Text which will be preprended directly to the object serialization.
///    @param True on success, false on failure. )
/// 
/// </summary>

public bool fn_SimObject_save (string simobject, string fileName, bool selectedOnly, string preAppendString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_save'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",simobject,fileName,selectedOnly,preAppendString));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);
StringBuilder sbpreAppendString = null;
if (preAppendString != null)
     sbpreAppendString = new StringBuilder(preAppendString, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_save(sbsimobject, sbfileName, selectedOnly, sbpreAppendString)>=1;
}
/// <summary>
/// Retrieve the value of a static field by index.
///    @param index The index of the static field.
///    @return The value of the static field with the given index or \"\". )
/// 
/// </summary>

public bool fn_SimObject_saveToXML (string simobject, string profileName, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_saveToXML'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simobject,profileName,fileName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbprofileName = null;
if (profileName != null)
     sbprofileName = new StringBuilder(profileName, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_saveToXML(sbsimobject, sbprofileName, sbfileName)>=1;
}
/// <summary>
/// Set whether the object will be included in saves.
///    @param value If true, the object will be included in saves; if false, it will be excluded. )
/// 
/// </summary>

public void fn_SimObject_setCanSave (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setCanSave'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_setCanSave(sbsimobject, value);
}
/// <summary>
/// Assign a class namespace to this object.
///    @param name The name of the 'class' namespace for this object. )
/// 
/// </summary>

public void fn_SimObject_setClassNamespace (string simobject, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setClassNamespace'" + string.Format("\"{0}\" \"{1}\" ",simobject,name));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_SimObject_setClassNamespace(sbsimobject, sbname);
}
/// <summary>
/// (enabled))
/// 
/// </summary>

public void fn_SimObject_setEnabled (string simobject, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setEnabled'" + string.Format("\"{0}\" \"{1}\" ",simobject,enabled));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_setEnabled(sbsimobject, enabled);
}
/// <summary>
/// Set the console type code for the given field.
///    @param fieldName The name of the dynamic field to change to type for.
///    @param type The name of the console type.
///    @note This only works for dynamic fields.  Types of static fields cannot be changed. )
/// 
/// </summary>

public void fn_SimObject_setFieldType (string simobject, string fieldName, string type)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setFieldType'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simobject,fieldName,type));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);

SafeNativeMethods.mwle_fn_SimObject_setFieldType(sbsimobject, sbfieldName, sbtype);
}
/// <summary>
/// Set the value of the given field on this object.
///    @param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
///    @param value The new value to assign to the field.
///    @param index Optional argument to specify an index for an array field.
///    @return True. )
/// 
/// </summary>

public bool fn_SimObject_setFieldValue (string simobject, string fieldName, string value, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setFieldValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",simobject,fieldName,value,index));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfieldName = null;
if (fieldName != null)
     sbfieldName = new StringBuilder(fieldName, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fn_SimObject_setFieldValue(sbsimobject, sbfieldName, sbvalue, index)>=1;
}
/// <summary>
/// Sets the object's file name and path
///    @param fileName The name of the file to associate this object with. )
/// 
/// </summary>

public void fn_SimObject_setFilename (string simobject, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setFilename'" + string.Format("\"{0}\" \"{1}\" ",simobject,fileName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fn_SimObject_setFilename(sbsimobject, sbfileName);
}
/// <summary>
/// Set whether the object has been marked as expanded. (in editor)
///    @param state True if the object is to be marked expanded; false if not. )
/// 
/// </summary>

public void fn_SimObject_setIsExpanded (string simobject, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setIsExpanded'" + string.Format("\"{0}\" \"{1}\" ",simobject,state));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fn_SimObject_setIsExpanded(sbsimobject, state);
}
/// <summary>
/// Assign a superclass namespace to this object.
///    @param name The name of the 'superClass' namespace for this object. )
/// 
/// </summary>

public void fn_SimObject_setSuperClassNamespace (string simobject, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimObject_setSuperClassNamespace'" + string.Format("\"{0}\" \"{1}\" ",simobject,name));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_SimObject_setSuperClassNamespace(sbsimobject, sbname);
}
/// <summary>
/// () - Try to bind unresolved persistent IDs in the set. )
/// 
/// </summary>

public void fn_SimPersistSet_resolvePersistentIds (string simpersistset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimPersistSet_resolvePersistentIds'" + string.Format("\"{0}\" ",simpersistset));
StringBuilder sbsimpersistset = null;
if (simpersistset != null)
     sbsimpersistset = new StringBuilder(simpersistset, 1024);

SafeNativeMethods.mwle_fn_SimPersistSet_resolvePersistentIds(sbsimpersistset);
}
/// <summary>
/// addPoint( F32 value, F32 time ) )
/// 
/// </summary>

public void fn_SimResponseCurve_addPoint (string simresponsecurve, float value, float time)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimResponseCurve_addPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simresponsecurve,value,time));
StringBuilder sbsimresponsecurve = null;
if (simresponsecurve != null)
     sbsimresponsecurve = new StringBuilder(simresponsecurve, 1024);

SafeNativeMethods.mwle_fn_SimResponseCurve_addPoint(sbsimresponsecurve, value, time);
}
/// <summary>
/// clear() )
/// 
/// </summary>

public void fn_SimResponseCurve_clear (string simresponsecurve)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimResponseCurve_clear'" + string.Format("\"{0}\" ",simresponsecurve));
StringBuilder sbsimresponsecurve = null;
if (simresponsecurve != null)
     sbsimresponsecurve = new StringBuilder(simresponsecurve, 1024);

SafeNativeMethods.mwle_fn_SimResponseCurve_clear(sbsimresponsecurve);
}
/// <summary>
/// getValue( F32 time ) )
/// 
/// </summary>

public float fn_SimResponseCurve_getValue (string simresponsecurve, float time)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimResponseCurve_getValue'" + string.Format("\"{0}\" \"{1}\" ",simresponsecurve,time));
StringBuilder sbsimresponsecurve = null;
if (simresponsecurve != null)
     sbsimresponsecurve = new StringBuilder(simresponsecurve, 1024);

return  SafeNativeMethods.mwle_fn_SimResponseCurve_getValue(sbsimresponsecurve, time);
}
/// <summary>
/// () Delete all objects in the set. )
/// 
/// </summary>

public void fn_SimSet_deleteAllObjects (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimSet_deleteAllObjects'" + string.Format("\"{0}\" ",simset));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

SafeNativeMethods.mwle_fn_SimSet_deleteAllObjects(sbsimset);
}
/// <summary>
/// () Get the number of direct and indirect child objects contained in the set.
///    @return The number of objects contained in the set as well as in other sets contained directly or indirectly in the set. )
/// 
/// </summary>

public int fn_SimSet_getFullCount (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimSet_getFullCount'" + string.Format("\"{0}\" ",simset));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

return  SafeNativeMethods.mwle_fn_SimSet_getFullCount(sbsimset);
}
/// <summary>
/// ( string callbackFunction ) Sort the objects in the set using the given comparison function.
///    @param callbackFunction Name of a function that takes two object arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal. )
/// 
/// </summary>

public void fn_SimSet_sort (string simset, string callbackFunction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimSet_sort'" + string.Format("\"{0}\" \"{1}\" ",simset,callbackFunction));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbcallbackFunction = null;
if (callbackFunction != null)
     sbcallbackFunction = new StringBuilder(callbackFunction, 1024);

SafeNativeMethods.mwle_fn_SimSet_sort(sbsimset, sbcallbackFunction);
}
/// <summary>
/// (string attributeName)
///    @brief Get float attribute from the current Element on the stack.
///    @param attributeName Name of attribute to retrieve.
///    @return The value of the given attribute in the form of a float.
///    @deprecated Use attribute().)
/// 
/// </summary>

public float fn_SimXMLDocument_attributeF32 (string simxmldocument, string attributeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimXMLDocument_attributeF32'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,attributeName));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbattributeName = null;
if (attributeName != null)
     sbattributeName = new StringBuilder(attributeName, 1024);

return  SafeNativeMethods.mwle_fn_SimXMLDocument_attributeF32(sbsimxmldocument, sbattributeName);
}
/// <summary>
/// (string attributeName)
///    @brief Get int attribute from the current Element on the stack.
///    @param attributeName Name of attribute to retrieve.
///    @return The value of the given attribute in the form of an integer.
///    @deprecated Use attribute().)
/// 
/// </summary>

public int fn_SimXMLDocument_attributeS32 (string simxmldocument, string attributeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SimXMLDocument_attributeS32'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,attributeName));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbattributeName = null;
if (attributeName != null)
     sbattributeName = new StringBuilder(attributeName, 1024);

return  SafeNativeMethods.mwle_fn_SimXMLDocument_attributeS32(sbsimxmldocument, sbattributeName);
}
/// <summary>
/// @brief Determines the memory consumption of a class or object.
/// 				@param objectOrClass The object or class being measured.
/// 				@return Returns the total size of an object in bytes.
/// 				@ingroup Debugging)
/// 
/// </summary>

public int fn_sizeof (string objectOrClass)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_sizeof'" + string.Format("\"{0}\" ",objectOrClass));
StringBuilder sbobjectOrClass = null;
if (objectOrClass != null)
     sbobjectOrClass = new StringBuilder(objectOrClass, 1024);

return  SafeNativeMethods.mwle_fn_sizeof(sbobjectOrClass);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_SkyBox_postApply (string skybox)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SkyBox_postApply'" + string.Format("\"{0}\" ",skybox));
StringBuilder sbskybox = null;
if (skybox != null)
     sbskybox = new StringBuilder(skybox, 1024);

SafeNativeMethods.mwle_fn_SkyBox_postApply(sbskybox);
}
/// <summary>
/// @brief Prevents mouse movement from being processed
/// 
/// 					 In the source, whenever a mouse move event occurs 
/// 					 GameTSCtrl::onMouseMove() is called. Whenever snapToggle() 
/// 					 is called, it will flag a variable that can prevent this 
/// 					 from happening: gSnapLine. This variable is not exposed to 
/// 					 script, so you need to call this function to trigger it.
/// 
/// 					 @tsexample
/// 					 // Snapping is off by default, so we will toggle
/// 					 // it on first:
/// 					 PlayGui.snapToggle();
/// 					 // Mouse movement should be disabled
/// 					 // Let's turn it back on
/// 					 PlayGui.snapToggle();
/// 					 @endtsexample
/// 
/// 					 @ingroup GuiGame)
/// 
/// </summary>

public void fn_snapToggle ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_snapToggle'");


SafeNativeMethods.mwle_fn_snapToggle();
}
/// <summary>
/// ,,,,) ,spawnObject(class [, dataBlock, name, properties, script,modelName])
/// 				@hide)
/// 
/// </summary>

public int fn_spawnObject (string spawnClass, string spawnDataBlock, string spawnName, string spawnProperties, string spawnScript, string modelName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_spawnObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",spawnClass,spawnDataBlock,spawnName,spawnProperties,spawnScript,modelName));
StringBuilder sbspawnClass = null;
if (spawnClass != null)
     sbspawnClass = new StringBuilder(spawnClass, 1024);
StringBuilder sbspawnDataBlock = null;
if (spawnDataBlock != null)
     sbspawnDataBlock = new StringBuilder(spawnDataBlock, 1024);
StringBuilder sbspawnName = null;
if (spawnName != null)
     sbspawnName = new StringBuilder(spawnName, 1024);
StringBuilder sbspawnProperties = null;
if (spawnProperties != null)
     sbspawnProperties = new StringBuilder(spawnProperties, 1024);
StringBuilder sbspawnScript = null;
if (spawnScript != null)
     sbspawnScript = new StringBuilder(spawnScript, 1024);
StringBuilder sbmodelName = null;
if (modelName != null)
     sbmodelName = new StringBuilder(modelName, 1024);

return  SafeNativeMethods.mwle_fn_spawnObject(sbspawnClass, sbspawnDataBlock, sbspawnName, sbspawnProperties, sbspawnScript, sbmodelName);
}
/// <summary>
/// ([string additionalProps]) Spawns the object based on the SpawnSphere's 
///    class, datablock, properties, and script settings. Allows you to pass in 
///    extra properties.
///    @hide )
/// 
/// </summary>

public int fn_SpawnSphere_spawnObject (string spawnsphere, string additionalProps)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_SpawnSphere_spawnObject'" + string.Format("\"{0}\" \"{1}\" ",spawnsphere,additionalProps));
StringBuilder sbspawnsphere = null;
if (spawnsphere != null)
     sbspawnsphere = new StringBuilder(spawnsphere, 1024);
StringBuilder sbadditionalProps = null;
if (additionalProps != null)
     sbadditionalProps = new StringBuilder(additionalProps, 1024);

return  SafeNativeMethods.mwle_fn_SpawnSphere_spawnObject(sbspawnsphere, sbadditionalProps);
}
/// <summary>
/// Activates the shape replicator.
/// 													@tsexample
/// 														// Call the function
/// 														StartClientReplication()
/// 													@endtsexample
/// 													@ingroup Foliage
/// 					)
/// 
/// </summary>

public void fn_StartClientReplication ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_StartClientReplication'");


SafeNativeMethods.mwle_fn_StartClientReplication();
}
/// <summary>
/// @brief Start watching resources for file changes
///    Typically this is called during initializeCore().
///    @see stopFileChangeNotifications()
/// 	@ingroup FileSystem)
/// 
/// </summary>

public void fn_startFileChangeNotifications ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_startFileChangeNotifications'");


SafeNativeMethods.mwle_fn_startFileChangeNotifications();
}
/// <summary>
/// Activates the foliage replicator.
/// 													@tsexample
/// 														// Call the function
/// 														StartFoliageReplication();
/// 													@endtsexample
/// 													@ingroup Foliage)
/// 
/// </summary>

public void fn_StartFoliageReplication ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_StartFoliageReplication'");


SafeNativeMethods.mwle_fn_StartFoliageReplication();
}
/// <summary>
/// startHeartbeat(...); )
/// 
/// </summary>

public void fn_startHeartbeat ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_startHeartbeat'");


SafeNativeMethods.mwle_fn_startHeartbeat();
}
/// <summary>
/// startPrecisionTimer() - Create and start a high resolution platform timer. Returns the timer id. )
/// 
/// </summary>

public int fn_startPrecisionTimer ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_startPrecisionTimer'");


return  SafeNativeMethods.mwle_fn_startPrecisionTimer();
}
/// <summary>
/// Test whether the given string begins with the given prefix.
///    @param str The string to test.
///    @param prefix The potential prefix of @a str.
///    @param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will 
///       not be taken into account.
///    @return True if the first characters in @a str match the complete contents of @a prefix; false otherwise.
///    @tsexample
///    startsWith( \"TEST123\", \"test\" ) // Returns true.
///    @endtsexample
///    @see endsWith
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_startsWith (string str, string prefix, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_startsWith'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,prefix,caseSensitive));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbprefix = null;
if (prefix != null)
     sbprefix = new StringBuilder(prefix, 1024);

return  SafeNativeMethods.mwle_fn_startsWith(sbstr, sbprefix, caseSensitive)>=1;
}
/// <summary>
/// THEORA, 30.0f, Point2I::Zero ),
///    Begins a video capture session.
///    @see stopVideoCapture
///    @ingroup Rendering )
/// 
/// </summary>

public void fn_startVideoCapture (string canvas, string filename, string encoder, float framerate, string resolution)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_startVideoCapture'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",canvas,filename,encoder,framerate,resolution));
StringBuilder sbcanvas = null;
if (canvas != null)
     sbcanvas = new StringBuilder(canvas, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbencoder = null;
if (encoder != null)
     sbencoder = new StringBuilder(encoder, 1024);
StringBuilder sbresolution = null;
if (resolution != null)
     sbresolution = new StringBuilder(resolution, 1024);

SafeNativeMethods.mwle_fn_startVideoCapture(sbcanvas, sbfilename, sbencoder, framerate, sbresolution);
}
/// <summary>
/// @internal)
/// 
/// </summary>

public bool fn_StaticShape_getPoweredState (string staticshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_StaticShape_getPoweredState'" + string.Format("\"{0}\" ",staticshape));
StringBuilder sbstaticshape = null;
if (staticshape != null)
     sbstaticshape = new StringBuilder(staticshape, 1024);

return  SafeNativeMethods.mwle_fn_StaticShape_getPoweredState(sbstaticshape)>=1;
}
/// <summary>
/// (bool isPowered)
/// 			  @internal)
/// 
/// </summary>

public void fn_StaticShape_setPoweredState (string staticshape, bool isPowered)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_StaticShape_setPoweredState'" + string.Format("\"{0}\" \"{1}\" ",staticshape,isPowered));
StringBuilder sbstaticshape = null;
if (staticshape != null)
     sbstaticshape = new StringBuilder(staticshape, 1024);

SafeNativeMethods.mwle_fn_StaticShape_setPoweredState(sbstaticshape, isPowered);
}
/// <summary>
/// @brief Stop watching resources for file changes
///    Typically this is called during shutdownCore().
///    @see startFileChangeNotifications()
/// 	@ingroup FileSystem)
/// 
/// </summary>

public void fn_stopFileChangeNotifications ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopFileChangeNotifications'");


SafeNativeMethods.mwle_fn_stopFileChangeNotifications();
}
/// <summary>
/// stopHeartbeat(...); )
/// 
/// </summary>

public void fn_stopHeartbeat ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopHeartbeat'");


SafeNativeMethods.mwle_fn_stopHeartbeat();
}
/// <summary>
/// stopPrecisionTimer( S32 id ) - Stop and destroy timer with the passed id.  Returns the elapsed milliseconds. )
/// 
/// </summary>

public int fn_stopPrecisionTimer (int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopPrecisionTimer'" + string.Format("\"{0}\" ",id));

return  SafeNativeMethods.mwle_fn_stopPrecisionTimer(id);
}
/// <summary>
/// ()
/// 				@brief Stops the rendering sampler
/// 				@ingroup Rendering)
/// 
/// </summary>

public void fn_stopSampling ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopSampling'");


SafeNativeMethods.mwle_fn_stopSampling();
}
/// <summary>
/// stopServerQuery(...); )
/// 
/// </summary>

public void fn_stopServerQuery ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopServerQuery'");


SafeNativeMethods.mwle_fn_stopServerQuery();
}
/// <summary>
/// Stops the video capture session.
///    @see startVideoCapture   
///    @ingroup Rendering )
/// 
/// </summary>

public void fn_stopVideoCapture ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stopVideoCapture'");


SafeNativeMethods.mwle_fn_stopVideoCapture();
}
/// <summary>
/// Return the integer character code value corresponding to the first character in the given string.
///    @param chr a (one-character) string.
///    @return the UTF32 code value for the first character in the given string.
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strasc (string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strasc'" + string.Format("\"{0}\" ",chr));
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

return  SafeNativeMethods.mwle_fn_strasc(sbchr);
}
/// <summary>
/// Find the first occurrence of the given character in @a str.
///    @param str The string to search.
///    @param chr The character to search for.  Only the first character from the string is taken.
///    @return The remainder of the input string starting with the given character or the empty string if the character could not be found.
///    @see strrchr
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strchr (string str, string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strchr'" + string.Format("\"{0}\" \"{1}\" ",str,chr));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_strchr(sbstr, sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Find the first occurrence of the given character in the given string.
///    @param str The string to search.
///    @param chr The character to look for.  Only the first character of this string will be searched for.
///    @param start The index into @a str at which to start searching for the given character.
///    @return The index of the first occurrence of @a chr in @a str or -1 if @a str does not contain the given character.
///    @tsexample
///    strchrpos( \"test\", \"s\" ) // Returns 2.
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strchrpos (string str, string chr, int start)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strchrpos'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,chr,start));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

return  SafeNativeMethods.mwle_fn_strchrpos(sbstr, sbchr, start);
}
/// <summary>
/// Compares two strings using case-b>sensitive/b> comparison.
///    @param str1 The first string.
///    @param str2 The second string.
///    @return 0 if both strings are equal, a value 0 if the first character different in str1 has a smaller character code 
///       value than the character at the same position in str2, and a value >1 otherwise.
///    @tsexample
///    if( strcmp( %var, \"foobar\" ) == 0 )
///       echo( \"%var is equal to 'foobar'\" );
///    @endtsexample
///    @see stricmp
///    @see strnatcmp
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strcmp (string str1, string str2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strcmp'" + string.Format("\"{0}\" \"{1}\" ",str1,str2));
StringBuilder sbstr1 = null;
if (str1 != null)
     sbstr1 = new StringBuilder(str1, 1024);
StringBuilder sbstr2 = null;
if (str2 != null)
     sbstr2 = new StringBuilder(str2, 1024);

return  SafeNativeMethods.mwle_fn_strcmp(sbstr1, sbstr2);
}
/// <summary>
/// Format the given value as a string using printf-style formatting.
///    @param format A printf-style format string.
///    @param value The value argument matching the given format string.
///    @tsexample
///    // Convert the given integer value to a string in a hex notation.
///    %hex = strformat( \"%x\", %value );
///    @endtsexample
///    @ingroup Strings
///    @see http://en.wikipedia.org/wiki/Printf )
/// 
/// </summary>

public string fn_strformat (string format, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strformat'" + string.Format("\"{0}\" \"{1}\" ",format,value));
var returnbuff = new StringBuilder(16384);
StringBuilder sbformat = null;
if (format != null)
     sbformat = new StringBuilder(format, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fn_strformat(sbformat, sbvalue, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Compares two strings using case-b>insensitive/b> comparison.
///    @param str1 The first string.
///    @param str2 The second string.
///    @return 0 if both strings are equal, a value 0 if the first character different in str1 has a smaller character code 
///       value than the character at the same position in str2, and a value >0 otherwise.
///    @tsexample
///    if( stricmp( \"FOObar\", \"foobar\" ) == 0 )
///       echo( \"this is always true\" );
///    @endtsexample
///    @see strcmp
///    @see strinatcmp
///    @ingroup Strings )
/// 
/// </summary>

public int fn_stricmp (string str1, string str2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stricmp'" + string.Format("\"{0}\" \"{1}\" ",str1,str2));
StringBuilder sbstr1 = null;
if (str1 != null)
     sbstr1 = new StringBuilder(str1, 1024);
StringBuilder sbstr2 = null;
if (str2 != null)
     sbstr2 = new StringBuilder(str2, 1024);

return  SafeNativeMethods.mwle_fn_stricmp(sbstr1, sbstr2);
}
/// <summary>
/// Compares two strings using \"natural order\" case-b>insensitive/b> comparison.
///    Natural order means that rather than solely comparing single character code values, strings are ordered in a 
///    natural way.  For example, the string \"hello10\" is considered greater than the string \"hello2\" even though 
///    the first numeric character in \"hello10\" actually has a smaller character value than the corresponding character 
///    in \"hello2\".  However, since 10 is greater than 2, strnatcmp will put \"hello10\" after \"hello2\".
///    @param str1 The first string.
///    @param str2 The second string.
///    @return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value 
///       0 if @a str1 comes before @a str2 in a natural order.
///    @tsexample
///    // Bubble sort 10 elements of %array using natural order
///    do
///    {
///       %swapped = false;
///       for( %i = 0; %i  10 - 1; %i ++ )
///          if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
///          {
///             %temp = %array[ %i ];
///             %array[ %i ] = %array[ %i + 1 ];
///             %array[ %i + 1 ] = %temp;
///             %swapped = true;
///          }
///    }
///    while( %swapped );
///    @endtsexample
///    @see stricmp
///    @see strnatcmp
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strinatcmp (string str1, string str2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strinatcmp'" + string.Format("\"{0}\" \"{1}\" ",str1,str2));
StringBuilder sbstr1 = null;
if (str1 != null)
     sbstr1 = new StringBuilder(str1, 1024);
StringBuilder sbstr2 = null;
if (str2 != null)
     sbstr2 = new StringBuilder(str2, 1024);

return  SafeNativeMethods.mwle_fn_strinatcmp(sbstr1, sbstr2);
}
/// <summary>
/// Remove all occurrences of characters contained in @a chars from @a str.
///    @param str The string to filter characters out from.
///    @param chars A string of characters to filter out from @a str.
///    @return A version of @a str with all occurrences of characters contained in @a chars filtered out.
///    @tsexample
///    stripChars( \"teststring\", \"se\" ); // Returns \"tttring\".
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_stripChars (string str, string chars)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stripChars'" + string.Format("\"{0}\" \"{1}\" ",str,chars));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbchars = null;
if (chars != null)
     sbchars = new StringBuilder(chars, 1024);

SafeNativeMethods.mwle_fn_stripChars(sbstr, sbchars, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Strip TorqueML control characters from the specified string, returning a 'clean' version.
/// 					 @param inString String to strip TorqueML control characters from.
/// 					 @tsexample
/// 					 // Define the string to strip TorqueML control characters from
/// 					 %string = \"font:Arial:24>How Now color:c43c12>Brown color:000000>Cow\";
/// 					 // Request the stripped version of the string
/// 					 %strippedString = StripMLControlChars(%string);
/// 					 @endtsexample
/// 					 @return Version of the inputted string with all TorqueML characters removed.
/// 					 @see References
/// 					 @ingroup GuiCore)
/// 
/// </summary>

public string fn_StripMLControlChars (string inString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_StripMLControlChars'" + string.Format("\"{0}\" ",inString));
var returnbuff = new StringBuilder(16384);
StringBuilder sbinString = null;
if (inString != null)
     sbinString = new StringBuilder(inString, 1024);

SafeNativeMethods.mwle_fn_StripMLControlChars(sbinString, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Strip a numeric suffix from the given string.
///    @param str The string from which to strip its numeric suffix.
///    @return The string @a str without its number suffix or the original string @a str if it has no such suffix.
///    @tsexample
///    stripTrailingNumber( \"test123\" ) // Returns \"test\".
///    @endtsexample
///    @see getTrailingNumber
///    @ingroup Strings )
/// 
/// </summary>

public string fn_stripTrailingNumber (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_stripTrailingNumber'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(1024);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_stripTrailingNumber(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Match a pattern against a string.
///    @param pattern The wildcard pattern to match against.  The pattern can include characters, '*' to match 
///       any number of characters and '?' to match a single character.
///    @param str The string which should be matched against @a pattern.
///    @param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against 
///       this string.  If false, differences in casing are ignored.
///    @return True if @a str matches the given @a pattern.
///    @tsexample
///    strIsMatchExpr( \"f?o*R\", \"foobar\" ) // Returns true.
///    @endtsexample
///    @see strIsMatchMultipleExpr
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_strIsMatchExpr (string pattern, string str, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strIsMatchExpr'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",pattern,str,caseSensitive));
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_strIsMatchExpr(sbpattern, sbstr, caseSensitive)>=1;
}
/// <summary>
/// Match a multiple patterns against a single string.
///    @param patterns A tab-separated list of patterns.  Each pattern can include charaters, '*' to match 
///       any number of characters and '?' to match a single character.  Each of the patterns is tried in turn.
///    @param str The string which should be matched against @a patterns.
///    @param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against 
///       this string.  If false, differences in casing are ignored.
///    @return True if @a str matches any of the given @a patterns.
///    @tsexample
///    strIsMatchMultipleExpr( \"*.cs *.gui *.mis\", \"mymission.mis\" ) // Returns true.
///    @endtsexample
///    @see strIsMatchExpr
///    @ingroup Strings )
/// 
/// </summary>

public bool fn_strIsMatchMultipleExpr (string patterns, string str, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strIsMatchMultipleExpr'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",patterns,str,caseSensitive));
StringBuilder sbpatterns = null;
if (patterns != null)
     sbpatterns = new StringBuilder(patterns, 1024);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_strIsMatchMultipleExpr(sbpatterns, sbstr, caseSensitive)>=1;
}
/// <summary>
/// Get the length of the given string in bytes.
///    @note This does b>not/b> return a true character count for strings with multi-byte characters!
///    @param str A string.
///    @return The length of the given string in bytes.
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strlen (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strlen'" + string.Format("\"{0}\" ",str));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

return  SafeNativeMethods.mwle_fn_strlen(sbstr);
}
/// <summary>
/// Return an all lower-case version of the given string.
///    @param str A string.
///    @return A version of @a str with all characters converted to lower-case.
///    @tsexample
///    strlwr( \"TesT1\" ) // Returns \"test1\"
///    @endtsexample
///    @see strupr
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strlwr (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strlwr'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_strlwr(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Compares two strings using \"natural order\" case-b>sensitive/b> comparison.
///    Natural order means that rather than solely comparing single character code values, strings are ordered in a 
///    natural way.  For example, the string \"hello10\" is considered greater than the string \"hello2\" even though 
///    the first numeric character in \"hello10\" actually has a smaller character value than the corresponding character 
///    in \"hello2\".  However, since 10 is greater than 2, strnatcmp will put \"hello10\" after \"hello2\".
///    @param str1 The first string.
///    @param str2 The second string.
///    @return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value 
///       0 if @a str1 comes before @a str2 in a natural order.
///    @tsexample
///    // Bubble sort 10 elements of %array using natural order
///    do
///    {
///       %swapped = false;
///       for( %i = 0; %i  10 - 1; %i ++ )
///          if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
///          {
///             %temp = %array[ %i ];
///             %array[ %i ] = %array[ %i + 1 ];
///             %array[ %i + 1 ] = %temp;
///             %swapped = true;
///          }
///    }
///    while( %swapped );
///    @endtsexample
///    @see strcmp
///    @see strinatcmp
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strnatcmp (string str1, string str2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strnatcmp'" + string.Format("\"{0}\" \"{1}\" ",str1,str2));
StringBuilder sbstr1 = null;
if (str1 != null)
     sbstr1 = new StringBuilder(str1, 1024);
StringBuilder sbstr2 = null;
if (str2 != null)
     sbstr2 = new StringBuilder(str2, 1024);

return  SafeNativeMethods.mwle_fn_strnatcmp(sbstr1, sbstr2);
}
/// <summary>
/// Find the start of @a needle in @a haystack searching from left to right beginning at the given offset.
///    @param haystack The string to search.
///    @param needle The string to search for.
///    @return The index at which the first occurrence of @a needle was found in @a haystack or -1 if no match was found.
///    @tsexample
///    strpos( \"b ab\", \"b\", 1 ) // Returns 3.
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strpos (string haystack, string needle, int offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strpos'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",haystack,needle,offset));
StringBuilder sbhaystack = null;
if (haystack != null)
     sbhaystack = new StringBuilder(haystack, 1024);
StringBuilder sbneedle = null;
if (needle != null)
     sbneedle = new StringBuilder(needle, 1024);

return  SafeNativeMethods.mwle_fn_strpos(sbhaystack, sbneedle, offset);
}
/// <summary>
/// Find the last occurrence of the given character in @a str.
///    @param str The string to search.
///    @param chr The character to search for.  Only the first character from the string is taken.
///    @return The remainder of the input string starting with the given character or the empty string if the character could not be found.
///    @see strchr
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strrchr (string str, string chr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strrchr'" + string.Format("\"{0}\" \"{1}\" ",str,chr));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

SafeNativeMethods.mwle_fn_strrchr(sbstr, sbchr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Find the last occurrence of the given character in the given string.
///    @param str The string to search.
///    @param chr The character to look for.  Only the first character of this string will be searched for.
///    @param start The index into @a str at which to start searching for the given character.
///    @return The index of the last occurrence of @a chr in @a str or -1 if @a str does not contain the given character.
///    @tsexample
///    strrchrpos( \"test\", \"t\" ) // Returns 3.
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strrchrpos (string str, string chr, int start)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strrchrpos'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,chr,start));
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbchr = null;
if (chr != null)
     sbchr = new StringBuilder(chr, 1024);

return  SafeNativeMethods.mwle_fn_strrchrpos(sbstr, sbchr, start);
}
/// <summary>
///  ),
///    Return a string that repeats @a str @a numTimes number of times delimiting each occurrence with @a delimiter.
///    @param str The string to repeat multiple times.
///    @param numTimes The number of times to repeat @a str in the result string.
///    @param delimiter The string to put between each repetition of @a str.
///    @return A string containing @a str repeated @a numTimes times.
///    @tsexample
///    strrepeat( \"a\", 5, \"b\" ) // Returns \"ababababa\".
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strrepeat (string str, int numTimes, string delimiter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strrepeat'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",str,numTimes,delimiter));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);
StringBuilder sbdelimiter = null;
if (delimiter != null)
     sbdelimiter = new StringBuilder(delimiter, 1024);

SafeNativeMethods.mwle_fn_strrepeat(sbstr, numTimes, sbdelimiter, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Replace all occurrences of @a from in @a source with @a to.
///    @param source The string in which to replace the occurrences of @a from.
///    @param from The string to replace in @a source.
///    @param to The string with which to replace occurrences of @from.
///    @return A string with all occurrences of @a from in @a source replaced by @a to.
///    @tsexample
///    strreplace( \"aabbccbb\", \"bb\", \"ee\" ) // Returns \"aaeeccee\".
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strreplace (string source, string from, string to)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strreplace'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",source,from,to));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsource = null;
if (source != null)
     sbsource = new StringBuilder(source, 1024);
StringBuilder sbfrom = null;
if (from != null)
     sbfrom = new StringBuilder(from, 1024);
StringBuilder sbto = null;
if (to != null)
     sbto = new StringBuilder(to, 1024);

SafeNativeMethods.mwle_fn_strreplace(sbsource, sbfrom, sbto, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Find the start of @a substring in the given @a string searching from left to right.
///    @param string The string to search.
///    @param substring The string to search for.
///    @return The index into @a string at which the first occurrence of @a substring was found or -1 if @a substring could not be found.
///    @tsexample
///    strstr( \"abcd\", \"c\" ) // Returns 2.
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public int fn_strstr (string stringx, string substring)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strstr'" + string.Format("\"{0}\" \"{1}\" ",stringx,substring));
StringBuilder sbstringx = null;
if (stringx != null)
     sbstringx = new StringBuilder(stringx, 1024);
StringBuilder sbsubstring = null;
if (substring != null)
     sbsubstring = new StringBuilder(substring, 1024);

return  SafeNativeMethods.mwle_fn_strstr(sbstringx, sbsubstring);
}
/// <summary>
/// strToPlayerName(string); )
/// 
/// </summary>

public string fn_strToPlayerName (string ptr)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strToPlayerName'" + string.Format("\"{0}\" ",ptr));
var returnbuff = new StringBuilder(16384);
StringBuilder sbptr = null;
if (ptr != null)
     sbptr = new StringBuilder(ptr, 1024);

SafeNativeMethods.mwle_fn_strToPlayerName(sbptr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return an all upper-case version of the given string.
///    @param str A string.
///    @return A version of @a str with all characters converted to upper-case.
///    @tsexample
///    strupr( \"TesT1\" ) // Returns \"TEST1\"
///    @endtsexample
///    @see strlwr
///    @ingroup Strings )
/// 
/// </summary>

public string fn_strupr (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_strupr'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_strupr(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// animate( F32 duration, F32 startAzimuth, F32 endAzimuth, F32 startElevation, F32 endElevation ))
/// 
/// </summary>

public void fn_Sun_animate (string sun, float duration, float startAzimuth, float endAzimuth, float startElevation, float endElevation)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Sun_animate'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",sun,duration,startAzimuth,endAzimuth,startElevation,endElevation));
StringBuilder sbsun = null;
if (sun != null)
     sbsun = new StringBuilder(sun, 1024);

SafeNativeMethods.mwle_fn_Sun_animate(sbsun, duration, startAzimuth, endAzimuth, startElevation, endElevation);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_Sun_apply (string sun)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_Sun_apply'" + string.Format("\"{0}\" ",sun));
StringBuilder sbsun = null;
if (sun != null)
     sbsun = new StringBuilder(sun, 1024);

SafeNativeMethods.mwle_fn_Sun_apply(sbsun);
}
/// <summary>
/// @brief Initializes and open the telnet console.
///                 @param port        Port to listen on for console connections (0 will shut down listening).
///                 @param consolePass Password for read/write access to console.
///                 @param listenPass  Password for read access to console.
///                 @param remoteEcho  [optional] Enable echoing back to the client, off by default.
/// 				@ingroup Debugging)
/// 
/// </summary>

public void fn_telnetSetParameters (int port, string consolePass, string listenPass, bool remoteEcho)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_telnetSetParameters'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",port,consolePass,listenPass,remoteEcho));
StringBuilder sbconsolePass = null;
if (consolePass != null)
     sbconsolePass = new StringBuilder(consolePass, 1024);
StringBuilder sblistenPass = null;
if (listenPass != null)
     sblistenPass = new StringBuilder(listenPass, 1024);

SafeNativeMethods.mwle_fn_telnetSetParameters(port, sbconsolePass, sblistenPass, remoteEcho);
}
/// <summary>
/// png), (string filename, [string format]) - export the terrain block's heightmap to a bitmap file (default: png) )
/// 
/// </summary>

public bool fn_TerrainBlock_exportHeightMap (string terrainblock, string fileNameStr, string format)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainBlock_exportHeightMap'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",terrainblock,fileNameStr,format));
StringBuilder sbterrainblock = null;
if (terrainblock != null)
     sbterrainblock = new StringBuilder(terrainblock, 1024);
StringBuilder sbfileNameStr = null;
if (fileNameStr != null)
     sbfileNameStr = new StringBuilder(fileNameStr, 1024);
StringBuilder sbformat = null;
if (format != null)
     sbformat = new StringBuilder(format, 1024);

return  SafeNativeMethods.mwle_fn_TerrainBlock_exportHeightMap(sbterrainblock, sbfileNameStr, sbformat)>=1;
}
/// <summary>
/// png), (string filePrefix, [string format]) - export the terrain block's layer maps to bitmap files (default: png) )
/// 
/// </summary>

public bool fn_TerrainBlock_exportLayerMaps (string terrainblock, string filePrefixStr, string format)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainBlock_exportLayerMaps'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",terrainblock,filePrefixStr,format));
StringBuilder sbterrainblock = null;
if (terrainblock != null)
     sbterrainblock = new StringBuilder(terrainblock, 1024);
StringBuilder sbfilePrefixStr = null;
if (filePrefixStr != null)
     sbfilePrefixStr = new StringBuilder(filePrefixStr, 1024);
StringBuilder sbformat = null;
if (format != null)
     sbformat = new StringBuilder(format, 1024);

return  SafeNativeMethods.mwle_fn_TerrainBlock_exportLayerMaps(sbterrainblock, sbfilePrefixStr, sbformat)>=1;
}
/// <summary>
/// ( string matName )
///    Adds a new material. )
/// 
/// </summary>

public int fn_TerrainEditor_addMaterial (string terraineditor, string matName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_addMaterial'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,matName));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbmatName = null;
if (matName != null)
     sbmatName = new StringBuilder(matName, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_addMaterial(sbterraineditor, sbmatName);
}
/// <summary>
/// ), (TerrainBlock terrain))
/// 
/// </summary>

public void fn_TerrainEditor_attachTerrain (string terraineditor, string terrain)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_attachTerrain'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,terrain));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbterrain = null;
if (terrain != null)
     sbterrain = new StringBuilder(terrain, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_attachTerrain(sbterraineditor, sbterrain);
}
/// <summary>
/// (F32 minHeight, F32 maxHeight, F32 minSlope, F32 maxSlope , F32 coverage))  
/// 
/// </summary>

public void fn_TerrainEditor_autoMaterialLayer (string terraineditor, float minHeight, float maxHeight, float minSlope, float maxSlope, float coverage)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_autoMaterialLayer'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",terraineditor,minHeight,maxHeight,minSlope,maxSlope,coverage));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_autoMaterialLayer(sbterraineditor, minHeight, maxHeight, minSlope, maxSlope, coverage);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_TerrainEditor_clearSelection (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_clearSelection'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_clearSelection(sbterraineditor);
}
/// <summary>
/// (int num))
/// 
/// </summary>

public string fn_TerrainEditor_getActionName (string terraineditor, uint index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getActionName'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getActionName(sbterraineditor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public int fn_TerrainEditor_getActiveTerrain (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getActiveTerrain'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getActiveTerrain(sbterraineditor);
}
/// <summary>
/// Returns a Point2I.)
/// 
/// </summary>

public string fn_TerrainEditor_getBrushPos (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getBrushPos'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getBrushPos(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ())
/// 
/// </summary>

public float fn_TerrainEditor_getBrushPressure (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getBrushPressure'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getBrushPressure(sbterraineditor);
}
/// <summary>
/// ())
/// 
/// </summary>

public string fn_TerrainEditor_getBrushSize (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getBrushSize'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getBrushSize(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ())
/// 
/// </summary>

public float fn_TerrainEditor_getBrushSoftness (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getBrushSoftness'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getBrushSoftness(sbterraineditor);
}
/// <summary>
/// ())
/// 
/// </summary>

public string fn_TerrainEditor_getBrushType (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getBrushType'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getBrushType(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public string fn_TerrainEditor_getCurrentAction (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getCurrentAction'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getCurrentAction(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the current material count. )
/// 
/// </summary>

public int fn_TerrainEditor_getMaterialCount (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getMaterialCount'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getMaterialCount(sbterraineditor);
}
/// <summary>
/// ( string name ) - Returns the index of the material with the given name or -1. )
/// 
/// </summary>

public int fn_TerrainEditor_getMaterialIndex (string terraineditor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getMaterialIndex'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,name));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getMaterialIndex(sbterraineditor, sbname);
}
/// <summary>
/// ( int index ) - Returns the name of the material at the given index. )
/// 
/// </summary>

public string fn_TerrainEditor_getMaterialName (string terraineditor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getMaterialName'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getMaterialName(sbterraineditor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// () gets the list of current terrain materials.)
/// 
/// </summary>

public string fn_TerrainEditor_getMaterials (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getMaterials'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getMaterials(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public int fn_TerrainEditor_getNumActions (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getNumActions'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getNumActions(sbterraineditor);
}
/// <summary>
/// )
/// 
/// </summary>

public int fn_TerrainEditor_getNumTextures (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getNumTextures'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getNumTextures(sbterraineditor);
}
/// <summary>
/// )
/// 
/// </summary>

public float fn_TerrainEditor_getSlopeLimitMaxAngle (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getSlopeLimitMaxAngle'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getSlopeLimitMaxAngle(sbterraineditor);
}
/// <summary>
/// )
/// 
/// </summary>

public float fn_TerrainEditor_getSlopeLimitMinAngle (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getSlopeLimitMinAngle'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getSlopeLimitMinAngle(sbterraineditor);
}
/// <summary>
/// (S32 index))
/// 
/// </summary>

public int fn_TerrainEditor_getTerrainBlock (string terraineditor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getTerrainBlock'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,index));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getTerrainBlock(sbterraineditor, index);
}
/// <summary>
/// ())
/// 
/// </summary>

public int fn_TerrainEditor_getTerrainBlockCount (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getTerrainBlockCount'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getTerrainBlockCount(sbterraineditor);
}
/// <summary>
/// () gets the list of current terrain materials for all terrain blocks.)
/// 
/// </summary>

public string fn_TerrainEditor_getTerrainBlocksMaterialList (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getTerrainBlocksMaterialList'" + string.Format("\"{0}\" ",terraineditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_getTerrainBlocksMaterialList(sbterraineditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// , , ), 
///                                                                            (x/y/z) Gets the terrain block that is located under the given world point.
///                                                                            @param x/y/z The world coordinates (floating point values) you wish to query at.  
///                                                                            These can be formatted as either a string (\"x y z\") or separately as (x, y, z)
///                                                                            @return Returns the ID of the requested terrain block (0 if not found).)
/// 
/// </summary>

public int fn_TerrainEditor_getTerrainUnderWorldPoint (string terraineditor, string ptOrX, string Y, string Z)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_getTerrainUnderWorldPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",terraineditor,ptOrX,Y,Z));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbptOrX = null;
if (ptOrX != null)
     sbptOrX = new StringBuilder(ptOrX, 1024);
StringBuilder sbY = null;
if (Y != null)
     sbY = new StringBuilder(Y, 1024);
StringBuilder sbZ = null;
if (Z != null)
     sbZ = new StringBuilder(Z, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_getTerrainUnderWorldPoint(sbterraineditor, sbptOrX, sbY, sbZ);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_TerrainEditor_markEmptySquares (string terraineditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_markEmptySquares'" + string.Format("\"{0}\" ",terraineditor));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_markEmptySquares(sbterraineditor);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_TerrainEditor_mirrorTerrain (string terraineditor, int mirrorIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_mirrorTerrain'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,mirrorIndex));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_mirrorTerrain(sbterraineditor, mirrorIndex);
}
/// <summary>
/// ), (string action=NULL))
/// 
/// </summary>

public void fn_TerrainEditor_processAction (string terraineditor, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_processAction'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,action));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_processAction(sbterraineditor, sbaction);
}
/// <summary>
/// ( int index ) - Remove the material at the given index. )
/// 
/// </summary>

public void fn_TerrainEditor_removeMaterial (string terraineditor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_removeMaterial'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,index));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_removeMaterial(sbterraineditor, index);
}
/// <summary>
/// ( int index, int order ) 
///   - Reorder material at the given index to the new position, changing the order in which it is rendered / blended. )
/// 
/// </summary>

public void fn_TerrainEditor_reorderMaterial (string terraineditor, int index, int orderPos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_reorderMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",terraineditor,index,orderPos));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_reorderMaterial(sbterraineditor, index, orderPos);
}
/// <summary>
/// (bool clear))
/// 
/// </summary>

public void fn_TerrainEditor_resetSelWeights (string terraineditor, bool clear)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_resetSelWeights'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,clear));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_resetSelWeights(sbterraineditor, clear);
}
/// <summary>
/// (string action_name))
/// 
/// </summary>

public void fn_TerrainEditor_setAction (string terraineditor, string action_name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setAction'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,action_name));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbaction_name = null;
if (action_name != null)
     sbaction_name = new StringBuilder(action_name, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setAction(sbterraineditor, sbaction_name);
}
/// <summary>
/// Location)
/// 
/// </summary>

public void fn_TerrainEditor_setBrushPos (string terraineditor, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setBrushPos'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,pos));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setBrushPos(sbterraineditor, sbpos);
}
/// <summary>
/// (float pressure))
/// 
/// </summary>

public void fn_TerrainEditor_setBrushPressure (string terraineditor, float pressure)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setBrushPressure'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,pressure));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setBrushPressure(sbterraineditor, pressure);
}
/// <summary>
/// (int w [, int h]))
/// 
/// </summary>

public void fn_TerrainEditor_setBrushSize (string terraineditor, int w, int h)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setBrushSize'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",terraineditor,w,h));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setBrushSize(sbterraineditor, w, h);
}
/// <summary>
/// (float softness))
/// 
/// </summary>

public void fn_TerrainEditor_setBrushSoftness (string terraineditor, float softness)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setBrushSoftness'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,softness));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setBrushSoftness(sbterraineditor, softness);
}
/// <summary>
/// (string type)
///               One of box, ellipse, selection.)
/// 
/// </summary>

public void fn_TerrainEditor_setBrushType (string terraineditor, string type)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setBrushType'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,type));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setBrushType(sbterraineditor, sbtype);
}
/// <summary>
/// )
/// 
/// </summary>

public float fn_TerrainEditor_setSlopeLimitMaxAngle (string terraineditor, float angle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setSlopeLimitMaxAngle'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,angle));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_setSlopeLimitMaxAngle(sbterraineditor, angle);
}
/// <summary>
/// )
/// 
/// </summary>

public float fn_TerrainEditor_setSlopeLimitMinAngle (string terraineditor, float angle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setSlopeLimitMinAngle'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,angle));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_setSlopeLimitMinAngle(sbterraineditor, angle);
}
/// <summary>
/// (bool overlayEnable) - sets the terraformer current heightmap to draw as an overlay over the current terrain.)
/// 
/// </summary>

public void fn_TerrainEditor_setTerraformOverlay (string terraineditor, bool overlayEnable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_setTerraformOverlay'" + string.Format("\"{0}\" \"{1}\" ",terraineditor,overlayEnable));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);

SafeNativeMethods.mwle_fn_TerrainEditor_setTerraformOverlay(sbterraineditor, overlayEnable);
}
/// <summary>
/// ( int index, string matName )
///    Changes the material name at the index. )
/// 
/// </summary>

public bool fn_TerrainEditor_updateMaterial (string terraineditor, uint index, string matName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainEditor_updateMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",terraineditor,index,matName));
StringBuilder sbterraineditor = null;
if (terraineditor != null)
     sbterraineditor = new StringBuilder(terraineditor, 1024);
StringBuilder sbmatName = null;
if (matName != null)
     sbmatName = new StringBuilder(matName, 1024);

return  SafeNativeMethods.mwle_fn_TerrainEditor_updateMaterial(sbterraineditor, index, sbmatName)>=1;
}
/// <summary>
/// ( TerrainBlock obj, F32 factor, U32 steps ))
/// 
/// </summary>

public void fn_TerrainSmoothAction_smooth (string terrainsmoothaction, string terrain, float factor, uint steps)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainSmoothAction_smooth'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",terrainsmoothaction,terrain,factor,steps));
StringBuilder sbterrainsmoothaction = null;
if (terrainsmoothaction != null)
     sbterrainsmoothaction = new StringBuilder(terrainsmoothaction, 1024);
StringBuilder sbterrain = null;
if (terrain != null)
     sbterrain = new StringBuilder(terrain, 1024);

SafeNativeMethods.mwle_fn_TerrainSmoothAction_smooth(sbterrainsmoothaction, sbterrain, factor, steps);
}
/// <summary>
/// () )
/// 
/// </summary>

public void fn_TerrainSolderEdgesAction_solder (string terrainsolderedgesaction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TerrainSolderEdgesAction_solder'" + string.Format("\"{0}\" ",terrainsolderedgesaction));
StringBuilder sbterrainsolderedgesaction = null;
if (terrainsolderedgesaction != null)
     sbterrainsolderedgesaction = new StringBuilder(terrainsolderedgesaction, 1024);

SafeNativeMethods.mwle_fn_TerrainSolderEdgesAction_solder(sbterrainsolderedgesaction);
}
/// <summary>
/// testBridge(arg1, arg2, arg3))
/// 
/// </summary>

public string fn_testJavaScriptBridge (string arg1, string arg2, string arg3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_testJavaScriptBridge'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arg1,arg2,arg3));
var returnbuff = new StringBuilder(16384);
StringBuilder sbarg1 = null;
if (arg1 != null)
     sbarg1 = new StringBuilder(arg1, 1024);
StringBuilder sbarg2 = null;
if (arg2 != null)
     sbarg2 = new StringBuilder(arg2, 1024);
StringBuilder sbarg3 = null;
if (arg3 != null)
     sbarg3 = new StringBuilder(arg3, 1024);

SafeNativeMethods.mwle_fn_testJavaScriptBridge(sbarg1, sbarg2, sbarg3, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Pause playback of the video. )
/// 
/// </summary>

public void fn_TheoraTextureObject_pause (string theoratextureobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TheoraTextureObject_pause'" + string.Format("\"{0}\" ",theoratextureobject));
StringBuilder sbtheoratextureobject = null;
if (theoratextureobject != null)
     sbtheoratextureobject = new StringBuilder(theoratextureobject, 1024);

SafeNativeMethods.mwle_fn_TheoraTextureObject_pause(sbtheoratextureobject);
}
/// <summary>
/// Start playback of the video. )
/// 
/// </summary>

public void fn_TheoraTextureObject_play (string theoratextureobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TheoraTextureObject_play'" + string.Format("\"{0}\" ",theoratextureobject));
StringBuilder sbtheoratextureobject = null;
if (theoratextureobject != null)
     sbtheoratextureobject = new StringBuilder(theoratextureobject, 1024);

SafeNativeMethods.mwle_fn_TheoraTextureObject_play(sbtheoratextureobject);
}
/// <summary>
/// Stop playback of the video. )
/// 
/// </summary>

public void fn_TheoraTextureObject_stop (string theoratextureobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_TheoraTextureObject_stop'" + string.Format("\"{0}\" ",theoratextureobject));
StringBuilder sbtheoratextureobject = null;
if (theoratextureobject != null)
     sbtheoratextureobject = new StringBuilder(theoratextureobject, 1024);

SafeNativeMethods.mwle_fn_TheoraTextureObject_stop(sbtheoratextureobject);
}
/// <summary>
/// Enable or disable tracing in the script code VM.
///    When enabled, the script code runtime will trace the invocation and returns 
///    from all functions that are called and log them to the console. This is helpful in 
///    observing the flow of the script program.
///    @param enable New setting for script trace execution, on by default.
///    @ingroup Debugging )
/// 
/// </summary>

public void fn_trace (bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_trace'" + string.Format("\"{0}\" ",enable));

SafeNativeMethods.mwle_fn_trace(enable);
}
/// <summary>
/// Remove leading and trailing whitespace from the string.
///    @param str A string.
///    @return A string that is the same as @a str but with any leading (i.e. leftmost) and trailing (i.e. rightmost) whitespace removed.
///    @tsexample
///    trim( \"   string  \" ); // Returns \"string\".
///    @endtsexample
///    @ingroup Strings )
/// 
/// </summary>

public string fn_trim (string str)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_trim'" + string.Format("\"{0}\" ",str));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstr = null;
if (str != null)
     sbstr = new StringBuilder(str, 1024);

SafeNativeMethods.mwle_fn_trim(sbstr, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// tsUpdateImposterImages( bool forceupdate ))
/// 
/// </summary>

public void fn_tsUpdateImposterImages (bool forceUpdate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_tsUpdateImposterImages'" + string.Format("\"{0}\" ",forceUpdate));

SafeNativeMethods.mwle_fn_tsUpdateImposterImages(forceUpdate);
}
/// <summary>
/// ), action.addToManager([undoManager]))
/// 
/// </summary>

public void fn_UndoAction_addToManager (string undoaction, string undoManager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoAction_addToManager'" + string.Format("\"{0}\" \"{1}\" ",undoaction,undoManager));
StringBuilder sbundoaction = null;
if (undoaction != null)
     sbundoaction = new StringBuilder(undoaction, 1024);
StringBuilder sbundoManager = null;
if (undoManager != null)
     sbundoManager = new StringBuilder(undoManager, 1024);

SafeNativeMethods.mwle_fn_UndoAction_addToManager(sbundoaction, sbundoManager);
}
/// <summary>
/// () - Reo action contained in undo. )
/// 
/// </summary>

public void fn_UndoAction_redo (string undoaction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoAction_redo'" + string.Format("\"{0}\" ",undoaction));
StringBuilder sbundoaction = null;
if (undoaction != null)
     sbundoaction = new StringBuilder(undoaction, 1024);

SafeNativeMethods.mwle_fn_UndoAction_redo(sbundoaction);
}
/// <summary>
/// () - Undo action contained in undo. )
/// 
/// </summary>

public void fn_UndoAction_undo (string undoaction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoAction_undo'" + string.Format("\"{0}\" ",undoaction));
StringBuilder sbundoaction = null;
if (undoaction != null)
     sbundoaction = new StringBuilder(undoaction, 1024);

SafeNativeMethods.mwle_fn_UndoAction_undo(sbundoaction);
}
/// <summary>
/// Clears the undo manager.)
/// 
/// </summary>

public void fn_UndoManager_clearAll (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_clearAll'" + string.Format("\"{0}\" ",undomanager));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_clearAll(sbundomanager);
}
/// <summary>
/// UndoManager.getNextRedoName();)
/// 
/// </summary>

public string fn_UndoManager_getNextRedoName (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getNextRedoName'" + string.Format("\"{0}\" ",undomanager));
var returnbuff = new StringBuilder(16384);
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_getNextRedoName(sbundomanager, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// UndoManager.getNextUndoName();)
/// 
/// </summary>

public string fn_UndoManager_getNextUndoName (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getNextUndoName'" + string.Format("\"{0}\" ",undomanager));
var returnbuff = new StringBuilder(16384);
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_getNextUndoName(sbundomanager, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (index))
/// 
/// </summary>

public int fn_UndoManager_getRedoAction (string undomanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getRedoAction'" + string.Format("\"{0}\" \"{1}\" ",undomanager,index));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

return  SafeNativeMethods.mwle_fn_UndoManager_getRedoAction(sbundomanager, index);
}
/// <summary>
/// )
/// 
/// </summary>

public int fn_UndoManager_getRedoCount (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getRedoCount'" + string.Format("\"{0}\" ",undomanager));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

return  SafeNativeMethods.mwle_fn_UndoManager_getRedoCount(sbundomanager);
}
/// <summary>
/// (index))
/// 
/// </summary>

public string fn_UndoManager_getRedoName (string undomanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getRedoName'" + string.Format("\"{0}\" \"{1}\" ",undomanager,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_getRedoName(sbundomanager, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (index))
/// 
/// </summary>

public int fn_UndoManager_getUndoAction (string undomanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getUndoAction'" + string.Format("\"{0}\" \"{1}\" ",undomanager,index));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

return  SafeNativeMethods.mwle_fn_UndoManager_getUndoAction(sbundomanager, index);
}
/// <summary>
/// )
/// 
/// </summary>

public int fn_UndoManager_getUndoCount (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getUndoCount'" + string.Format("\"{0}\" ",undomanager));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

return  SafeNativeMethods.mwle_fn_UndoManager_getUndoCount(sbundomanager);
}
/// <summary>
/// (index))
/// 
/// </summary>

public string fn_UndoManager_getUndoName (string undomanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_getUndoName'" + string.Format("\"{0}\" \"{1}\" ",undomanager,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_getUndoName(sbundomanager, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( bool discard=false ) - Pop the current CompoundUndoAction off the stack. )
/// 
/// </summary>

public void fn_UndoManager_popCompound (string undomanager, bool discard)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_popCompound'" + string.Format("\"{0}\" \"{1}\" ",undomanager,discard));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_popCompound(sbundomanager, discard);
}
/// <summary>
/// \"\"), ( string name=\"\" ) - Push a CompoundUndoAction onto the compound stack for assembly. )
/// 
/// </summary>

public string fn_UndoManager_pushCompound (string undomanager, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_pushCompound'" + string.Format("\"{0}\" \"{1}\" ",undomanager,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fn_UndoManager_pushCompound(sbundomanager, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// UndoManager.redo();)
/// 
/// </summary>

public void fn_UndoManager_redo (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_redo'" + string.Format("\"{0}\" ",undomanager));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_redo(sbundomanager);
}
/// <summary>
/// UndoManager.undo();)
/// 
/// </summary>

public void fn_UndoManager_undo (string undomanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_UndoManager_undo'" + string.Format("\"{0}\" ",undomanager));
StringBuilder sbundomanager = null;
if (undomanager != null)
     sbundomanager = new StringBuilder(undomanager, 1024);

SafeNativeMethods.mwle_fn_UndoManager_undo(sbundomanager);
}
/// <summary>
/// (string queueName, string listener)
/// 				@brief Unregisters an event message
/// 				@param queueName String containing the name of queue
/// 				@param listener Name of event messenger
/// 				@ingroup Messaging)
/// 
/// </summary>

public void fn_unregisterMessageListener (string queueName, string listenerName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_unregisterMessageListener'" + string.Format("\"{0}\" \"{1}\" ",queueName,listenerName));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);
StringBuilder sblistenerName = null;
if (listenerName != null)
     sblistenerName = new StringBuilder(listenerName, 1024);

SafeNativeMethods.mwle_fn_unregisterMessageListener(sbqueueName, sblistenerName);
}
/// <summary>
/// (string queueName)
/// 				@brief Unregisters a dispatcher queue
/// 				@param queueName String containing the name of queue
/// 				@ingroup Messaging)
/// 
/// </summary>

public void fn_unregisterMessageQueue (string queueName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_unregisterMessageQueue'" + string.Format("\"{0}\" ",queueName));
StringBuilder sbqueueName = null;
if (queueName != null)
     sbqueueName = new StringBuilder(queueName, 1024);

SafeNativeMethods.mwle_fn_unregisterMessageQueue(sbqueueName);
}
/// <summary>
/// Add two vectors.
///    @param a The first vector.
///    @param b The second vector.
///    @return The vector @a a + @a b.
///    @tsexample
///       //-----------------------------------------------------------------------------
///       //
///       // VectorAdd( %a, %b );
///       //
///       // The sum of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
///       //
///       //     a + b = ( ax + bx, ay + by, az + bz )
///       //
///       //-----------------------------------------------------------------------------
///       %a = \"1 0 0\";
///       %b = \"0 1 0\";
///       // %r = \"( 1 + 0, 0 + 1, 0 + 0 )\";
///       // %r = \"1 1 0\";
///       %r = VectorAdd( %a, %b );
///    @endtsexample
///    @ingroup Vectors)
/// 
/// </summary>

public string fn_VectorAdd (string a, string b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorAdd'" + string.Format("\"{0}\" \"{1}\" ",a,b));
var returnbuff = new StringBuilder(1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

SafeNativeMethods.mwle_fn_VectorAdd(sba, sbb, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Calculcate the cross product of two vectors.
///    @param a The first vector.
///    @param b The second vector.
///    @return The cross product @a x @a b.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorCross( %a, %b );
/// 	//
/// 	// The cross product of vector a, (ax, ay, az), and vector b, (bx, by, bz), is
/// 	//
/// 	//     a x b = ( ( ay * bz ) - ( az * by ), ( az * bx ) - ( ax * bz ), ( ax * by ) - ( ay * bx ) )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%b = \"2 0 1\";
/// 
/// 	// %r = \"( ( 1 * 1 ) - ( 0 * 0 ), ( 0 * 2 ) - ( 1 * 1 ), ( 1 * 0 ) - ( 1 * 2 ) )\";
/// 	// %r = \"1 -1 -2\";
/// 	%r = VectorCross( %a, %b );
///    @endtsexample	
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorCross (string a, string b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorCross'" + string.Format("\"{0}\" \"{1}\" ",a,b));
var returnbuff = new StringBuilder(1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

SafeNativeMethods.mwle_fn_VectorCross(sba, sbb, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Compute the distance between two vectors.
///    @param a The first vector.
///    @param b The second vector.
///    @return The length( @a b - @a a ).
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorDist( %a, %b );
/// 	//
/// 	// The distance between vector a, (ax, ay, az), and vector b, (bx, by, bz), is
/// 	//
/// 	//     a -> b = ||( b - a )||
/// 	//            = ||( bx - ax, by - ay, bz - az )||
/// 	//            = mSqrt( ( bx - ax ) * ( bx - ax ) + ( by - ay ) * ( by - ay ) + ( bz - az ) * ( bz - az ) )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%b = \"2 0 1\";
/// 
/// 	// %r = mSqrt( ( 2 - 1 ) * ( 2 - 1) + ( 0 - 1 ) * ( 0 - 1 ) + ( 1 - 0 ) * ( 1 - 0 ) );
/// 	// %r = mSqrt( 3 );
/// 	%r = VectorDist( %a, %b );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public float fn_VectorDist (string a, string b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorDist'" + string.Format("\"{0}\" \"{1}\" ",a,b));
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

return  SafeNativeMethods.mwle_fn_VectorDist(sba, sbb);
}
/// <summary>
/// Compute the dot product of two vectors.
///    @param a The first vector.
///    @param b The second vector.
///    @return The dot product @a a * @a b.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorDot( %a, %b );
/// 	//
/// 	// The dot product between vector a, (ax, ay, az), and vector b, (bx, by, bz), is:
/// 	//
/// 	//     a . b = ( ax * bx + ay * by + az * bz )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%b = \"2 0 1\";
/// 
/// 	// %r = \"( 1 * 2 + 1 * 0 + 0 * 1 )\";
/// 	// %r = 2;
/// 	%r = VectorDot( %a, %b );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public float fn_VectorDot (string a, string b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorDot'" + string.Format("\"{0}\" \"{1}\" ",a,b));
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

return  SafeNativeMethods.mwle_fn_VectorDot(sba, sbb);
}
/// <summary>
/// Calculate the magnitude of the given vector.
///    @param v A vector.
///    @return The length of vector @a v.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorLen( %a );
/// 	//
/// 	// The length or magnitude of  vector a, (ax, ay, az), is:
/// 	//
/// 	//     ||a|| = Sqrt( ax * ax + ay * ay + az * az )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 
/// 	// %r = mSqrt( 1 * 1 + 1 * 1 + 0 * 0 );
/// 	// %r = mSqrt( 2 );
/// 	// %r = 1.414;
/// 	%r = VectorLen( %a );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public float fn_VectorLen (string v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorLen'" + string.Format("\"{0}\" ",v));
StringBuilder sbv = null;
if (v != null)
     sbv = new StringBuilder(v, 1024);

return  SafeNativeMethods.mwle_fn_VectorLen(sbv);
}
/// <summary>
/// Linearly interpolate between two vectors by @a t.
///    @param a Vector to start interpolation from.
///    @param b Vector to interpolate to.
///    @param t Interpolation factor (0-1).  At zero, @a a is returned and at one, @a b is returned.  In between, an interpolated vector 
///       between @a a and @a b is returned.
///    @return An interpolated vector between @a a and @a b.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorLerp( %a, %b );
/// 	//
/// 	// The point between vector a, (ax, ay, az), and vector b, (bx, by, bz), which is
/// 	// weighted by the interpolation factor, t, is
/// 	//
/// 	//     r = a + t * ( b - a )
/// 	//       = ( ax + t * ( bx - ax ), ay + t * ( by - ay ), az + t * ( bz - az ) )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%b = \"2 0 1\";
/// 	%v = \"0.25\";
/// 
/// 	// %r = \"( 1 + 0.25 * ( 2 - 1 ), 1 + 0.25 * ( 0 - 1 ), 0 + 0.25 * ( 1 - 0 ) )\";
/// 	// %r = \"1.25 0.75 0.25\";
/// 	%r = VectorLerp( %a, %b );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorLerp (string a, string b, float t)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorLerp'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",a,b,t));
var returnbuff = new StringBuilder(1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

SafeNativeMethods.mwle_fn_VectorLerp(sba, sbb, t, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Brings a vector into its unit form, i.e. such that it has the magnitute 1.
///    @param v The vector to normalize.
///    @return The vector @a v scaled to length 1.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorNormalize( %a );
/// 	//
/// 	// The normalized vector a, (ax, ay, az), is:
/// 	//
/// 	//     a^ = a / ||a||
/// 	//        = ( ax / ||a||, ay / ||a||, az / ||a|| )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%l = 1.414;
/// 
/// 	// %r = \"( 1 / 1.141, 1 / 1.141, 0 / 1.141 )\";
/// 	// %r = \"0.707 0.707 0\";
/// 	%r = VectorNormalize( %a );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorNormalize (string v)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorNormalize'" + string.Format("\"{0}\" ",v));
var returnbuff = new StringBuilder(1024);
StringBuilder sbv = null;
if (v != null)
     sbv = new StringBuilder(v, 1024);

SafeNativeMethods.mwle_fn_VectorNormalize(sbv, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Create an orthogonal basis from the given vector.
///    @param aaf The vector to create the orthogonal basis from.
///    @return A matrix representing the orthogonal basis.
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorOrthoBasis (string aa)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorOrthoBasis'" + string.Format("\"{0}\" ",aa));
var returnbuff = new StringBuilder(1024);
StringBuilder sbaa = null;
if (aa != null)
     sbaa = new StringBuilder(aa, 1024);

SafeNativeMethods.mwle_fn_VectorOrthoBasis(sbaa, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// (Vector3F, float) rotate a vector in 2d)
/// 
/// </summary>

public string fn_VectorRot (string v, float angle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorRot'" + string.Format("\"{0}\" \"{1}\" ",v,angle));
var returnbuff = new StringBuilder(16384);
StringBuilder sbv = null;
if (v != null)
     sbv = new StringBuilder(v, 1024);

SafeNativeMethods.mwle_fn_VectorRot(sbv, angle, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Scales a vector by a scalar.
///    @param a The vector to scale.
///    @param scalar The scale factor.
///    @return The vector @a a * @a scalar.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorScale( %a, %v );
/// 	//
/// 	// Scaling vector a, (ax, ay, az), but the scalar, v, is:
/// 	//
/// 	//     a * v = ( ax * v, ay * v, az * v )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 1 0\";
/// 	%v = \"2\";
/// 
/// 	// %r = \"( 1 * 2, 1 * 2, 0 * 2 )\";
/// 	// %r = \"2 2 0\";
/// 	%r = VectorScale( %a, %v );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorScale (string a, float scalar)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorScale'" + string.Format("\"{0}\" \"{1}\" ",a,scalar));
var returnbuff = new StringBuilder(1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);

SafeNativeMethods.mwle_fn_VectorScale(sba, scalar, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Subtract two vectors.
///    @param a The first vector.
///    @param b The second vector.
///    @return The vector @a a - @a b.
///    @tsexample
/// 	//-----------------------------------------------------------------------------
/// 	//
/// 	// VectorSub( %a, %b );
/// 	//
/// 	// The difference of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
/// 	//
/// 	//     a - b = ( ax - bx, ay - by, az - bz )
/// 	//
/// 	//-----------------------------------------------------------------------------
/// 
/// 	%a = \"1 0 0\";
/// 	%b = \"0 1 0\";
/// 
/// 	// %r = \"( 1 - 0, 0 - 1, 0 - 0 )\";
/// 	// %r = \"1 -1 0\";
/// 	%r = VectorSub( %a, %b );
///    @endtsexample
///    @ingroup Vectors )
/// 
/// </summary>

public string fn_VectorSub (string a, string b)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_VectorSub'" + string.Format("\"{0}\" \"{1}\" ",a,b));
var returnbuff = new StringBuilder(1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);

SafeNativeMethods.mwle_fn_VectorSub(sba, sbb, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Update all NavMesh tiles that intersect the given object's world box.)
/// 
/// </summary>

public void fn_WalkaboutUpdateAll (int objid, bool remove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WalkaboutUpdateAll'" + string.Format("\"{0}\" \"{1}\" ",objid,remove));

SafeNativeMethods.mwle_fn_WalkaboutUpdateAll(objid, remove);
}
/// <summary>
/// @brief Update all tiles in a given NavMesh that intersect the given object's world box.)
/// 
/// </summary>

public void fn_WalkaboutUpdateMesh (int meshid, int objid, bool remove)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WalkaboutUpdateMesh'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",meshid,objid,remove));

SafeNativeMethods.mwle_fn_WalkaboutUpdateMesh(meshid, objid, remove);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_addUndoState (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_addUndoState'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_addUndoState(sbworldeditor);
}
/// <summary>
/// (int axis)
///               Align all selected objects along the given axis.)
/// 
/// </summary>

public void fn_WorldEditor_alignByAxis (string worldeditor, int boundsAxis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_alignByAxis'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,boundsAxis));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_alignByAxis(sbworldeditor, boundsAxis);
}
/// <summary>
/// (int boundsAxis)
///               Align all selected objects against the given bounds axis.)
/// 
/// </summary>

public void fn_WorldEditor_alignByBounds (string worldeditor, int boundsAxis)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_alignByBounds'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,boundsAxis));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_alignByBounds(sbworldeditor, boundsAxis);
}
/// <summary>
/// )
/// 
/// </summary>

public bool fn_WorldEditor_canPasteSelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_canPasteSelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_canPasteSelection(sbworldeditor)>=1;
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_clearIgnoreList (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_clearIgnoreList'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_clearIgnoreList(sbworldeditor);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_clearSelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_clearSelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_clearSelection(sbworldeditor);
}
/// <summary>
/// ( String path ) - Export the combined geometry of all selected objects to the specified path in collada format. )
/// 
/// </summary>

public void fn_WorldEditor_colladaExportSelection (string worldeditor, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_colladaExportSelection'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,path));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_colladaExportSelection(sbworldeditor, sbpath);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_copySelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_copySelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_copySelection(sbworldeditor);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_cutSelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_cutSelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_cutSelection(sbworldeditor);
}
/// <summary>
/// ( bool skipUndo = false ))
/// 
/// </summary>

public void fn_WorldEditor_dropSelection (string worldeditor, bool skipUndo)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_dropSelection'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,skipUndo));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_dropSelection(sbworldeditor, skipUndo);
}
/// <summary>
/// () - Replace selected Prefab objects with a SimGroup containing all children objects defined in the .prefab. )
/// 
/// </summary>

public void fn_WorldEditor_explodeSelectedPrefab (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_explodeSelectedPrefab'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_explodeSelectedPrefab(sbworldeditor);
}
/// <summary>
/// () - Return the currently active WorldEditorSelection object. )
/// 
/// </summary>

public int fn_WorldEditor_getActiveSelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getActiveSelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getActiveSelection(sbworldeditor);
}
/// <summary>
/// (int index))
/// 
/// </summary>

public int fn_WorldEditor_getSelectedObject (string worldeditor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSelectedObject'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,index));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSelectedObject(sbworldeditor, index);
}
/// <summary>
/// )
/// 
/// </summary>

public string fn_WorldEditor_getSelectionCentroid (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSelectionCentroid'" + string.Format("\"{0}\" ",worldeditor));
var returnbuff = new StringBuilder(16384);
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_getSelectionCentroid(sbworldeditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public string fn_WorldEditor_getSelectionExtent (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSelectionExtent'" + string.Format("\"{0}\" ",worldeditor));
var returnbuff = new StringBuilder(1024);
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_getSelectionExtent(sbworldeditor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public float fn_WorldEditor_getSelectionRadius (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSelectionRadius'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSelectionRadius(sbworldeditor);
}
/// <summary>
/// () - Return the number of objects currently selected in the editor.)
/// 
/// </summary>

public int fn_WorldEditor_getSelectionSize (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSelectionSize'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSelectionSize(sbworldeditor);
}
/// <summary>
/// getSoftSnap()
///               Is soft snapping always on?)
/// 
/// </summary>

public bool fn_WorldEditor_getSoftSnap (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSoftSnap'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSoftSnap(sbworldeditor)>=1;
}
/// <summary>
/// getSoftSnapBackfaceTolerance()
///               The fraction of the soft snap radius that backfaces may be included.)
/// 
/// </summary>

public float fn_WorldEditor_getSoftSnapBackfaceTolerance (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSoftSnapBackfaceTolerance'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSoftSnapBackfaceTolerance(sbworldeditor);
}
/// <summary>
/// getSoftSnapSize()
///               Get the absolute size to trigger a soft snap.)
/// 
/// </summary>

public float fn_WorldEditor_getSoftSnapSize (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_getSoftSnapSize'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fn_WorldEditor_getSoftSnapSize(sbworldeditor);
}
/// <summary>
/// (Object obj, bool hide))
/// 
/// </summary>

public void fn_WorldEditor_hideObject (string worldeditor, string obj, bool hide)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_hideObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",worldeditor,obj,hide));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_hideObject(sbworldeditor, sbobj, hide);
}
/// <summary>
/// (bool hide))
/// 
/// </summary>

public void fn_WorldEditor_hideSelection (string worldeditor, bool hide)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_hideSelection'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,hide));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_hideSelection(sbworldeditor, hide);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_invalidateSelectionCentroid (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_invalidateSelectionCentroid'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_invalidateSelectionCentroid(sbworldeditor);
}
/// <summary>
/// (bool lock))
/// 
/// </summary>

public void fn_WorldEditor_lockSelection (string worldeditor, bool lockx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_lockSelection'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,lockx));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_lockSelection(sbworldeditor, lockx);
}
/// <summary>
/// ( string filename ) - Save selected objects to a .prefab file and replace them in the level with a Prefab object. )
/// 
/// </summary>

public void fn_WorldEditor_makeSelectionPrefab (string worldeditor, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_makeSelectionPrefab'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,filename));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_makeSelectionPrefab(sbworldeditor, sbfilename);
}
/// <summary>
/// ( Object A, Object B ) )
/// 
/// </summary>

public void fn_WorldEditor_mountRelative (string worldeditor, string objA, string objB)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_mountRelative'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",worldeditor,objA,objB));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbobjA = null;
if (objA != null)
     sbobjA = new StringBuilder(objA, 1024);
StringBuilder sbobjB = null;
if (objB != null)
     sbobjB = new StringBuilder(objB, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_mountRelative(sbworldeditor, sbobjA, sbobjB);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_pasteSelection (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_pasteSelection'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_pasteSelection(sbworldeditor);
}
/// <summary>
/// ( int objID ))
/// 
/// </summary>

public void fn_WorldEditor_redirectConsole (string worldeditor, int objID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_redirectConsole'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,objID));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_redirectConsole(sbworldeditor, objID);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_resetSelectedRotation (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_resetSelectedRotation'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_resetSelectedRotation(sbworldeditor);
}
/// <summary>
/// )
/// 
/// </summary>

public void fn_WorldEditor_resetSelectedScale (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_resetSelectedScale'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_resetSelectedScale(sbworldeditor);
}
/// <summary>
/// (SimObject obj))
/// 
/// </summary>

public void fn_WorldEditor_selectObject (string worldeditor, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_selectObject'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,objName));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_selectObject(sbworldeditor, sbobjName);
}
/// <summary>
/// ( id set ) - Set the currently active WorldEditorSelection object. )
/// 
/// </summary>

public void fn_WorldEditor_setActiveSelection (string worldeditor, string selection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_setActiveSelection'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,selection));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbselection = null;
if (selection != null)
     sbselection = new StringBuilder(selection, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_setActiveSelection(sbworldeditor, sbselection);
}
/// <summary>
/// setSoftSnap(bool)
///               Allow soft snapping all of the time.)
/// 
/// </summary>

public void fn_WorldEditor_setSoftSnap (string worldeditor, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_setSoftSnap'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,enable));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_setSoftSnap(sbworldeditor, enable);
}
/// <summary>
/// setSoftSnapBackfaceTolerance(F32 with range of 0..1)
///               The fraction of the soft snap radius that backfaces may be included.)
/// 
/// </summary>

public void fn_WorldEditor_setSoftSnapBackfaceTolerance (string worldeditor, float range)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_setSoftSnapBackfaceTolerance'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,range));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_setSoftSnapBackfaceTolerance(sbworldeditor, range);
}
/// <summary>
/// setSoftSnapSize(F32)
///               Set the absolute size to trigger a soft snap.)
/// 
/// </summary>

public void fn_WorldEditor_setSoftSnapSize (string worldeditor, float size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_setSoftSnapSize'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,size));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_setSoftSnapSize(sbworldeditor, size);
}
/// <summary>
/// softSnapDebugRender(bool)
///               Toggle soft snapping debug rendering.)
/// 
/// </summary>

public void fn_WorldEditor_softSnapDebugRender (string worldeditor, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_softSnapDebugRender'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,enable));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_softSnapDebugRender(sbworldeditor, enable);
}
/// <summary>
/// softSnapRender(bool)
///               Render the soft snapping bounds.)
/// 
/// </summary>

public void fn_WorldEditor_softSnapRender (string worldeditor, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_softSnapRender'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,enable));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_softSnapRender(sbworldeditor, enable);
}
/// <summary>
/// softSnapRenderTriangle(bool)
///               Render the soft snapped triangle.)
/// 
/// </summary>

public void fn_WorldEditor_softSnapRenderTriangle (string worldeditor, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_softSnapRenderTriangle'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,enable));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_softSnapRenderTriangle(sbworldeditor, enable);
}
/// <summary>
/// softSnapSizeByBounds(bool)
///               Use selection bounds size as soft snap bounds.)
/// 
/// </summary>

public void fn_WorldEditor_softSnapSizeByBounds (string worldeditor, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_softSnapSizeByBounds'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,enable));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_softSnapSizeByBounds(sbworldeditor, enable);
}
/// <summary>
/// transformSelection(...)
///               Transform selection by given parameters.)
/// 
/// </summary>

public void fn_WorldEditor_transformSelection (string worldeditor, bool position, string point, bool relativePos, bool rotate, string rotation, bool relativeRot, bool rotLocal, int scaleType, string scale, bool sRelative, bool sLocal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_transformSelection'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" ",worldeditor,position,point,relativePos,rotate,rotation,relativeRot,rotLocal,scaleType,scale,sRelative,sLocal));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbpoint = null;
if (point != null)
     sbpoint = new StringBuilder(point, 1024);
StringBuilder sbrotation = null;
if (rotation != null)
     sbrotation = new StringBuilder(rotation, 1024);
StringBuilder sbscale = null;
if (scale != null)
     sbscale = new StringBuilder(scale, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_transformSelection(sbworldeditor, position, sbpoint, relativePos, rotate, sbrotation, relativeRot, rotLocal, scaleType, sbscale, sRelative, sLocal);
}
/// <summary>
/// (SimObject obj))
/// 
/// </summary>

public void fn_WorldEditor_unselectObject (string worldeditor, string objName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_WorldEditor_unselectObject'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,objName));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);

SafeNativeMethods.mwle_fn_WorldEditor_unselectObject(sbworldeditor, sbobjName);
}
/// <summary>
/// Force all cached fonts to serialize themselves to the cache.
///    @ingroup Font )
/// 
/// </summary>

public void fn_writeFontCache ()
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fn_writeFontCache'");


SafeNativeMethods.mwle_fn_writeFontCache();
}
/// <summary>
/// ( ActionMap, bind, bool, 5, 10, actionMap.bind( device, action, [modifier spec, mod...], command ) 
/// 			  @hide)
/// 
/// </summary>

public bool fnActionMap_bind (string actionmap, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_bind'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" ",actionmap,a2,a3,a4,a5,a6,a7,a8,a9));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);

return  SafeNativeMethods.mwle_fnActionMap_bind(sbactionmap, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9)>=1;
}
/// <summary>
///  ),
///     @brief Associates a make command and optional break command to a specified input device action.
///     Must include parenthesis and semicolon in the make and break command strings.
///     @param device The device to bind to. Can be a keyboard, mouse, joystick or gamepad.
///     @param action The device action to bind to. The action is dependant upon the device. Specify a key for keyboards.
///     @param makeCmd The command to execute when the device/action is made.
///     @param breakCmd [optional] The command to execute when the device or action is unmade.
///     @return True the bind was successful, false if the device was unknown or description failed.
/// 	@tsexample
/// 	// Print to the console when the spacebar is pressed
/// 	function onSpaceDown()
/// 	{
/// 	   echo(\"Space bar down!\");
/// 	}
/// 	// Print to the console when the spacebar is released
/// 	function onSpaceUp()
/// 	{
/// 	   echo(\"Space bar up!\");
/// 	}
///    // Bind the commands onSpaceDown() and onSpaceUp() to spacebar events
/// 	moveMap.bindCmd(keyboard, \"space\", \"onSpaceDown();\", \"onSpaceUp();\");
/// 	@endtsexample)
/// 
/// </summary>

public bool fnActionMap_bindCmd (string actionmap, string device, string action, string makeCmd, string breakCmd)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_bindCmd'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",actionmap,device,action,makeCmd,breakCmd));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);
StringBuilder sbmakeCmd = null;
if (makeCmd != null)
     sbmakeCmd = new StringBuilder(makeCmd, 1024);
StringBuilder sbbreakCmd = null;
if (breakCmd != null)
     sbbreakCmd = new StringBuilder(breakCmd, 1024);

return  SafeNativeMethods.mwle_fnActionMap_bindCmd(sbactionmap, sbdevice, sbaction, sbmakeCmd, sbbreakCmd)>=1;
}
/// <summary>
/// ( ActionMap, bindObj, bool, 6, 11, (device, action, [modifier spec, mod...], command, object)
/// 			  @hide)
/// 
/// </summary>

public bool fnActionMap_bindObj (string actionmap, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_bindObj'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" ",actionmap,a2,a3,a4,a5,a6,a7,a8,a9,a10));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);

return  SafeNativeMethods.mwle_fnActionMap_bindObj(sbactionmap, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10)>=1;
}
/// <summary>
/// @brief Gets the ActionMap binding for the specified command.
///    Use getField() on the return value to get the device and action of the binding.
///    @param command The function to search bindings for.
///    @return The binding against the specified command. Returns an empty string(\"\") 
///    if a binding wasn't found.
/// 	@tsexample
/// 	// Find what the function \"jump()\" is bound to in moveMap
/// 	%bind = moveMap.getBinding( \"jump\" );
/// 	if ( %bind !$= \"\" )
/// 	{
/// 	// Find out what device is used in the binding
/// 		%device = getField( %bind, 0 );
/// 	// Find out what action (such as a key) is used in the binding
/// 		%action = getField( %bind, 1 );
/// 	}
/// 	@endtsexample
///    @see getField)
/// 
/// </summary>

public string fnActionMap_getBinding (string actionmap, string command)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_getBinding'" + string.Format("\"{0}\" \"{1}\" ",actionmap,command));
var returnbuff = new StringBuilder(16384);
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbcommand = null;
if (command != null)
     sbcommand = new StringBuilder(command, 1024);

SafeNativeMethods.mwle_fnActionMap_getBinding(sbactionmap, sbcommand, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets ActionMap command for the device and action.
///    @param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
///    @param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
///    @return The command against the specified device and action.
/// 	@tsexample
/// 	// Find what function is bound to a device\'s action
/// 	// In this example, \"jump()\" was assigned to the space key in another script
/// 	%command = moveMap.getCommand(\"keyboard\", \"space\");
/// 	// Should print \"jump\" in the console
/// 	echo(%command)
/// 	@endtsexample)
/// 
/// </summary>

public string fnActionMap_getCommand (string actionmap, string device, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_getCommand'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,device,action));
var returnbuff = new StringBuilder(16384);
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

SafeNativeMethods.mwle_fnActionMap_getCommand(sbactionmap, sbdevice, sbaction, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the Dead zone for the specified device and action.
///    @param device The device that was bound.  Can be a keyboard, mouse, joystick or a gamepad.
///    @param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
///    @return The dead zone for the specified device and action. Returns \"0 0\" if there is no dead zone  
///    or an empty string(\"\") if the mapping was not found.
/// 	@tsexample
/// 	%deadZone = moveMap.getDeadZone( \"gamepad\", \"thumbrx\");
/// 	@endtsexample)
/// 
/// </summary>

public string fnActionMap_getDeadZone (string actionmap, string device, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_getDeadZone'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,device,action));
var returnbuff = new StringBuilder(16384);
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

SafeNativeMethods.mwle_fnActionMap_getDeadZone(sbactionmap, sbdevice, sbaction, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get any scaling on the specified device and action.
///    @param device The device that was bound. Can be keyboard, mouse, joystick or gamepad.
///    @param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
///    @return Any scaling applied to the specified device and action.
/// 	@tsexample
/// 	%scale = %moveMap.getScale( \"gamepad\", \"thumbrx\");
/// 	@endtsexample)
/// 
/// </summary>

public float fnActionMap_getScale (string actionmap, string device, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_getScale'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,device,action));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

return  SafeNativeMethods.mwle_fnActionMap_getScale(sbactionmap, sbdevice, sbaction);
}
/// <summary>
/// @brief Determines if the specified device and action is inverted.
///    Should only be used for scrolling devices or gamepad/joystick axes.
///    @param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
///    @param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
///    @return True if the specified device and action is inverted.
/// 	@tsexample
///    %if ( moveMap.isInverted( \"mouse\", \"xaxis\"))
///       echo(\"Mouse's xAxis is inverted\");
/// 	@endtsexample)
/// 
/// </summary>

public bool fnActionMap_isInverted (string actionmap, string device, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_isInverted'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,device,action));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

return  SafeNativeMethods.mwle_fnActionMap_isInverted(sbactionmap, sbdevice, sbaction)>=1;
}
/// <summary>
/// @brief Pop the ActionMap off the %ActionMap stack.
///    Deactivates an %ActionMap and removes it from the @ActionMap stack.
/// 	@tsexample
/// 	// Deactivate moveMap
/// 	moveMap.pop();
/// 	@endtsexample
///    @see ActionMap)
/// 
/// </summary>

public void fnActionMap_pop (string actionmap)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_pop'" + string.Format("\"{0}\" ",actionmap));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);

SafeNativeMethods.mwle_fnActionMap_pop(sbactionmap);
}
/// <summary>
/// @brief Push the ActionMap onto the %ActionMap stack.
///    Activates an ActionMap and placees it at the top of the ActionMap stack.
/// 	@tsexample
/// 	// Make moveMap the active action map
/// 	moveMap.push();
/// 	@endtsexample
///    @see ActionMap)
/// 
/// </summary>

public void fnActionMap_push (string actionmap)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_push'" + string.Format("\"{0}\" ",actionmap));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);

SafeNativeMethods.mwle_fnActionMap_push(sbactionmap);
}
/// <summary>
/// @brief Saves the ActionMap to a file or dumps it to the console.
///    @param fileName The file path to save the ActionMap to. If a filename is not specified 
///     the ActionMap will be dumped to the console.
///    @param append Whether to write the ActionMap at the end of the file or overwrite it.
/// 	@tsexample
/// 	// Write out the actionmap into the config.cs file
///    moveMap.save( \"scripts/client/config.cs\" );
/// 	@endtsexample)
/// 
/// </summary>

public void fnActionMap_save (string actionmap, string fileName, bool append)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_save'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,fileName,append));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fnActionMap_save(sbactionmap, sbfileName, append);
}
/// <summary>
/// @brief Removes the binding on an input device and action.
///    @param device The device to unbind from. Can be a keyboard, mouse, joystick or a gamepad.
///    @param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
///    @return True if the unbind was successful, false if the device was unknown or description failed.
/// 	@tsexample
/// 	moveMap.unbind(\"keyboard\", \"space\");
/// 	@endtsexample)
/// 
/// </summary>

public bool fnActionMap_unbind (string actionmap, string device, string action)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_unbind'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",actionmap,device,action));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);

return  SafeNativeMethods.mwle_fnActionMap_unbind(sbactionmap, sbdevice, sbaction)>=1;
}
/// <summary>
/// @brief Remove any object-binding on an input device and action.
///    @param device The device to bind to.  Can be keyboard, mouse, joystick or gamepad.
///    @param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
///    @param obj The object to perform unbind against.
///    @return True if the unbind was successful, false if the device was unknown or description failed.
/// 	@tsexample
///    moveMap.unbindObj(\"keyboard\", \"numpad1\", \"rangeChange\", %player);
///    @endtsexample)
/// 
/// </summary>

public bool fnActionMap_unbindObj (string actionmap, string device, string action, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnActionMap_unbindObj'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",actionmap,device,action,obj));
StringBuilder sbactionmap = null;
if (actionmap != null)
     sbactionmap = new StringBuilder(actionmap, 1024);
StringBuilder sbdevice = null;
if (device != null)
     sbdevice = new StringBuilder(device, 1024);
StringBuilder sbaction = null;
if (action != null)
     sbaction = new StringBuilder(action, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnActionMap_unbindObj(sbactionmap, sbdevice, sbaction, sbobj)>=1;
}
/// <summary>
/// )
/// 	
/// </summary>

public void fnAIPlayer_AISearchSimSet (string aiplayer, float fOV, float farDist, string ObjToSearch, string result)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_AISearchSimSet'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",aiplayer,fOV,farDist,ObjToSearch,result));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbObjToSearch = null;
if (ObjToSearch != null)
     sbObjToSearch = new StringBuilder(ObjToSearch, 1024);
StringBuilder sbresult = null;
if (result != null)
     sbresult = new StringBuilder(result, 1024);

SafeNativeMethods.mwle_fnAIPlayer_AISearchSimSet(sbaiplayer, fOV, farDist, sbObjToSearch, sbresult);
}
/// <summary>
/// @brief Check whether an object is within a specified veiw cone.
///    @obj Object to check. (If blank, it will check the current target).
///    @fov view angle in degrees.(Defaults to 45)
///    @checkEnabled check whether the object can take damage and if so is still alive.(Defaults to false))
/// 
/// </summary>

public bool fnAIPlayer_checkInFoV (string aiplayer, string obj, float fov, bool checkEnabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_checkInFoV'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",aiplayer,obj,fov,checkEnabled));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_checkInFoV(sbaiplayer, sbobj, fov, checkEnabled)>=1;
}
/// <summary>
/// @brief Check whether an object is in line of sight.
///    @obj Object to check. (If blank, it will check the current target).
///    @useMuzzle Use muzzle position. Otherwise use eye position. (defaults to false).
///    @checkEnabled check whether the object can take damage and if so is still alive.(Defaults to false))
/// 
/// </summary>

public bool fnAIPlayer_checkInLos (string aiplayer, string obj, bool useMuzzle, bool checkEnabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_checkInLos'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",aiplayer,obj,useMuzzle,checkEnabled));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_checkInLos(sbaiplayer, sbobj, useMuzzle, checkEnabled)>=1;
}
/// <summary>
/// @brief Use this to stop aiming at an object or a point.
///    
///    @see setAimLocation()
///    @see setAimObject())
/// 
/// </summary>

public void fnAIPlayer_clearAim (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_clearAim'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_clearAim(sbaiplayer);
}
/// <summary>
/// @brief Tells the AI to find cover nearby.
/// 
///    @param from   Location to find cover from (i.e., enemy position).
///    @param radius Distance to search for cover.
///    @return Cover point ID if cover was found, -1 otherwise.)
/// 
/// </summary>

public int fnAIPlayer_findCover (string aiplayer, string from, float radius)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_findCover'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiplayer,from,radius));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbfrom = null;
if (from != null)
     sbfrom = new StringBuilder(from, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_findCover(sbaiplayer, sbfrom, radius);
}
/// <summary>
/// @brief Get the NavMesh object this AIPlayer is currently using.
/// 
///    @return The ID of the NavPath object this character is using for 
///    pathfinding. This is determined by the character's location, 
///    navigation type and other factors. Returns -1 if no NavMesh is 
///    found.)
/// 
/// </summary>

public int fnAIPlayer_findNavMesh (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_findNavMesh'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_findNavMesh(sbaiplayer);
}
/// <summary>
/// @brief Tell the AIPlayer to follow a path.
/// 
///    @param obj ID of a NavPath object for the character to follow.)
/// 
/// </summary>

public void fnAIPlayer_followNavPath (string aiplayer, uint obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_followNavPath'" + string.Format("\"{0}\" \"{1}\" ",aiplayer,obj));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_followNavPath(sbaiplayer, obj);
}
/// <summary>
/// @brief Tell the AIPlayer to follow another object.
/// 
///    @param obj ID of the object to follow.
///    @param radius Maximum distance we let the target escape to.)
/// 
/// </summary>

public void fnAIPlayer_followObject (string aiplayer, uint obj, float radius)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_followObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiplayer,obj,radius));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_followObject(sbaiplayer, obj, radius);
}
/// <summary>
/// @brief Returns the point the AIPlayer is aiming at.
/// 
///    This will reflect the position set by setAimLocation(), 
///    or the position of the object that the bot is now aiming at.  
///    If the bot is not aiming at anything, this value will 
///    change to whatever point the bot's current line-of-sight intercepts.
/// 
///    @return World space coordinates of the object AI is aiming at. Formatted as \"X Y Z\".
///    
///    @see setAimLocation()
///    @see setAimObject())
/// 
/// </summary>

public string fnAIPlayer_getAimLocation (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getAimLocation'" + string.Format("\"{0}\" ",aiplayer));
var returnbuff = new StringBuilder(1024);
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_getAimLocation(sbaiplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the object the AIPlayer is targeting.
/// 
///    @return Returns -1 if no object is being aimed at, 
///    or the SimObjectID of the object the AIPlayer is aiming at.
///    
///    @see setAimObject())
/// 
/// </summary>

public int fnAIPlayer_getAimObject (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getAimObject'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_getAimObject(sbaiplayer);
}
/// <summary>
/// @brief Get the AIPlayer's current destination.
/// 
///    @return Returns a point containing the \"x y z\" position 
///    of the AIPlayer's current move destination. If no move destination 
///    has yet been set, this returns \"0 0 0\".
///    
///    @see setMoveDestination())
/// 
/// </summary>

public string fnAIPlayer_getMoveDestination (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getMoveDestination'" + string.Format("\"{0}\" ",aiplayer));
var returnbuff = new StringBuilder(1024);
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_getMoveDestination(sbaiplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the move speed of an AI object.
/// 
///    @return A speed multiplier between 0.0 and 1.0.
/// 
///    @see setMoveSpeed())
/// 
/// </summary>

public float fnAIPlayer_getMoveSpeed (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getMoveSpeed'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_getMoveSpeed(sbaiplayer);
}
/// <summary>
/// @brief Return the NavMesh this AIPlayer is using to navigate.)
/// 
/// </summary>

public int fnAIPlayer_getNavMesh (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getNavMesh'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_getNavMesh(sbaiplayer);
}
/// <summary>
/// @brief Return the size of NavMesh this character uses for pathfinding.)
/// 
/// </summary>

public string fnAIPlayer_getNavSize (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getNavSize'" + string.Format("\"{0}\" ",aiplayer));
var returnbuff = new StringBuilder(16384);
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_getNavSize(sbaiplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the AIPlayer's current pathfinding destination.
/// 
///    @return Returns a point containing the \"x y z\" position 
///    of the AIPlayer's current path destination. If no path destination 
///    has yet been set, this returns \"0 0 0\".
/// 
///    @see setPathDestination())
/// 
/// </summary>

public string fnAIPlayer_getPathDestination (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_getPathDestination'" + string.Format("\"{0}\" ",aiplayer));
var returnbuff = new StringBuilder(1024);
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_getPathDestination(sbaiplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Tells the AI to re-plan its path. Does nothing if the character 
///    has no path, or if it is following a mission path.)
/// 
/// </summary>

public void fnAIPlayer_repath (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_repath'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_repath(sbaiplayer);
}
/// <summary>
/// @brief Tells the AIPlayer to aim at the location provided.
/// 
///    @param target An \"x y z\" position in the game world to target.
///    
///    @see getAimLocation())
/// 
/// </summary>

public void fnAIPlayer_setAimLocation (string aiplayer, string target)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_setAimLocation'" + string.Format("\"{0}\" \"{1}\" ",aiplayer,target));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

SafeNativeMethods.mwle_fnAIPlayer_setAimLocation(sbaiplayer, sbtarget);
}
/// <summary>
/// @brief Tells the AI to move to the location provided
/// 
///    @param goal Coordinates in world space representing location to move to.
///    @param slowDown A boolean value. If set to true, the bot will slow down 
///    when it gets within 5-meters of its move destination. If false, the bot 
///    will stop abruptly when it reaches the move destination. By default, this is true.
/// 
///    @note Upon reaching a move destination, the bot will clear its move destination and 
///    calls to getMoveDestination will return \"0 0 0\".
///    
///    @see getMoveDestination())
/// 
/// </summary>

public void fnAIPlayer_setMoveDestination (string aiplayer, string goal, bool slowDown)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_setMoveDestination'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiplayer,goal,slowDown));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbgoal = null;
if (goal != null)
     sbgoal = new StringBuilder(goal, 1024);

SafeNativeMethods.mwle_fnAIPlayer_setMoveDestination(sbaiplayer, sbgoal, slowDown);
}
/// <summary>
/// @brief Sets the move speed for an AI object.
/// 
///    @param speed A speed multiplier between 0.0 and 1.0.  
///    This is multiplied by the AIPlayer's base movement rates (as defined in 
///    its PlayerData datablock)
///    
///    @see getMoveDestination())
/// 
/// </summary>

public void fnAIPlayer_setMoveSpeed (string aiplayer, float speed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_setMoveSpeed'" + string.Format("\"{0}\" \"{1}\" ",aiplayer,speed));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_setMoveSpeed(sbaiplayer, speed);
}
/// <summary>
/// @brief Set the size of NavMesh this character uses. One of \"Small\", \"Regular\" or \"Large\".)
/// 
/// </summary>

public void fnAIPlayer_setNavSize (string aiplayer, string size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_setNavSize'" + string.Format("\"{0}\" \"{1}\" ",aiplayer,size));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbsize = null;
if (size != null)
     sbsize = new StringBuilder(size, 1024);

SafeNativeMethods.mwle_fnAIPlayer_setNavSize(sbaiplayer, sbsize);
}
/// <summary>
/// @brief Tells the AI to find a path to the location provided
/// 
///    @param goal Coordinates in world space representing location to move to.
///    @return True if a path was found.
/// 
///    @see getPathDestination()
///    @see setMoveDestination())
/// 
/// </summary>

public bool fnAIPlayer_setPathDestination (string aiplayer, string goal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_setPathDestination'" + string.Format("\"{0}\" \"{1}\" ",aiplayer,goal));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);
StringBuilder sbgoal = null;
if (goal != null)
     sbgoal = new StringBuilder(goal, 1024);

return  SafeNativeMethods.mwle_fnAIPlayer_setPathDestination(sbaiplayer, sbgoal)>=1;
}
/// <summary>
/// @brief Tells the AIPlayer to stop moving.)
/// 
/// </summary>

public void fnAIPlayer_stop (string aiplayer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAIPlayer_stop'" + string.Format("\"{0}\" ",aiplayer));
StringBuilder sbaiplayer = null;
if (aiplayer != null)
     sbaiplayer = new StringBuilder(aiplayer, 1024);

SafeNativeMethods.mwle_fnAIPlayer_stop(sbaiplayer);
}
/// <summary>
/// @brief Activate a turret from a deactive state.)
/// 
/// </summary>

public void fnAITurretShape_activateTurret (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_activateTurret'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_activateTurret(sbaiturretshape);
}
/// <summary>
/// @brief Adds object to the turret's ignore list.
///    All objects in this list will be ignored by the turret's targeting.
///    @param obj The ShapeBase object to ignore.)
/// 
/// </summary>

public void fnAITurretShape_addToIgnoreList (string aiturretshape, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_addToIgnoreList'" + string.Format("\"{0}\" \"{1}\" ",aiturretshape,obj));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fnAITurretShape_addToIgnoreList(sbaiturretshape, sbobj);
}
/// <summary>
/// @brief Deactivate a turret from an active state.)
/// 
/// </summary>

public void fnAITurretShape_deactivateTurret (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_deactivateTurret'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_deactivateTurret(sbaiturretshape);
}
/// <summary>
/// @brief Get the turret's current target.
///    @returns The object that is the target's current target, or 0 if no target.)
/// 
/// </summary>

public string fnAITurretShape_getTarget (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_getTarget'" + string.Format("\"{0}\" ",aiturretshape));
var returnbuff = new StringBuilder(1024);
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_getTarget(sbaiturretshape, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the turret's defined projectile velocity that helps with target leading.
///    @returns The defined weapon projectile speed, or 0 if leading is disabled.)
/// 
/// </summary>

public float fnAITurretShape_getWeaponLeadVelocity (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_getWeaponLeadVelocity'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

return  SafeNativeMethods.mwle_fnAITurretShape_getWeaponLeadVelocity(sbaiturretshape);
}
/// <summary>
/// @brief Indicates if the turret has a target.
///    @returns True if the turret has a target.)
/// 
/// </summary>

public bool fnAITurretShape_hasTarget (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_hasTarget'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

return  SafeNativeMethods.mwle_fnAITurretShape_hasTarget(sbaiturretshape)>=1;
}
/// <summary>
/// @brief Recenter the turret's weapon.)
/// 
/// </summary>

public void fnAITurretShape_recenterTurret (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_recenterTurret'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_recenterTurret(sbaiturretshape);
}
/// <summary>
/// @brief Removes object from the turret's ignore list.
///    All objects in this list will be ignored by the turret's targeting.
///    @param obj The ShapeBase object to once again allow for targeting.)
/// 
/// </summary>

public void fnAITurretShape_removeFromIgnoreList (string aiturretshape, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_removeFromIgnoreList'" + string.Format("\"{0}\" \"{1}\" ",aiturretshape,obj));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fnAITurretShape_removeFromIgnoreList(sbaiturretshape, sbobj);
}
/// <summary>
/// @brief Resets the turret's target tracking.
///    Only resets the internal target tracking.  Does not modify the turret's facing.)
/// 
/// </summary>

public void fnAITurretShape_resetTarget (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_resetTarget'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_resetTarget(sbaiturretshape);
}
/// <summary>
/// @brief Set the firing state of the turret's guns.
///    @param fire Set to true to activate all guns.  False to deactivate them.)
/// 
/// </summary>

public void fnAITurretShape_setAllGunsFiring (string aiturretshape, bool fire)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_setAllGunsFiring'" + string.Format("\"{0}\" \"{1}\" ",aiturretshape,fire));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_setAllGunsFiring(sbaiturretshape, fire);
}
/// <summary>
/// @brief Set the firing state of the given gun slot.
///    @param slot The gun to modify.  Valid range is 0-3 that corresponds to the weapon mount point.
///    @param fire Set to true to activate the gun.  False to deactivate it.)
/// 
/// </summary>

public void fnAITurretShape_setGunSlotFiring (string aiturretshape, int slot, bool fire)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_setGunSlotFiring'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiturretshape,slot,fire));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_setGunSlotFiring(sbaiturretshape, slot, fire);
}
/// <summary>
/// @brief Set the turret's current state.
///    Normally the turret's state comes from updating the state machine but this method 
///    allows you to override this and jump to the requested state immediately.
///    @param newState The name of the new state.
///    @param force Is true then force the full processing of the new state even if it is the 
///    same as the current state.  If false then only the time out value is reset and the state's 
///    script method is called, if any.)
/// 
/// </summary>

public void fnAITurretShape_setTurretState (string aiturretshape, string newState, bool force)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_setTurretState'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",aiturretshape,newState,force));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);
StringBuilder sbnewState = null;
if (newState != null)
     sbnewState = new StringBuilder(newState, 1024);

SafeNativeMethods.mwle_fnAITurretShape_setTurretState(sbaiturretshape, sbnewState, force);
}
/// <summary>
/// @brief Set the turret's projectile velocity to help lead the target.
///    This value normally comes from AITurretShapeData::weaponLeadVelocity but this method 
///    allows you to override the datablock value.  This can be useful if the turret changes 
///    ammunition, uses a different weapon than the default, is damaged, etc.
///    @note Setting this to 0 will disable target leading.)
/// 
/// </summary>

public void fnAITurretShape_setWeaponLeadVelocity (string aiturretshape, float velocity)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_setWeaponLeadVelocity'" + string.Format("\"{0}\" \"{1}\" ",aiturretshape,velocity));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_setWeaponLeadVelocity(sbaiturretshape, velocity);
}
/// <summary>
/// @brief Begin scanning for a target.)
/// 
/// </summary>

public void fnAITurretShape_startScanForTargets (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_startScanForTargets'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_startScanForTargets(sbaiturretshape);
}
/// <summary>
/// @brief Have the turret track the current target.)
/// 
/// </summary>

public void fnAITurretShape_startTrackingTarget (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_startTrackingTarget'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_startTrackingTarget(sbaiturretshape);
}
/// <summary>
/// @brief Stop scanning for targets.
///    @note Only impacts the scanning for new targets.  Does not effect a turret's current 
///    target lock.)
/// 
/// </summary>

public void fnAITurretShape_stopScanForTargets (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_stopScanForTargets'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_stopScanForTargets(sbaiturretshape);
}
/// <summary>
/// @brief Stop the turret from tracking the current target.)
/// 
/// </summary>

public void fnAITurretShape_stopTrackingTarget (string aiturretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnAITurretShape_stopTrackingTarget'" + string.Format("\"{0}\" ",aiturretshape));
StringBuilder sbaiturretshape = null;
if (aiturretshape != null)
     sbaiturretshape = new StringBuilder(aiturretshape, 1024);

SafeNativeMethods.mwle_fnAITurretShape_stopTrackingTarget(sbaiturretshape);
}
/// <summary>
///  ),
///    Adds a new element to the end of an array (same as push_back()).
///    @param key Key for the new element
///    @param value Value for the new element )
/// 
/// </summary>

public void fnArrayObject_add (string arrayobject, string key, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_add'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arrayobject,key,value));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnArrayObject_add(sbarrayobject, sbkey, sbvalue);
}
/// <summary>
/// Appends the target array to the array object.
///    @param target ArrayObject to append to the end of this array )
/// 
/// </summary>

public bool fnArrayObject_append (string arrayobject, string target)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_append'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,target));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_append(sbarrayobject, sbtarget)>=1;
}
/// <summary>
/// Get the number of elements in the array. )
/// 
/// </summary>

public int fnArrayObject_count (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_count'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_count(sbarrayobject);
}
/// <summary>
/// Get the number of times a particular key is found in the array.
///    @param key Key value to count )
/// 
/// </summary>

public int fnArrayObject_countKey (string arrayobject, string key)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_countKey'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,key));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_countKey(sbarrayobject, sbkey);
}
/// <summary>
/// Get the number of times a particular value is found in the array.
///    @param value Array element value to count )
/// 
/// </summary>

public int fnArrayObject_countValue (string arrayobject, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_countValue'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,value));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_countValue(sbarrayobject, sbvalue);
}
/// <summary>
/// Removes elements with matching keys from array.
///    @param target ArrayObject containing keys to remove from this array )
/// 
/// </summary>

public bool fnArrayObject_crop (string arrayobject, string target)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_crop'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,target));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_crop(sbarrayobject, sbtarget)>=1;
}
/// <summary>
/// Alters array into an exact duplicate of the target array.
///    @param target ArrayObject to duplicate )
/// 
/// </summary>

public bool fnArrayObject_duplicate (string arrayobject, string target)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_duplicate'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,target));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_duplicate(sbarrayobject, sbtarget)>=1;
}
/// <summary>
/// Echos the array contents to the console )
/// 
/// </summary>

public void fnArrayObject_echo (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_echo'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_echo(sbarrayobject);
}
/// <summary>
/// Emptys all elements from an array )
/// 
/// </summary>

public void fnArrayObject_empty (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_empty'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_empty(sbarrayobject);
}
/// <summary>
/// Removes an element at a specific position from the array.
///    @param index 0-based index of the element to remove )
/// 
/// </summary>

public void fnArrayObject_erase (string arrayobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_erase'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,index));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_erase(sbarrayobject, index);
}
/// <summary>
/// Gets the current pointer index )
/// 
/// </summary>

public int fnArrayObject_getCurrent (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_getCurrent'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_getCurrent(sbarrayobject);
}
/// <summary>
/// Search the array from the current position for the key 
///    @param value Array key to search for
///    @return Index of the first element found, or -1 if none )
/// 
/// </summary>

public int fnArrayObject_getIndexFromKey (string arrayobject, string key)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_getIndexFromKey'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,key));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_getIndexFromKey(sbarrayobject, sbkey);
}
/// <summary>
/// Search the array from the current position for the element 
///    @param value Array value to search for
///    @return Index of the first element found, or -1 if none )
/// 
/// </summary>

public int fnArrayObject_getIndexFromValue (string arrayobject, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_getIndexFromValue'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,value));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_getIndexFromValue(sbarrayobject, sbvalue);
}
/// <summary>
/// Get the key of the array element at the submitted index.
///    @param index 0-based index of the array element to get
///    @return The key associated with the array element at the 
///    specified index, or \"\" if the index is out of range )
/// 
/// </summary>

public string fnArrayObject_getKey (string arrayobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_getKey'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_getKey(sbarrayobject, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the value of the array element at the submitted index.
///    @param index 0-based index of the array element to get
///    @return The value of the array element at the specified index, 
///    or \"\" if the index is out of range )
/// 
/// </summary>

public string fnArrayObject_getValue (string arrayobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_getValue'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_getValue(sbarrayobject, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Adds a new element to a specified position in the array.
///    - @a index = 0 will insert an element at the start of the array (same as push_front())
///    - @a index = %array.count() will insert an element at the end of the array (same as push_back())
///    @param key Key for the new element
///    @param value Value for the new element
///    @param index 0-based index at which to insert the new element )
/// 
/// </summary>

public void fnArrayObject_insert (string arrayobject, string key, string value, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_insert'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",arrayobject,key,value,index));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnArrayObject_insert(sbarrayobject, sbkey, sbvalue, index);
}
/// <summary>
/// Moves array pointer to start of array
///    @return Returns the new array pointer )
/// 
/// </summary>

public int fnArrayObject_moveFirst (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_moveFirst'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_moveFirst(sbarrayobject);
}
/// <summary>
/// Moves array pointer to end of array
///    @return Returns the new array pointer )
/// 
/// </summary>

public int fnArrayObject_moveLast (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_moveLast'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_moveLast(sbarrayobject);
}
/// <summary>
/// Moves array pointer to next position
///    @return Returns the new array pointer, or -1 if already at the end )
/// 
/// </summary>

public int fnArrayObject_moveNext (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_moveNext'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_moveNext(sbarrayobject);
}
/// <summary>
/// Moves array pointer to prev position
///    @return Returns the new array pointer, or -1 if already at the start )
/// 
/// </summary>

public int fnArrayObject_movePrev (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_movePrev'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

return  SafeNativeMethods.mwle_fnArrayObject_movePrev(sbarrayobject);
}
/// <summary>
/// Removes the last element from the array )
/// 
/// </summary>

public void fnArrayObject_pop_back (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_pop_back'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_pop_back(sbarrayobject);
}
/// <summary>
/// Removes the first element from the array )
/// 
/// </summary>

public void fnArrayObject_pop_front (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_pop_front'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_pop_front(sbarrayobject);
}
/// <summary>
///  ),
///    Adds a new element to the end of an array.
///    @param key Key for the new element
///    @param value Value for the new element )
/// 
/// </summary>

public void fnArrayObject_push_back (string arrayobject, string key, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_push_back'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arrayobject,key,value));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnArrayObject_push_back(sbarrayobject, sbkey, sbvalue);
}
/// <summary>
///  ),
///    Adds a new element to the front of an array )
/// 
/// </summary>

public void fnArrayObject_push_front (string arrayobject, string key, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_push_front'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arrayobject,key,value));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnArrayObject_push_front(sbarrayobject, sbkey, sbvalue);
}
/// <summary>
/// Sets the current pointer index.
///    @param index New 0-based pointer index )
/// 
/// </summary>

public void fnArrayObject_setCurrent (string arrayobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_setCurrent'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,index));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_setCurrent(sbarrayobject, index);
}
/// <summary>
/// Set the key at the given index.
///    @param key New key value
///    @param index 0-based index of the array element to update )
/// 
/// </summary>

public void fnArrayObject_setKey (string arrayobject, string key, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_setKey'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arrayobject,key,index));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);

SafeNativeMethods.mwle_fnArrayObject_setKey(sbarrayobject, sbkey, index);
}
/// <summary>
/// Set the value at the given index.
///    @param value New array element value
///    @param index 0-based index of the array element to update )
/// 
/// </summary>

public void fnArrayObject_setValue (string arrayobject, string value, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_setValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",arrayobject,value,index));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnArrayObject_setValue(sbarrayobject, sbvalue, index);
}
/// <summary>
/// Alpha sorts the array by value
///    @param ascending [optional] True for ascending sort, false for descending sort )
/// 
/// </summary>

public void fnArrayObject_sort (string arrayobject, bool ascending)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sort'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,ascending));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sort(sbarrayobject, ascending);
}
/// <summary>
/// Alpha sorts the array by value in ascending order )
/// 
/// </summary>

public void fnArrayObject_sorta (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sorta'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sorta(sbarrayobject);
}
/// <summary>
/// Alpha sorts the array by value in descending order )
/// 
/// </summary>

public void fnArrayObject_sortd (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortd'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortd(sbarrayobject);
}
/// <summary>
/// Sorts the array by value in ascending order using the given callback function.
///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
///    @tsexample
///    function mySortCallback(%a, %b)
///    {
///       return strcmp( %a.name, %b.name );
///    }
///    %array.sortf( \"mySortCallback\" );
///    @endtsexample )
/// 
/// </summary>

public void fnArrayObject_sortf (string arrayobject, string functionName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortf'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,functionName));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbfunctionName = null;
if (functionName != null)
     sbfunctionName = new StringBuilder(functionName, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortf(sbarrayobject, sbfunctionName);
}
/// <summary>
/// Sorts the array by value in descending order using the given callback function.
///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
///    @see sortf )
/// 
/// </summary>

public void fnArrayObject_sortfd (string arrayobject, string functionName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortfd'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,functionName));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbfunctionName = null;
if (functionName != null)
     sbfunctionName = new StringBuilder(functionName, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortfd(sbarrayobject, sbfunctionName);
}
/// <summary>
/// Sorts the array by key in ascending order using the given callback function.
///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
///    @see sortf )
/// 
/// </summary>

public void fnArrayObject_sortfk (string arrayobject, string functionName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortfk'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,functionName));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbfunctionName = null;
if (functionName != null)
     sbfunctionName = new StringBuilder(functionName, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortfk(sbarrayobject, sbfunctionName);
}
/// <summary>
/// Sorts the array by key in descending order using the given callback function.
///    @param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.
///    @see sortf )
/// 
/// </summary>

public void fnArrayObject_sortfkd (string arrayobject, string functionName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortfkd'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,functionName));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);
StringBuilder sbfunctionName = null;
if (functionName != null)
     sbfunctionName = new StringBuilder(functionName, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortfkd(sbarrayobject, sbfunctionName);
}
/// <summary>
/// Alpha sorts the array by key
///    @param ascending [optional] True for ascending sort, false for descending sort )
/// 
/// </summary>

public void fnArrayObject_sortk (string arrayobject, bool ascending)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortk'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,ascending));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortk(sbarrayobject, ascending);
}
/// <summary>
/// Alpha sorts the array by key in ascending order )
/// 
/// </summary>

public void fnArrayObject_sortka (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortka'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortka(sbarrayobject);
}
/// <summary>
/// Alpha sorts the array by key in descending order )
/// 
/// </summary>

public void fnArrayObject_sortkd (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortkd'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortkd(sbarrayobject);
}
/// <summary>
/// Numerically sorts the array by value
///    @param ascending [optional] True for ascending sort, false for descending sort )
/// 
/// </summary>

public void fnArrayObject_sortn (string arrayobject, bool ascending)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortn'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,ascending));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortn(sbarrayobject, ascending);
}
/// <summary>
/// Numerically sorts the array by value in ascending order ) 
/// 
/// </summary>

public void fnArrayObject_sortna (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortna'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortna(sbarrayobject);
}
/// <summary>
/// Numerically sorts the array by value in descending order )
/// 
/// </summary>

public void fnArrayObject_sortnd (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortnd'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortnd(sbarrayobject);
}
/// <summary>
/// Numerically sorts the array by key
///    @param ascending [optional] True for ascending sort, false for descending sort )
/// 
/// </summary>

public void fnArrayObject_sortnk (string arrayobject, bool ascending)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortnk'" + string.Format("\"{0}\" \"{1}\" ",arrayobject,ascending));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortnk(sbarrayobject, ascending);
}
/// <summary>
/// Numerical sorts the array by key in ascending order )
/// 
/// </summary>

public void fnArrayObject_sortnka (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortnka'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortnka(sbarrayobject);
}
/// <summary>
/// Numerical sorts the array by key in descending order )
/// 
/// </summary>

public void fnArrayObject_sortnkd (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_sortnkd'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_sortnkd(sbarrayobject);
}
/// <summary>
/// Removes any elements that have duplicated keys (leaving the first instance) )
/// 
/// </summary>

public void fnArrayObject_uniqueKey (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_uniqueKey'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_uniqueKey(sbarrayobject);
}
/// <summary>
/// Removes any elements that have duplicated values (leaving the first instance) )
/// 
/// </summary>

public void fnArrayObject_uniqueValue (string arrayobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnArrayObject_uniqueValue'" + string.Format("\"{0}\" ",arrayobject));
StringBuilder sbarrayobject = null;
if (arrayobject != null)
     sbarrayobject = new StringBuilder(arrayobject, 1024);

SafeNativeMethods.mwle_fnArrayObject_uniqueValue(sbarrayobject);
}
/// <summary>
/// Move the camera to fully view the given radius.
///                    @note For this operation to take affect a valid edit orbit point must first be specified.  See Camera::setEditOrbitPoint().
///                    @param radius The radius to view.)
/// 
/// </summary>

public void fnCamera_autoFitRadius (string camera, float radius)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_autoFitRadius'" + string.Format("\"{0}\" \"{1}\" ",camera,radius));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_autoFitRadius(sbcamera, radius);
}
/// <summary>
/// Get the angular velocity for a Newton mode camera.
///                    @returns The angular velocity in the form of \"x y z\".
///                    @note Only returns useful results when Camera::newtonRotation is set to true.)
/// 
/// </summary>

public string fnCamera_getAngularVelocity (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getAngularVelocity'" + string.Format("\"{0}\" ",camera));
var returnbuff = new StringBuilder(1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_getAngularVelocity(sbcamera, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the current camera control mode.
///                    @see CameraMotionMode)
/// 
/// </summary>

public int fnCamera_getMode (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getMode'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

return  SafeNativeMethods.mwle_fnCamera_getMode(sbcamera);
}
/// <summary>
/// Get the camera's offset from its orbit or tracking point.
///                    The offset is added to the camera's position when set to CameraMode::OrbitObject.
///                    @returns The offset in the form of \"x y z\".)
/// 
/// </summary>

public string fnCamera_getOffset (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getOffset'" + string.Format("\"{0}\" ",camera));
var returnbuff = new StringBuilder(1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_getOffset(sbcamera, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the camera's position in the world.
///                    @returns The position in the form of \"x y z\".)
/// 
/// </summary>

public string fnCamera_getPosition (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getPosition'" + string.Format("\"{0}\" ",camera));
var returnbuff = new StringBuilder(1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_getPosition(sbcamera, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the camera's Euler rotation in radians.
///                    @returns The rotation in radians in the form of \"x y z\".)
/// 
/// </summary>

public string fnCamera_getRotation (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getRotation'" + string.Format("\"{0}\" ",camera));
var returnbuff = new StringBuilder(1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_getRotation(sbcamera, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the velocity for the camera.
///                    @returns The camera's velocity in the form of \"x y z\".
///                    @note Only useful when the Camera is in Newton mode.)
/// 
/// </summary>

public string fnCamera_getVelocity (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_getVelocity'" + string.Format("\"{0}\" ",camera));
var returnbuff = new StringBuilder(1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_getVelocity(sbcamera, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Is the camera in edit orbit mode?
///                    @returns true if the camera is in edit orbit mode.)
/// 
/// </summary>

public bool fnCamera_isEditOrbitMode (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_isEditOrbitMode'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

return  SafeNativeMethods.mwle_fnCamera_isEditOrbitMode(sbcamera)>=1;
}
/// <summary>
/// Is this a Newton Fly mode camera with damped rotation?
///                     @returns true if the camera uses a damped rotation.  i.e. Camera::newtonRotation is set to true.)
/// 
/// </summary>

public bool fnCamera_isRotationDamped (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_isRotationDamped'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

return  SafeNativeMethods.mwle_fnCamera_isRotationDamped(sbcamera)>=1;
}
/// <summary>
/// Point the camera at the specified position.  Does not work in Orbit or Track modes.
///                    @param point The position to point the camera at.)
/// 
/// </summary>

public void fnCamera_lookAt (string camera, string point)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_lookAt'" + string.Format("\"{0}\" \"{1}\" ",camera,point));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbpoint = null;
if (point != null)
     sbpoint = new StringBuilder(point, 1024);

SafeNativeMethods.mwle_fnCamera_lookAt(sbcamera, sbpoint);
}
/// <summary>
/// Set the angular drag for a Newton mode camera.
///                    @param drag The angular drag applied while the camera is rotating.
///                    @note Only takes affect when Camera::newtonRotation is set to true.)
/// 
/// </summary>

public void fnCamera_setAngularDrag (string camera, float drag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setAngularDrag'" + string.Format("\"{0}\" \"{1}\" ",camera,drag));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setAngularDrag(sbcamera, drag);
}
/// <summary>
/// Set the angular force for a Newton mode camera.
///                    @param force The angular force applied when attempting to rotate the camera.
///                    @note Only takes affect when Camera::newtonRotation is set to true.)
/// 
/// </summary>

public void fnCamera_setAngularForce (string camera, float force)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setAngularForce'" + string.Format("\"{0}\" \"{1}\" ",camera,force));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setAngularForce(sbcamera, force);
}
/// <summary>
/// Set the angular velocity for a Newton mode camera.
///                    @param velocity The angular velocity infor form of \"x y z\".
///                    @note Only takes affect when Camera::newtonRotation is set to true.)
/// 
/// </summary>

public void fnCamera_setAngularVelocity (string camera, string velocity)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setAngularVelocity'" + string.Format("\"{0}\" \"{1}\" ",camera,velocity));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbvelocity = null;
if (velocity != null)
     sbvelocity = new StringBuilder(velocity, 1024);

SafeNativeMethods.mwle_fnCamera_setAngularVelocity(sbcamera, sbvelocity);
}
/// <summary>
/// Set the Newton mode camera brake multiplier when trigger[1] is active.
///                    @param multiplier The brake multiplier to apply.
///                    @note Only used when Camera is in Newton mode.)
/// 
/// </summary>

public void fnCamera_setBrakeMultiplier (string camera, float multiplier)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setBrakeMultiplier'" + string.Format("\"{0}\" \"{1}\" ",camera,multiplier));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setBrakeMultiplier(sbcamera, multiplier);
}
/// <summary>
/// Set the drag for a Newton mode camera.
///                    @param drag The drag applied to the camera while moving.
///                    @note Only used when Camera is in Newton mode.)
/// 
/// </summary>

public void fnCamera_setDrag (string camera, float drag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setDrag'" + string.Format("\"{0}\" \"{1}\" ",camera,drag));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setDrag(sbcamera, drag);
}
/// <summary>
/// Set the editor camera to orbit around a point set with Camera::setEditOrbitPoint().
///                     @note This method is generally used only within the World Editor and other tools.  To 
///                     orbit about an object or point within a game, see Camera::setOrbitMode() and its helper methods.)
/// 
/// </summary>

public void fnCamera_setEditOrbitMode (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setEditOrbitMode'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setEditOrbitMode(sbcamera);
}
/// <summary>
/// Set the editor camera's orbit point.
///                    @param point The point the camera will orbit in the form of \"x y z\".)
/// 
/// </summary>

public void fnCamera_setEditOrbitPoint (string camera, string point)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setEditOrbitPoint'" + string.Format("\"{0}\" \"{1}\" ",camera,point));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbpoint = null;
if (point != null)
     sbpoint = new StringBuilder(point, 1024);

SafeNativeMethods.mwle_fnCamera_setEditOrbitPoint(sbcamera, sbpoint);
}
/// <summary>
/// Set the force applied to a Newton mode camera while moving.
///                    @param force The force applied to the camera while attempting to move.
///                    @note Only used when Camera is in Newton mode.)
/// 
/// </summary>

public void fnCamera_setFlyForce (string camera, float force)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setFlyForce'" + string.Format("\"{0}\" \"{1}\" ",camera,force));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setFlyForce(sbcamera, force);
}
/// <summary>
/// Set the camera to fly freely.
///                    Allows the camera to have 6 degrees of freedom.  Provides for instantaneous motion 
///                    and rotation unless one of the Newton fields has been set to true.  See Camera::newtonMode 
///                    and Camera::newtonRotation.)
/// 
/// </summary>

public void fnCamera_setFlyMode (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setFlyMode'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setFlyMode(sbcamera);
}
/// <summary>
/// Set the mass for a Newton mode camera.
///                    @param mass The mass used during ease-in and ease-out calculations.
///                    @note Only used when Camera is in Newton mode.)
/// 
/// </summary>

public void fnCamera_setMass (string camera, float mass)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setMass'" + string.Format("\"{0}\" \"{1}\" ",camera,mass));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setMass(sbcamera, mass);
}
/// <summary>
/// Set the camera to fly freely, but with ease-in and ease-out.
///                     This method allows for the same 6 degrees of freedom as Camera::setFlyMode() but 
///                     activates the ease-in and ease-out on the camera's movement.  To also activate 
///                     Newton mode for the camera's rotation, set Camera::newtonRotation to true.)
/// 
/// </summary>

public void fnCamera_setNewtonFlyMode (string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setNewtonFlyMode'" + string.Format("\"{0}\" ",camera));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setNewtonFlyMode(sbcamera);
}
/// <summary>
/// Set the camera's offset.
///                    The offset is added to the camera's position when set to CameraMode::OrbitObject.
///                    @param offset The distance to offset the camera by in the form of \"x y z\".)
/// 
/// </summary>

public void fnCamera_setOffset (string camera, string offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setOffset'" + string.Format("\"{0}\" \"{1}\" ",camera,offset));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

SafeNativeMethods.mwle_fnCamera_setOffset(sbcamera, sboffset);
}
/// <summary>
/// Set the camera to orbit around the given object, or if none is given, around the given point.
///                     @param orbitObject The object to orbit around.  If no object is given (0 or blank string is passed in) use the orbitPoint instead
///                     @param orbitPoint The point to orbit around when no object is given.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform().
///                     @param minDistance The minimum distance allowed to the orbit object or point.
///                     @param maxDistance The maximum distance allowed from the orbit object or point.
///                     @param initDistance The initial distance from the orbit object or point.
///                     @param ownClientObj [optional] Are we orbiting an object that is owned by us?  Default is false.
///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
///                     @see Camera::setOrbitObject()
///                     @see Camera::setOrbitPoint())
/// 
/// </summary>

public void fnCamera_setOrbitMode (string camera, string orbitObject, string orbitPoint, float minDistance, float maxDistance, float initDistance, bool ownClientObj, string offset, bool lockedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setOrbitMode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" ",camera,orbitObject,orbitPoint,minDistance,maxDistance,initDistance,ownClientObj,offset,lockedx));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sborbitObject = null;
if (orbitObject != null)
     sborbitObject = new StringBuilder(orbitObject, 1024);
StringBuilder sborbitPoint = null;
if (orbitPoint != null)
     sborbitPoint = new StringBuilder(orbitPoint, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

SafeNativeMethods.mwle_fnCamera_setOrbitMode(sbcamera, sborbitObject, sborbitPoint, minDistance, maxDistance, initDistance, ownClientObj, sboffset, lockedx);
}
/// <summary>
/// Set the camera to orbit around a given object.
///                     @param orbitObject The object to orbit around.
///                     @param rotation The initial camera rotation about the object in radians in the form of \"x y z\".
///                     @param minDistance The minimum distance allowed to the orbit object or point.
///                     @param maxDistance The maximum distance allowed from the orbit object or point.
///                     @param initDistance The initial distance from the orbit object or point.
///                     @param ownClientObject [optional] Are we orbiting an object that is owned by us?  Default is false.
///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
///                     @returns false if the given object could not be found.
///                     @see Camera::setOrbitMode())
/// 
/// </summary>

public bool fnCamera_setOrbitObject (string camera, string orbitObject, string rotation, float minDistance, float maxDistance, float initDistance, bool ownClientObject, string offset, bool lockedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setOrbitObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" ",camera,orbitObject,rotation,minDistance,maxDistance,initDistance,ownClientObject,offset,lockedx));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sborbitObject = null;
if (orbitObject != null)
     sborbitObject = new StringBuilder(orbitObject, 1024);
StringBuilder sbrotation = null;
if (rotation != null)
     sbrotation = new StringBuilder(rotation, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

return  SafeNativeMethods.mwle_fnCamera_setOrbitObject(sbcamera, sborbitObject, sbrotation, minDistance, maxDistance, initDistance, ownClientObject, sboffset, lockedx)>=1;
}
/// <summary>
/// Set the camera to orbit around a given point.
///                     @param orbitPoint The point to orbit around.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform().
///                     @param minDistance The minimum distance allowed to the orbit object or point.
///                     @param maxDistance The maximum distance allowed from the orbit object or point.
///                     @param initDistance The initial distance from the orbit object or point.
///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
///                     @param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
///                     @see Camera::setOrbitMode())
/// 
/// </summary>

public void fnCamera_setOrbitPoint (string camera, string orbitPoint, float minDistance, float maxDistance, float initDistance, string offset, bool lockedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setOrbitPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",camera,orbitPoint,minDistance,maxDistance,initDistance,offset,lockedx));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sborbitPoint = null;
if (orbitPoint != null)
     sborbitPoint = new StringBuilder(orbitPoint, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

SafeNativeMethods.mwle_fnCamera_setOrbitPoint(sbcamera, sborbitPoint, minDistance, maxDistance, initDistance, sboffset, lockedx);
}
/// <summary>
/// Set the camera's Euler rotation in radians.
///                    @param rot The rotation in radians in the form of \"x y z\".
///                    @note Rotation around the Y axis is ignored )
/// 
/// </summary>

public void fnCamera_setRotation (string camera, string rot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setRotation'" + string.Format("\"{0}\" \"{1}\" ",camera,rot));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbrot = null;
if (rot != null)
     sbrot = new StringBuilder(rot, 1024);

SafeNativeMethods.mwle_fnCamera_setRotation(sbcamera, sbrot);
}
/// <summary>
/// Set the Newton mode camera speed multiplier when trigger[0] is active.
///                    @param multiplier The speed multiplier to apply.
///                    @note Only used when Camera is in Newton mode.)
/// 
/// </summary>

public void fnCamera_setSpeedMultiplier (string camera, float multiplier)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setSpeedMultiplier'" + string.Format("\"{0}\" \"{1}\" ",camera,multiplier));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setSpeedMultiplier(sbcamera, multiplier);
}
/// <summary>
/// Set the camera to track a given object.
///                     @param trackObject The object to track.
///                     @param offset [optional] An offset added to the camera's position.  Default is no offset.
///                     @returns false if the given object could not be found.)
/// 
/// </summary>

public bool fnCamera_setTrackObject (string camera, string trackObject, string offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setTrackObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",camera,trackObject,offset));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbtrackObject = null;
if (trackObject != null)
     sbtrackObject = new StringBuilder(trackObject, 1024);
StringBuilder sboffset = null;
if (offset != null)
     sboffset = new StringBuilder(offset, 1024);

return  SafeNativeMethods.mwle_fnCamera_setTrackObject(sbcamera, sbtrackObject, sboffset)>=1;
}
/// <summary>
/// Set if there is a valid editor camera orbit point.
///                    When validPoint is set to false the Camera operates as if it is 
///                    in Fly mode rather than an Orbit mode.
///                    @param validPoint Indicates the validity of the orbit point.
///                    @note Only used when Camera is in Edit Orbit Mode.)
/// 
/// </summary>

public void fnCamera_setValidEditOrbitPoint (string camera, bool validPoint)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setValidEditOrbitPoint'" + string.Format("\"{0}\" \"{1}\" ",camera,validPoint));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

SafeNativeMethods.mwle_fnCamera_setValidEditOrbitPoint(sbcamera, validPoint);
}
/// <summary>
/// Set the velocity for the camera.
///                    @param velocity The camera's velocity in the form of \"x y z\".
///                    @note Only affects the Camera when in Newton mode.)
/// 
/// </summary>

public void fnCamera_setVelocity (string camera, string velocity)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCamera_setVelocity'" + string.Format("\"{0}\" \"{1}\" ",camera,velocity));
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);
StringBuilder sbvelocity = null;
if (velocity != null)
     sbvelocity = new StringBuilder(velocity, 1024);

SafeNativeMethods.mwle_fnCamera_setVelocity(sbcamera, sbvelocity);
}
/// <summary>
/// @brief Returns true if someone is already using this cover point.)
/// 
/// </summary>

public bool fnCoverPoint_isOccupied (string coverpoint)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCoverPoint_isOccupied'" + string.Format("\"{0}\" ",coverpoint));
StringBuilder sbcoverpoint = null;
if (coverpoint != null)
     sbcoverpoint = new StringBuilder(coverpoint, 1024);

return  SafeNativeMethods.mwle_fnCoverPoint_isOccupied(sbcoverpoint)>=1;
}
/// <summary>
/// Returns the script filename of where the CubemapData object was 
///    defined.  This is used by the material editor. )
/// 
/// </summary>

public string fnCubemapData_getFilename (string cubemapdata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCubemapData_getFilename'" + string.Format("\"{0}\" ",cubemapdata));
var returnbuff = new StringBuilder(16384);
StringBuilder sbcubemapdata = null;
if (cubemapdata != null)
     sbcubemapdata = new StringBuilder(cubemapdata, 1024);

SafeNativeMethods.mwle_fnCubemapData_getFilename(sbcubemapdata, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Update the assigned cubemaps faces. )
/// 
/// </summary>

public void fnCubemapData_updateFaces (string cubemapdata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnCubemapData_updateFaces'" + string.Format("\"{0}\" ",cubemapdata));
StringBuilder sbcubemapdata = null;
if (cubemapdata != null)
     sbcubemapdata = new StringBuilder(cubemapdata, 1024);

SafeNativeMethods.mwle_fnCubemapData_updateFaces(sbcubemapdata);
}
/// <summary>
/// 1.0 1.0 1.0, 1.0 0.0 0.0), 
///    @brief Manually set this piece of debris at the given position with the given velocity.
/// 
///    Usually you do not manually create Debris objects as they are generated through other means, 
///    such as an Explosion.  This method exists when you do manually create a Debris object and 
///    want to have it start moving.
/// 
///    @param inputPosition Position to place the debris.
///    @param inputVelocity Velocity to move the debris after it has been placed.
///    @return Always returns true.
/// 
///    @tsexample
///       // Define the position
///       %position = \"1.0 1.0 1.0\";
///       // Define the velocity
///       %velocity = \"1.0 0.0 0.0\";
///       // Inform the debris object of its new position and velocity
///       %debris.init(%position,%velocity);
///    @endtsexample)
/// 
/// </summary>

public bool fnDebris_init (string debris, string inputPosition, string inputVelocity)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebris_init'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",debris,inputPosition,inputVelocity));
StringBuilder sbdebris = null;
if (debris != null)
     sbdebris = new StringBuilder(debris, 1024);
StringBuilder sbinputPosition = null;
if (inputPosition != null)
     sbinputPosition = new StringBuilder(inputPosition, 1024);
StringBuilder sbinputVelocity = null;
if (inputVelocity != null)
     sbinputVelocity = new StringBuilder(inputVelocity, 1024);

return  SafeNativeMethods.mwle_fnDebris_init(sbdebris, sbinputPosition, sbinputVelocity)>=1;
}
/// <summary>
/// Draws an axis aligned box primitive within the two 3d points. )
/// 
/// </summary>

public void fnDebugDrawer_drawBox (string debugdrawer, string a, string b, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_drawBox'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",debugdrawer,a,b,color));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_drawBox(sbdebugdrawer, sba, sbb, sbcolor);
}
/// <summary>
/// Draws a line primitive between two 3d points. )
/// 
/// </summary>

public void fnDebugDrawer_drawLine (string debugdrawer, string a, string b, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_drawLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",debugdrawer,a,b,color));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_drawLine(sbdebugdrawer, sba, sbb, sbcolor);
}
/// <summary>
/// Sets the \"time to live\" (TTL) for the last rendered primitive. )
/// 
/// </summary>

public void fnDebugDrawer_setLastTTL (string debugdrawer, uint ms)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_setLastTTL'" + string.Format("\"{0}\" \"{1}\" ",debugdrawer,ms));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_setLastTTL(sbdebugdrawer, ms);
}
/// <summary>
/// Sets the z buffer reading state for the last rendered primitive. )
/// 
/// </summary>

public void fnDebugDrawer_setLastZTest (string debugdrawer, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_setLastZTest'" + string.Format("\"{0}\" \"{1}\" ",debugdrawer,enabled));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_setLastZTest(sbdebugdrawer, enabled);
}
/// <summary>
/// Toggles the rendering of DebugDrawer primitives. )
/// 
/// </summary>

public void fnDebugDrawer_toggleDrawing (string debugdrawer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_toggleDrawing'" + string.Format("\"{0}\" ",debugdrawer));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_toggleDrawing(sbdebugdrawer);
}
/// <summary>
/// Toggles freeze mode which keeps the currently rendered primitives from expiring. )
/// 
/// </summary>

public void fnDebugDrawer_toggleFreeze (string debugdrawer)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDebugDrawer_toggleFreeze'" + string.Format("\"{0}\" ",debugdrawer));
StringBuilder sbdebugdrawer = null;
if (debugdrawer != null)
     sbdebugdrawer = new StringBuilder(debugdrawer, 1024);

SafeNativeMethods.mwle_fnDebugDrawer_toggleFreeze(sbdebugdrawer);
}
/// <summary>
/// Recompute the imagemap sub-texture rectangles for this DecalData.
///    @tsexample
///    // Inform the decal object to reload its imagemap and frame data.
///    %decalData.texRows = 4;
///    %decalData.postApply();
///    @endtsexample)
/// 
/// </summary>

public void fnDecalData_postApply (string decaldata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDecalData_postApply'" + string.Format("\"{0}\" ",decaldata));
StringBuilder sbdecaldata = null;
if (decaldata != null)
     sbdecaldata = new StringBuilder(decaldata, 1024);

SafeNativeMethods.mwle_fnDecalData_postApply(sbdecaldata);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force trigger an inspectPostApply. This will transmit 
///                    the material and other fields ( not including nodes ) 
///                    to client objects.
///                   )
/// 
/// </summary>

public void fnDecalRoad_postApply (string decalroad)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDecalRoad_postApply'" + string.Format("\"{0}\" ",decalroad));
StringBuilder sbdecalroad = null;
if (decalroad != null)
     sbdecalroad = new StringBuilder(decalroad, 1024);

SafeNativeMethods.mwle_fnDecalRoad_postApply(sbdecalroad);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force DecalRoad to update it's spline and reclip geometry.
///                   )
/// 
/// </summary>

public void fnDecalRoad_regenerate (string decalroad)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDecalRoad_regenerate'" + string.Format("\"{0}\" ",decalroad));
StringBuilder sbdecalroad = null;
if (decalroad != null)
     sbdecalroad = new StringBuilder(decalroad, 1024);

SafeNativeMethods.mwle_fnDecalRoad_regenerate(sbdecalroad);
}
/// <summary>
/// ( DynamicConsoleMethodComponent, callMethod, void, 3, 64 , (methodName, argi) Calls script defined method
/// 			  @param methodName The method's name as a string
/// 			  @param argi Any arguments to pass to the method
/// 			  @return No return value
/// 			  @note %obj.callMethod( %methodName, %arg1, %arg2, ... );)
/// 
/// 
/// </summary>

public void fnDynamicConsoleMethodComponent_callMethod (string dynamicconsolemethodcomponent, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19, string a20, string a21, string a22, string a23, string a24, string a25, string a26, string a27, string a28, string a29, string a30, string a31, string a32, string a33, string a34, string a35, string a36, string a37, string a38, string a39, string a40, string a41, string a42, string a43, string a44, string a45, string a46, string a47, string a48, string a49, string a50, string a51, string a52, string a53, string a54, string a55, string a56, string a57, string a58, string a59, string a60, string a61, string a62, string a63)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnDynamicConsoleMethodComponent_callMethod'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" \"{19}\" \"{20}\" \"{21}\" \"{22}\" \"{23}\" \"{24}\" \"{25}\" \"{26}\" \"{27}\" \"{28}\" \"{29}\" \"{30}\" \"{31}\" \"{32}\" \"{33}\" \"{34}\" \"{35}\" \"{36}\" \"{37}\" \"{38}\" \"{39}\" \"{40}\" \"{41}\" \"{42}\" \"{43}\" \"{44}\" \"{45}\" \"{46}\" \"{47}\" \"{48}\" \"{49}\" \"{50}\" \"{51}\" \"{52}\" \"{53}\" \"{54}\" \"{55}\" \"{56}\" \"{57}\" \"{58}\" \"{59}\" \"{60}\" \"{61}\" \"{62}\" ",dynamicconsolemethodcomponent,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30,a31,a32,a33,a34,a35,a36,a37,a38,a39,a40,a41,a42,a43,a44,a45,a46,a47,a48,a49,a50,a51,a52,a53,a54,a55,a56,a57,a58,a59,a60,a61,a62,a63));
StringBuilder sbdynamicconsolemethodcomponent = null;
if (dynamicconsolemethodcomponent != null)
     sbdynamicconsolemethodcomponent = new StringBuilder(dynamicconsolemethodcomponent, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);
StringBuilder sba20 = null;
if (a20 != null)
     sba20 = new StringBuilder(a20, 1024);
StringBuilder sba21 = null;
if (a21 != null)
     sba21 = new StringBuilder(a21, 1024);
StringBuilder sba22 = null;
if (a22 != null)
     sba22 = new StringBuilder(a22, 1024);
StringBuilder sba23 = null;
if (a23 != null)
     sba23 = new StringBuilder(a23, 1024);
StringBuilder sba24 = null;
if (a24 != null)
     sba24 = new StringBuilder(a24, 1024);
StringBuilder sba25 = null;
if (a25 != null)
     sba25 = new StringBuilder(a25, 1024);
StringBuilder sba26 = null;
if (a26 != null)
     sba26 = new StringBuilder(a26, 1024);
StringBuilder sba27 = null;
if (a27 != null)
     sba27 = new StringBuilder(a27, 1024);
StringBuilder sba28 = null;
if (a28 != null)
     sba28 = new StringBuilder(a28, 1024);
StringBuilder sba29 = null;
if (a29 != null)
     sba29 = new StringBuilder(a29, 1024);
StringBuilder sba30 = null;
if (a30 != null)
     sba30 = new StringBuilder(a30, 1024);
StringBuilder sba31 = null;
if (a31 != null)
     sba31 = new StringBuilder(a31, 1024);
StringBuilder sba32 = null;
if (a32 != null)
     sba32 = new StringBuilder(a32, 1024);
StringBuilder sba33 = null;
if (a33 != null)
     sba33 = new StringBuilder(a33, 1024);
StringBuilder sba34 = null;
if (a34 != null)
     sba34 = new StringBuilder(a34, 1024);
StringBuilder sba35 = null;
if (a35 != null)
     sba35 = new StringBuilder(a35, 1024);
StringBuilder sba36 = null;
if (a36 != null)
     sba36 = new StringBuilder(a36, 1024);
StringBuilder sba37 = null;
if (a37 != null)
     sba37 = new StringBuilder(a37, 1024);
StringBuilder sba38 = null;
if (a38 != null)
     sba38 = new StringBuilder(a38, 1024);
StringBuilder sba39 = null;
if (a39 != null)
     sba39 = new StringBuilder(a39, 1024);
StringBuilder sba40 = null;
if (a40 != null)
     sba40 = new StringBuilder(a40, 1024);
StringBuilder sba41 = null;
if (a41 != null)
     sba41 = new StringBuilder(a41, 1024);
StringBuilder sba42 = null;
if (a42 != null)
     sba42 = new StringBuilder(a42, 1024);
StringBuilder sba43 = null;
if (a43 != null)
     sba43 = new StringBuilder(a43, 1024);
StringBuilder sba44 = null;
if (a44 != null)
     sba44 = new StringBuilder(a44, 1024);
StringBuilder sba45 = null;
if (a45 != null)
     sba45 = new StringBuilder(a45, 1024);
StringBuilder sba46 = null;
if (a46 != null)
     sba46 = new StringBuilder(a46, 1024);
StringBuilder sba47 = null;
if (a47 != null)
     sba47 = new StringBuilder(a47, 1024);
StringBuilder sba48 = null;
if (a48 != null)
     sba48 = new StringBuilder(a48, 1024);
StringBuilder sba49 = null;
if (a49 != null)
     sba49 = new StringBuilder(a49, 1024);
StringBuilder sba50 = null;
if (a50 != null)
     sba50 = new StringBuilder(a50, 1024);
StringBuilder sba51 = null;
if (a51 != null)
     sba51 = new StringBuilder(a51, 1024);
StringBuilder sba52 = null;
if (a52 != null)
     sba52 = new StringBuilder(a52, 1024);
StringBuilder sba53 = null;
if (a53 != null)
     sba53 = new StringBuilder(a53, 1024);
StringBuilder sba54 = null;
if (a54 != null)
     sba54 = new StringBuilder(a54, 1024);
StringBuilder sba55 = null;
if (a55 != null)
     sba55 = new StringBuilder(a55, 1024);
StringBuilder sba56 = null;
if (a56 != null)
     sba56 = new StringBuilder(a56, 1024);
StringBuilder sba57 = null;
if (a57 != null)
     sba57 = new StringBuilder(a57, 1024);
StringBuilder sba58 = null;
if (a58 != null)
     sba58 = new StringBuilder(a58, 1024);
StringBuilder sba59 = null;
if (a59 != null)
     sba59 = new StringBuilder(a59, 1024);
StringBuilder sba60 = null;
if (a60 != null)
     sba60 = new StringBuilder(a60, 1024);
StringBuilder sba61 = null;
if (a61 != null)
     sba61 = new StringBuilder(a61, 1024);
StringBuilder sba62 = null;
if (a62 != null)
     sba62 = new StringBuilder(a62, 1024);
StringBuilder sba63 = null;
if (a63 != null)
     sba63 = new StringBuilder(a63, 1024);

SafeNativeMethods.mwle_fnDynamicConsoleMethodComponent_callMethod(sbdynamicconsolemethodcomponent, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, sba20, sba21, sba22, sba23, sba24, sba25, sba26, sba27, sba28, sba29, sba30, sba31, sba32, sba33, sba34, sba35, sba36, sba37, sba38, sba39, sba40, sba41, sba42, sba43, sba44, sba45, sba46, sba47, sba48, sba49, sba50, sba51, sba52, sba53, sba54, sba55, sba56, sba57, sba58, sba59, sba60, sba61, sba62, sba63);
}
/// <summary>
///  )
/// 
/// </summary>

public int fnEditTSCtrl_getDisplayType (string edittsctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_getDisplayType'" + string.Format("\"{0}\" ",edittsctrl));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

return  SafeNativeMethods.mwle_fnEditTSCtrl_getDisplayType(sbedittsctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public int fnEditTSCtrl_getGizmo (string edittsctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_getGizmo'" + string.Format("\"{0}\" ",edittsctrl));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

return  SafeNativeMethods.mwle_fnEditTSCtrl_getGizmo(sbedittsctrl);
}
/// <summary>
/// Return the FOV for orthographic views. )
/// 
/// </summary>

public float fnEditTSCtrl_getOrthoFOV (string edittsctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_getOrthoFOV'" + string.Format("\"{0}\" ",edittsctrl));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

return  SafeNativeMethods.mwle_fnEditTSCtrl_getOrthoFOV(sbedittsctrl);
}
/// <summary>
///  )
/// 
/// </summary>

public bool fnEditTSCtrl_isMiddleMouseDown (string edittsctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_isMiddleMouseDown'" + string.Format("\"{0}\" ",edittsctrl));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

return  SafeNativeMethods.mwle_fnEditTSCtrl_isMiddleMouseDown(sbedittsctrl)>=1;
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_renderBox (string edittsctrl, string pos, string size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_renderBox'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",edittsctrl,pos,size));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbsize = null;
if (size != null)
     sbsize = new StringBuilder(size, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_renderBox(sbedittsctrl, sbpos, sbsize);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_renderCircle (string edittsctrl, string pos, string normal, float radius, int segments)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_renderCircle'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",edittsctrl,pos,normal,radius,segments));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbnormal = null;
if (normal != null)
     sbnormal = new StringBuilder(normal, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_renderCircle(sbedittsctrl, sbpos, sbnormal, radius, segments);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_renderLine (string edittsctrl, string start, string end, float lineWidth)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_renderLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",edittsctrl,start,end,lineWidth));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);
StringBuilder sbstart = null;
if (start != null)
     sbstart = new StringBuilder(start, 1024);
StringBuilder sbend = null;
if (end != null)
     sbend = new StringBuilder(end, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_renderLine(sbedittsctrl, sbstart, sbend, lineWidth);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_renderSphere (string edittsctrl, string pos, float radius, int sphereLevel)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_renderSphere'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",edittsctrl,pos,radius,sphereLevel));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_renderSphere(sbedittsctrl, sbpos, radius, sphereLevel);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_renderTriangle (string edittsctrl, string a, string b, string c)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_renderTriangle'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",edittsctrl,a,b,c));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);
StringBuilder sba = null;
if (a != null)
     sba = new StringBuilder(a, 1024);
StringBuilder sbb = null;
if (b != null)
     sbb = new StringBuilder(b, 1024);
StringBuilder sbc = null;
if (c != null)
     sbc = new StringBuilder(c, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_renderTriangle(sbedittsctrl, sba, sbb, sbc);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnEditTSCtrl_setDisplayType (string edittsctrl, int displayType)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_setDisplayType'" + string.Format("\"{0}\" \"{1}\" ",edittsctrl,displayType));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_setDisplayType(sbedittsctrl, displayType);
}
/// <summary>
/// Set the FOV for to use for orthographic views. )
/// 
/// </summary>

public void fnEditTSCtrl_setOrthoFOV (string edittsctrl, float fov)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnEditTSCtrl_setOrthoFOV'" + string.Format("\"{0}\" \"{1}\" ",edittsctrl,fov));
StringBuilder sbedittsctrl = null;
if (edittsctrl != null)
     sbedittsctrl = new StringBuilder(edittsctrl, 1024);

SafeNativeMethods.mwle_fnEditTSCtrl_setOrthoFOV(sbedittsctrl, fov);
}
/// <summary>
/// @brief Launches the OS file browser
/// 
///    After an Execute() call, the chosen file name and path is available in one of two areas.  
///    If only a single file selection is permitted, the results will be stored in the @a fileName 
///    attribute.
/// 
///    If multiple file selection is permitted, the results will be stored in the 
///    @a files array.  The total number of files in the array will be stored in the 
///    @a fileCount attribute.
/// 
///    @tsexample
///    // NOTE: This is not he preferred class to use, but this still works
///    // Create the file dialog
///    %baseFileDialog = new FileDialog()
///    {
///       // Allow browsing of all file types
///       filters = \"*.*\";
///       // No default file
///       defaultFile = ;
///       // Set default path relative to project
///       defaultPath = \"./\";
///       // Set the title
///       title = \"Durpa\";
///       // Allow changing of path you are browsing
///       changePath = true;
///    };
///     // Launch the file dialog
///     %baseFileDialog.Execute();
///     
///     // Don't forget to cleanup
///     %baseFileDialog.delete();
/// 
///     // A better alternative is to use the 
///     // derived classes which are specific to file open and save
///     // Create a dialog dedicated to opening files
///     %openFileDlg = new OpenFileDialog()
///     {
///        // Look for jpg image files
///        // First part is the descriptor|second part is the extension
///        Filters = \"Jepg Files|*.jpg\";
///        // Allow browsing through other folders
///        ChangePath = true;
///        // Only allow opening of one file at a time
///        MultipleFiles = false;
///     };
///     // Launch the open file dialog
///     %result = %openFileDlg.Execute();
///     // Obtain the chosen file name and path
///     if ( %result )
///     {
///        %seletedFile = %openFileDlg.file;
///     }
///     else
///     {
///        %selectedFile = \"\";
///     }
///     // Cleanup
///     %openFileDlg.delete();
/// 
///     // Create a dialog dedicated to saving a file
///     %saveFileDlg = new SaveFileDialog()
///     {
///        // Only allow for saving of COLLADA files
///        Filters = \"COLLADA Files (*.dae)|*.dae|\";
///        // Default save path to where the WorldEditor last saved
///        DefaultPath = $pref::WorldEditor::LastPath;
///        // No default file specified
///        DefaultFile = \"\";
///        // Do not allow the user to change to a new directory
///        ChangePath = false;
///        // Prompt the user if they are going to overwrite an existing file
///        OverwritePrompt = true;
///     };
///     // Launch the save file dialog
///     %result = %saveFileDlg.Execute();
///     // Obtain the file name
///     %selectedFile = \"\";
///     if ( %result )
///        %selectedFile = %saveFileDlg.file;
///     // Cleanup
///     %saveFileDlg.delete();
///    @endtsexample
/// 
///    @return True if the file was selected was successfully found (opened) or declared (saved).)
/// 
/// </summary>

public bool fnFileDialog_Execute (string filedialog)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileDialog_Execute'" + string.Format("\"{0}\" ",filedialog));
StringBuilder sbfiledialog = null;
if (filedialog != null)
     sbfiledialog = new StringBuilder(filedialog, 1024);

return  SafeNativeMethods.mwle_fnFileDialog_Execute(sbfiledialog)>=1;
}
/// <summary>
/// @brief Close the file.
///    
///    It is EXTREMELY important that you call this function when you are finished reading or writing to a file. 
///    Failing to do so is not only a bad programming practice, but could result in bad data or corrupt files. 
///    Remember: Open, Read/Write, Close, Delete...in that order!
///    
///    @tsexample
///    // Create a file object for reading
///    %fileRead = new FileObject();
///    // Open a text file, if it exists
///    %fileRead.OpenForRead(\"./test.txt\");
///    // Peek the first line
///    %line = %fileRead.peekLine();
///    // Print the line we just peeked
///    echo(%line);
///    // If we peek again...
///    %line = %fileRead.peekLine();
///    // We will get the same output as the first time
///    // since the stream did not move forward
///    echo(%line);
///    // Close the file when finished
///    %fileWrite.close();
///    // Cleanup the file object
///    %fileWrite.delete();
///    @endtsexample)
/// 
/// </summary>

public void fnFileObject_close (string fileobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_close'" + string.Format("\"{0}\" ",fileobject));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);

SafeNativeMethods.mwle_fnFileObject_close(sbfileobject);
}
/// <summary>
/// @brief Determines if the parser for this FileObject has reached the end of the file
///    
///    @tsexample
///    // Create a file object for reading
///    %fileRead = new FileObject();
///    // Open a text file, if it exists
///    %fileRead.OpenForRead(\"./test.txt\");
///    // Keep reading until we reach the end of the file
///    while( !%fileRead.isEOF() )
///    {
///       %line = %fileRead.readline();
///       echo(%line);
///    }
///    // Made it to the end
///    echo(\"Finished reading file\");
///    @endtsexample
/// 
///    @return True if the parser has reached the end of the file, false otherwise)
/// 
/// </summary>

public bool fnFileObject_isEOF (string fileobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_isEOF'" + string.Format("\"{0}\" ",fileobject));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);

return  SafeNativeMethods.mwle_fnFileObject_isEOF(sbfileobject)>=1;
}
/// <summary>
/// @brief Open a specified file for writing, adding data to the end of the file
///    
///    There is no limit as to what kind of file you can write. Any format and data is allowable, not just text. Unlike openForWrite(), 
///    which will erase an existing file if it is opened, openForAppend() preserves data in an existing file and adds to it.
/// 
///    @param filename Path, name, and extension of file to append to
///    
///    @tsexample
///    // Create a file object for writing
///    %fileWrite = new FileObject();
///    // Open a file to write to, if it does not exist it will be created
///    // If it does exist, whatever we write will be added to the end
///    %result = %fileWrite.OpenForAppend(\"./test.txt\");
///    @endtsexample
/// 
///    @return True if file was successfully opened, false otherwise)
/// 
/// </summary>

public bool fnFileObject_openForAppend (string fileobject, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_openForAppend'" + string.Format("\"{0}\" \"{1}\" ",fileobject,filename));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fnFileObject_openForAppend(sbfileobject, sbfilename)>=1;
}
/// <summary>
/// @brief Open a specified file for reading
///    
///    There is no limit as to what kind of file you can read. Any format and data contained within is accessible, not just text
/// 
///    @param filename Path, name, and extension of file to be read
///    
///    @tsexample
///    // Create a file object for reading
///    %fileRead = new FileObject();
///    // Open a text file, if it exists
///    %result = %fileRead.OpenForRead(\"./test.txt\");
///    @endtsexample
/// 
///    @return True if file was successfully opened, false otherwise)
/// 
/// </summary>

public bool fnFileObject_openForRead (string fileobject, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_openForRead'" + string.Format("\"{0}\" \"{1}\" ",fileobject,filename));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fnFileObject_openForRead(sbfileobject, sbfilename)>=1;
}
/// <summary>
/// @brief Open a specified file for writing
///    
///    There is no limit as to what kind of file you can write. Any format and data is allowable, not just text
/// 
///    @param filename Path, name, and extension of file to write to
///    
///    @tsexample
///    // Create a file object for writing
///    %fileWrite = new FileObject();
///    // Open a file to write to, if it does not exist it will be created
///    %result = %fileWrite.OpenForWrite(\"./test.txt\");
///    @endtsexample
/// 
///    @return True if file was successfully opened, false otherwise)
/// 
/// </summary>

public bool fnFileObject_openForWrite (string fileobject, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_openForWrite'" + string.Format("\"{0}\" \"{1}\" ",fileobject,filename));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fnFileObject_openForWrite(sbfileobject, sbfilename)>=1;
}
/// <summary>
/// @brief Read a line from the file without moving the stream position.
///    
///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  
///    There is no limitation as to what kind of data you can read. Unlike readLine, the parser does not move forward after reading.
/// 
///    @param filename Path, name, and extension of file to be read
///    
///    @tsexample
///    // Create a file object for reading
///    %fileRead = new FileObject();
///    // Open a text file, if it exists
///    %fileRead.OpenForRead(\"./test.txt\");
///    // Peek the first line
///    %line = %fileRead.peekLine();
///    // Print the line we just peeked
///    echo(%line);
///    // If we peek again...
///    %line = %fileRead.peekLine();
///    // We will get the same output as the first time
///    // since the stream did not move forward
///    echo(%line);
///    @endtsexample
/// 
///    @return String containing the line of data that was just peeked)
/// 
/// </summary>

public string fnFileObject_peekLine (string fileobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_peekLine'" + string.Format("\"{0}\" ",fileobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);

SafeNativeMethods.mwle_fnFileObject_peekLine(sbfileobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Read a line from file.
///    
///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  
///    There is no limitation as to what kind of data you can read.
///    
///    @tsexample
///    // Create a file object for reading
///    %fileRead = new FileObject();
///    // Open a text file, if it exists
///    %fileRead.OpenForRead(\"./test.txt\");
///    // Read in the first line
///    %line = %fileRead.readline();
///    // Print the line we just read
///    echo(%line);
///    @endtsexample
/// 
///    @return String containing the line of data that was just read)
/// 
/// </summary>

public string fnFileObject_readLine (string fileobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_readLine'" + string.Format("\"{0}\" ",fileobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);

SafeNativeMethods.mwle_fnFileObject_readLine(sbfileobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Write a line to the file, if it was opened for writing.
///    
///    There is no limit as to what kind of text you can write. Any format and data is allowable, not just text. 
///    Be careful of what you write, as whitespace, current values, and literals will be preserved.
/// 
///    @param text The data we are writing out to file.
///    
///    @tsexample
///    // Create a file object for writing
///    %fileWrite = new FileObject();
///    // Open a file to write to, if it does not exist it will be created
///    %fileWrite.OpenForWrite(\"./test.txt\");
///    // Write a line to the text files
///    %fileWrite.writeLine(\"READ. READ CODE. CODE\");
///    @endtsexample
/// 
///    @return True if file was successfully opened, false otherwise)
/// 
/// </summary>

public void fnFileObject_writeLine (string fileobject, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileObject_writeLine'" + string.Format("\"{0}\" \"{1}\" ",fileobject,text));
StringBuilder sbfileobject = null;
if (fileobject != null)
     sbfileobject = new StringBuilder(fileobject, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnFileObject_writeLine(sbfileobject, sbtext);
}
/// <summary>
/// @brief Close the file. You can no longer read or write to it unless you open it again.
///    
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
///    
///    @see open())
/// 
/// </summary>

public void fnFileStreamObject_close (string filestreamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileStreamObject_close'" + string.Format("\"{0}\" ",filestreamobject));
StringBuilder sbfilestreamobject = null;
if (filestreamobject != null)
     sbfilestreamobject = new StringBuilder(filestreamobject, 1024);

SafeNativeMethods.mwle_fnFileStreamObject_close(sbfilestreamobject);
}
/// <summary>
/// @brief Open a file for reading, writing, reading and writing, or appending
///    
///    Using \"Read\" for the open mode allows you to parse the contents of file, but not making modifications. \"Write\" will create a new 
///    file if it does not exist, or erase the contents of an existing file when opened. Write also allows you to modify the contents of the file.
/// 
///    \"ReadWrite\" will provide the ability to parse data (read it in) and manipulate data (write it out) interchangeably. Keep in mind the stream can 
///    move during each operation. Finally, \"WriteAppend\" will open a file if it exists, but will not clear the contents. You can write new data starting 
///     at the end of the files existing contents.
/// 
///    @param filename Name of file to open
///    @param openMode One of \"Read\", \"Write\", \"ReadWrite\" or \"WriteAppend\"
/// 
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Get the status and print it
///    %status = %fsObject.getStatus();
///    echo(%status);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return True if the file was successfully opened, false if something went wrong
///    
///    @see close())
/// 
/// </summary>

public bool fnFileStreamObject_open (string filestreamobject, string filename, string openMode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFileStreamObject_open'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",filestreamobject,filename,openMode));
StringBuilder sbfilestreamobject = null;
if (filestreamobject != null)
     sbfilestreamobject = new StringBuilder(filestreamobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbopenMode = null;
if (openMode != null)
     sbopenMode = new StringBuilder(openMode, 1024);

return  SafeNativeMethods.mwle_fnFileStreamObject_open(sbfilestreamobject, sbfilename, sbopenMode)>=1;
}
/// <summary>
/// @brief Set whether the vehicle should temporarily use the createHoverHeight 
///    specified in the datablock.This can help avoid problems with spawning.
///    @param enabled true to use the datablock createHoverHeight, false otherwise )
/// 
/// </summary>

public void fnFlyingVehicle_useCreateHeight (string flyingvehicle, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnFlyingVehicle_useCreateHeight'" + string.Format("\"{0}\" \"{1}\" ",flyingvehicle,enabled));
StringBuilder sbflyingvehicle = null;
if (flyingvehicle != null)
     sbflyingvehicle = new StringBuilder(flyingvehicle, 1024);

SafeNativeMethods.mwle_fnFlyingVehicle_useCreateHeight(sbflyingvehicle, enabled);
}
/// <summary>
/// .)
/// 
/// </summary>

public void fnForest_addItem (string forest, string data, string position, float rotation, float scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnForest_addItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",forest,data,position,rotation,scale));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);

SafeNativeMethods.mwle_fnForest_addItem(sbforest, sbdata, sbposition, rotation, scale);
}
/// <summary>
/// .)
/// 
/// </summary>

public void fnForest_addItemWithTransform (string forest, string data, string trans, float scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnForest_addItemWithTransform'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",forest,data,trans,scale));
StringBuilder sbforest = null;
if (forest != null)
     sbforest = new StringBuilder(forest, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);
StringBuilder sbtrans = null;
if (trans != null)
     sbtrans = new StringBuilder(trans, 1024);

SafeNativeMethods.mwle_fnForest_addItemWithTransform(sbforest, sbdata, sbtrans, scale);
}
/// <summary>
/// @brief Mounts the wind emitter to another scene object
/// 
///    @param objectID Unique ID of the object wind emitter should attach to
///    
///    @tsexample
///    // Wind emitter previously created and named %windEmitter
///    // Going to attach it to the player, making him a walking wind storm
///    %windEmitter.attachToObject(%player);
///    @endtsexample)
/// 
/// </summary>

public void fnForestWindEmitter_attachToObject (string forestwindemitter, uint objectID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnForestWindEmitter_attachToObject'" + string.Format("\"{0}\" \"{1}\" ",forestwindemitter,objectID));
StringBuilder sbforestwindemitter = null;
if (forestwindemitter != null)
     sbforestwindemitter = new StringBuilder(forestwindemitter, 1024);

SafeNativeMethods.mwle_fnForestWindEmitter_attachToObject(sbforestwindemitter, objectID);
}
/// <summary>
/// @brief Apply an impulse to this object as defined by a world position and velocity vector.
/// 
///    @param pos impulse world position
///    @param vel impulse velocity (impulse force F = m * v)
///    @return Always true
/// 
///    @note Not all objects that derrive from GameBase have this defined.)
/// 
/// </summary>

public bool fnGameBase_applyImpulse (string gamebase, string pos, string vel)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameBase_applyImpulse'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",gamebase,pos,vel));
StringBuilder sbgamebase = null;
if (gamebase != null)
     sbgamebase = new StringBuilder(gamebase, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbvel = null;
if (vel != null)
     sbvel = new StringBuilder(vel, 1024);

return  SafeNativeMethods.mwle_fnGameBase_applyImpulse(sbgamebase, sbpos, sbvel)>=1;
}
/// <summary>
/// @brief Applies a radial impulse to the object using the given origin and force.
/// 
///    @param origin World point of origin of the radial impulse.
///    @param radius The radius of the impulse area.
///    @param magnitude The strength of the impulse.
///    
///    @note Not all objects that derrive from GameBase have this defined.)
/// 
/// </summary>

public void fnGameBase_applyRadialImpulse (string gamebase, string origin, float radius, float magnitude)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameBase_applyRadialImpulse'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",gamebase,origin,radius,magnitude));
StringBuilder sbgamebase = null;
if (gamebase != null)
     sbgamebase = new StringBuilder(gamebase, 1024);
StringBuilder sborigin = null;
if (origin != null)
     sborigin = new StringBuilder(origin, 1024);

SafeNativeMethods.mwle_fnGameBase_applyRadialImpulse(sbgamebase, sborigin, radius, magnitude);
}
/// <summary>
/// @brief Get the datablock used by this object.
///    @return the datablock this GameBase is using.
///    @see setDataBlock())
/// 
/// </summary>

public int fnGameBase_getDataBlock (string gamebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameBase_getDataBlock'" + string.Format("\"{0}\" ",gamebase));
StringBuilder sbgamebase = null;
if (gamebase != null)
     sbgamebase = new StringBuilder(gamebase, 1024);

return  SafeNativeMethods.mwle_fnGameBase_getDataBlock(sbgamebase);
}
/// <summary>
/// @brief Assign this GameBase to use the specified datablock.
///    @param data new datablock to use
///    @return true if successful, false if failed.
///    @see getDataBlock())
/// 
/// </summary>

public bool fnGameBase_setDataBlock (string gamebase, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameBase_setDataBlock'" + string.Format("\"{0}\" \"{1}\" ",gamebase,data));
StringBuilder sbgamebase = null;
if (gamebase != null)
     sbgamebase = new StringBuilder(gamebase, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

return  SafeNativeMethods.mwle_fnGameBase_setDataBlock(sbgamebase, sbdata)>=1;
}
/// <summary>
/// @brief Called by the server during phase 2 of the mission download to start sending ghosts to the client.
///    
///    Ghosts represent objects on the server that are in scope for the client.  These need 
///    to be synchronized with the client in order for the client to see and interact with them.  
///    This is typically done during the standard mission start phase 2 when following Torque's 
///    example mission startup sequence.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 1.5)
///          return;
///       %client.currentPhase = 2;
///    
///       // Set the player datablock choice
///       %client.playerDB = %playerDB;
///    
///       // Update mod paths, this needs to get there before the objects.
///       %client.transmitPaths();
///    
///       // Start ghosting objects to the client
///       %client.activateGhosting();
///    }
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public void fnGameConnection_activateGhosting (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_activateGhosting'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_activateGhosting(sbgameconnection);
}
/// <summary>
/// @brief Sets the size of the chase camera's matrix queue.
///    @note This sets the queue size across all GameConnections.
///    @note This is not currently hooked up.)
/// 
/// </summary>

public bool fnGameConnection_chaseCam (string gameconnection, int size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_chaseCam'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,size));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_chaseCam(sbgameconnection, size)>=1;
}
/// <summary>
/// @brief Clear the connection's camera object reference.
///    
///    @see GameConnection::setCameraObject() and GameConnection::getCameraObject())
/// 
/// </summary>

public void fnGameConnection_clearCameraObject (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_clearCameraObject'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_clearCameraObject(sbgameconnection);
}
/// <summary>
/// @brief Clear any display device.
///    A display device may define a number of properties that are used during rendering.)
/// 
/// </summary>

public void fnGameConnection_clearDisplayDevice (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_clearDisplayDevice'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_clearDisplayDevice(sbgameconnection);
}
/// <summary>
/// ),
///    @brief On the server, disconnect a client and pass along an optional reason why.
/// 
///    This method performs two operations: it disconnects a client connection from the server, 
///    and it deletes the connection object.  The optional reason is sent in the disconnect packet 
///    and is often displayed to the user so they know why they've been disconnected.
///    
///    @param reason [optional] The reason why the user has been disconnected from the server.
///    
///    @tsexample
///    function kick(%client)
///    {
///       messageAll( 'MsgAdminForce', '\\c2The Admin has kicked %1.', %client.playerName);
///    
///       if (!%client.isAIControlled())
///          BanList::add(%client.guid, %client.getAddress(), $Pref::Server::KickBanTime);
///       %client.delete(\"You have been kicked from this server\");
///    }
///    @endtsexample)
/// 
/// </summary>

public void fnGameConnection_delete (string gameconnection, string reason)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_delete'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,reason));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbreason = null;
if (reason != null)
     sbreason = new StringBuilder(reason, 1024);

SafeNativeMethods.mwle_fnGameConnection_delete(sbgameconnection, sbreason);
}
/// <summary>
/// @brief Returns the connection's camera object used when not viewing through the control object.
///    
///    @see GameConnection::setCameraObject() and GameConnection::clearCameraObject())
/// 
/// </summary>

public string fnGameConnection_getCameraObject (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getCameraObject'" + string.Format("\"{0}\" ",gameconnection));
var returnbuff = new StringBuilder(1024);
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_getCameraObject(sbgameconnection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the default field of view as used by the control object's camera.)
/// 
/// </summary>

public float fnGameConnection_getControlCameraDefaultFov (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getControlCameraDefaultFov'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_getControlCameraDefaultFov(sbgameconnection);
}
/// <summary>
/// @brief Returns the field of view as used by the control object's camera.)
/// 
/// </summary>

public float fnGameConnection_getControlCameraFov (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getControlCameraFov'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_getControlCameraFov(sbgameconnection);
}
/// <summary>
/// @brief On the server, returns the object that the client is controlling.
///    By default the control object is an instance of the Player class, but can also be an instance 
///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
///    appropriate for the game.
///    @see GameConnection::setControlObject())
/// 
/// </summary>

public string fnGameConnection_getControlObject (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getControlObject'" + string.Format("\"{0}\" ",gameconnection));
var returnbuff = new StringBuilder(1024);
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_getControlObject(sbgameconnection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the connection's control scheme absolute rotation property.
///    
///    @return True if the connection's control object should use an absolute rotation control scheme.
///    @see GameConnection::setControlSchemeParameters())
/// 
/// </summary>

public bool fnGameConnection_getControlSchemeAbsoluteRotation (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getControlSchemeAbsoluteRotation'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_getControlSchemeAbsoluteRotation(sbgameconnection)>=1;
}
/// <summary>
/// @brief On the client, get the control object's damage flash level.
///    @return flash level)
/// 
/// </summary>

public float fnGameConnection_getDamageFlash (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getDamageFlash'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_getDamageFlash(sbgameconnection);
}
/// <summary>
/// @brief On the client, get the control object's white-out level.
///    @return white-out level)
/// 
/// </summary>

public float fnGameConnection_getWhiteOut (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_getWhiteOut'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_getWhiteOut(sbgameconnection);
}
/// <summary>
/// @brief Returns true if this connection is AI controlled.
///    @see AIConnection)
/// 
/// </summary>

public bool fnGameConnection_isAIControlled (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_isAIControlled'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_isAIControlled(sbgameconnection)>=1;
}
/// <summary>
/// @brief Returns true if the object being controlled by the client is making use 
///    of a rotation damped camera.
///    @see Camera)
/// 
/// </summary>

public bool fnGameConnection_isControlObjectRotDampedCamera (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_isControlObjectRotDampedCamera'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_isControlObjectRotDampedCamera(sbgameconnection)>=1;
}
/// <summary>
/// @brief Returns true if a previously recorded demo file is now playing.
///    
///    @see GameConnection::playDemo())
/// 
/// </summary>

public bool fnGameConnection_isDemoPlaying (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_isDemoPlaying'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_isDemoPlaying(sbgameconnection)>=1;
}
/// <summary>
/// @brief Returns true if a demo file is now being recorded.
///    
///    @see GameConnection::startRecording(), GameConnection::stopRecording())
/// 
/// </summary>

public bool fnGameConnection_isDemoRecording (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_isDemoRecording'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_isDemoRecording(sbgameconnection)>=1;
}
/// <summary>
/// @brief Returns true if this connection is in first person mode.
/// 
///    @note Transition to first person occurs over time via mCameraPos, so this 
///    won't immediately return true after a set.)
/// 
/// </summary>

public bool fnGameConnection_isFirstPerson (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_isFirstPerson'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_isFirstPerson(sbgameconnection)>=1;
}
/// <summary>
/// @brief List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.
///    @note The list is sent to the console.)
/// 
/// </summary>

public void fnGameConnection_listClassIDs (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_listClassIDs'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_listClassIDs(sbgameconnection);
}
/// <summary>
///  )
/// 
/// </summary>

public bool fnGameConnection_LoadDatablocksFromFile (string gameconnection, uint crc)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_LoadDatablocksFromFile'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,crc));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_LoadDatablocksFromFile(sbgameconnection, crc)>=1;
}
/// <summary>
/// @brief Used on the server to play a 2D sound that is not attached to any object.
/// 
///    @param profile The SFXProfile that defines the sound to play.
/// 
///    @tsexample
///    function ServerPlay2D(%profile)
///    {
///       // Play the given sound profile on every client.
///       // The sounds will be transmitted as an event, not attached to any object.
///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
///          ClientGroup.getObject(%idx).play2D(%profile);
///    }
///    @endtsexample)
/// 
/// </summary>

public bool fnGameConnection_play2D (string gameconnection, string profile)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_play2D'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,profile));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbprofile = null;
if (profile != null)
     sbprofile = new StringBuilder(profile, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_play2D(sbgameconnection, sbprofile)>=1;
}
/// <summary>
/// @brief Used on the server to play a 3D sound that is not attached to any object.
///    
///    @param profile The SFXProfile that defines the sound to play.
///    @param location The position and orientation of the 3D sound given in the form of \"x y z ax ay az aa\".
/// 
///    @tsexample
///    function ServerPlay3D(%profile,%transform)
///    {
///       // Play the given sound profile at the given position on every client
///       // The sound will be transmitted as an event, not attached to any object.
///       for(%idx = 0; %idx  ClientGroup.getCount(); %idx++)
///          ClientGroup.getObject(%idx).play3D(%profile,%transform);
///    }
///    @endtsexample)
/// 
/// </summary>

public bool fnGameConnection_play3D (string gameconnection, string profile, string location)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_play3D'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",gameconnection,profile,location));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbprofile = null;
if (profile != null)
     sbprofile = new StringBuilder(profile, 1024);
StringBuilder sblocation = null;
if (location != null)
     sblocation = new StringBuilder(location, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_play3D(sbgameconnection, sbprofile, sblocation)>=1;
}
/// <summary>
/// @brief On the client, play back a previously recorded game session.
///    
///    It is often useful to play back a game session.  This could be for producing a 
///    demo of the game that will be shown at a later time, or for debugging a game.  
///    By recording the entire network stream it is possible to later play game the game 
///    exactly as it unfolded during the actual play session.  This is because all user 
///    control and server results pass through the connection.
/// 
///    @returns True if the playback was successful.  False if there was an issue, such as 
///    not being able to open the demo file for playback.
///    
///    @see GameConnection::startRecording(), GameConnection::stopRecording())
/// 
/// </summary>

public bool fnGameConnection_playDemo (string gameconnection, string demoFileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_playDemo'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,demoFileName));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbdemoFileName = null;
if (demoFileName != null)
     sbdemoFileName = new StringBuilder(demoFileName, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_playDemo(sbgameconnection, sbdemoFileName)>=1;
}
/// <summary>
/// @brief On the server, resets the connection to indicate that ghosting has been disabled.
/// 
///    Typically when a mission has ended on the server, all connected clients are informed of this change 
///    and their connections are reset back to a starting state.  This method resets a connection on the 
///    server to indicate that ghosts are no longer being transmitted.  On the client end, all ghost 
///    information will be deleted.
/// 
///    @tsexample
///       // Inform the clients
///       for (%clientIndex = 0; %clientIndex  ClientGroup.getCount(); %clientIndex++)
///       {
///          // clear ghosts and paths from all clients
///          %cl = ClientGroup.getObject(%clientIndex);
///          %cl.endMission();
///          %cl.resetGhosting();
///          %cl.clearPaths();
///       }
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public void fnGameConnection_resetGhosting (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_resetGhosting'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_resetGhosting(sbgameconnection);
}
/// <summary>
/// @brief On the server, sets the client's 3D display to fade to black.
///    @param doFade Set to true to fade to black, and false to fade from black.
///    @param timeMS Time it takes to perform the fade as measured in ms.
///    @note Not currently hooked up, and is not synchronized over the network.)
/// 
/// </summary>

public void fnGameConnection_setBlackOut (string gameconnection, bool doFade, int timeMS)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setBlackOut'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",gameconnection,doFade,timeMS));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_setBlackOut(sbgameconnection, doFade, timeMS);
}
/// <summary>
/// @brief On the server, set the connection's camera object used when not viewing 
///    through the control object.
///    
///    @see GameConnection::getCameraObject() and GameConnection::clearCameraObject())
/// 
/// </summary>

public bool fnGameConnection_setCameraObject (string gameconnection, string camera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setCameraObject'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,camera));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbcamera = null;
if (camera != null)
     sbcamera = new StringBuilder(camera, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_setCameraObject(sbgameconnection, sbcamera)>=1;
}
/// <summary>
/// (GameConnection, setConnectArgs, void, 3, 17,
///    (const char* args) @brief On the client, pass along a variable set of parameters to the server.
///    
///    Once the connection is established with the server, the server calls its onConnect() method 
///    with the client's passed in parameters as aruments.
///    
///    @see GameConnection::onConnect())
/// 
/// </summary>

public void fnGameConnection_setConnectArgs (string gameconnection, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setConnectArgs'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" ",gameconnection,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);

SafeNativeMethods.mwle_fnGameConnection_setConnectArgs(sbgameconnection, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16);
}
/// <summary>
/// @brief On the server, sets the control object's camera's field of view.
///    @param newFOV New field of view (in degrees) to force the control object's camera to use.  This value 
///    is clamped to be within the range of 1 to 179 degrees.
///    @note When transmitted over the network to the client, the resolution is limited to 
///    one degree.  Any fraction is dropped.)
/// 
/// </summary>

public void fnGameConnection_setControlCameraFov (string gameconnection, float newFOV)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setControlCameraFov'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,newFOV));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_setControlCameraFov(sbgameconnection, newFOV);
}
/// <summary>
/// @brief On the server, sets the object that the client will control.
///    By default the control object is an instance of the Player class, but can also be an instance 
///    of Camera (when editing the mission, for example), or any other ShapeBase derived class as 
///    appropriate for the game.
///    @param ctrlObj The GameBase object on the server to control.)
/// 
/// </summary>

public bool fnGameConnection_setControlObject (string gameconnection, string ctrlObj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setControlObject'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,ctrlObj));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbctrlObj = null;
if (ctrlObj != null)
     sbctrlObj = new StringBuilder(ctrlObj, 1024);

return  SafeNativeMethods.mwle_fnGameConnection_setControlObject(sbgameconnection, sbctrlObj)>=1;
}
/// <summary>
/// @brief Set the control scheme that may be used by a connection's control object.
///    
///    @param absoluteRotation Use absolute rotation values from client, likely through ExtendedMove.
///    @param addYawToAbsRot Add relative yaw control to the absolute rotation calculation.  Only useful when absoluteRotation is true. )
/// 
/// </summary>

public void fnGameConnection_setControlSchemeParameters (string gameconnection, bool absoluteRotation, bool addYawToAbsRot, bool addPitchToAbsRot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setControlSchemeParameters'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",gameconnection,absoluteRotation,addYawToAbsRot,addPitchToAbsRot));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_setControlSchemeParameters(sbgameconnection, absoluteRotation, addYawToAbsRot, addPitchToAbsRot);
}
/// <summary>
/// @brief On the server, sets this connection into or out of first person mode.
///    
///    @param firstPerson Set to true to put the connection into first person mode.)
/// 
/// </summary>

public void fnGameConnection_setFirstPerson (string gameconnection, bool firstPerson)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setFirstPerson'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,firstPerson));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_setFirstPerson(sbgameconnection, firstPerson);
}
/// <summary>
/// @brief On the client, set the password that will be passed to the server.
///               
///               On the server, this password is compared with what is stored in $pref::Server::Password.  
///               If $pref::Server::Password is empty then the client's sent password is ignored.  Otherwise, 
///               if the passed in client password and the server password do not match, the CHR_PASSWORD 
///               error string is sent back to the client and the connection is immediately terminated.
///               
///               This password checking is performed quite early on in the connection request process so as 
///               to minimize the impact of multiple failed attempts -- also known as hacking.)
/// 
/// </summary>

public void fnGameConnection_setJoinPassword (string gameconnection, string password)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setJoinPassword'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,password));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbpassword = null;
if (password != null)
     sbpassword = new StringBuilder(password, 1024);

SafeNativeMethods.mwle_fnGameConnection_setJoinPassword(sbgameconnection, sbpassword);
}
/// <summary>
/// @brief On the server, transmits the mission file's CRC value to the client.
/// 
///    Typically, during the standard mission start phase 1, the mission file's CRC value 
///    on the server is send to the client.  This allows the client to determine if the mission 
///    has changed since the last time it downloaded this mission and act appropriately, such as 
///    rebuilt cached lightmaps.
/// 
///    @param CRC The mission file's CRC value on the server.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase1Ack(%client, %seq)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 0)
///          return;
///       %client.currentPhase = 1;
///    
///       // Start with the CRC
///       %client.setMissionCRC( $missionCRC );
///    
///       // Send over the datablocks...
///       // OnDataBlocksDone will get called when have confirmation
///       // that they've all been received.
///       %client.transmitDataBlocks($missionSequence);
///    }
///    @endtsexample)
/// 
/// </summary>

public void fnGameConnection_setMissionCRC (string gameconnection, int CRC)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_setMissionCRC'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,CRC));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_setMissionCRC(sbgameconnection, CRC);
}
/// <summary>
/// @brief On the client, starts recording the network connection's traffic to a demo file.
///    
///    It is often useful to play back a game session.  This could be for producing a 
///    demo of the game that will be shown at a later time, or for debugging a game.  
///    By recording the entire network stream it is possible to later play game the game 
///    exactly as it unfolded during the actual play session.  This is because all user 
///    control and server results pass through the connection.
///    
///    @param fileName The file name to use for the demo recording.
///    
///    @see GameConnection::stopRecording(), GameConnection::playDemo())
/// 
/// </summary>

public void fnGameConnection_startRecording (string gameconnection, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_startRecording'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,fileName));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fnGameConnection_startRecording(sbgameconnection, sbfileName);
}
/// <summary>
/// @brief On the client, stops the recording of a connection's network traffic to a file.
///    
///    @see GameConnection::startRecording(), GameConnection::playDemo())
/// 
/// </summary>

public void fnGameConnection_stopRecording (string gameconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_stopRecording'" + string.Format("\"{0}\" ",gameconnection));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_stopRecording(sbgameconnection);
}
/// <summary>
/// @brief Sent by the server during phase 1 of the mission download to send the datablocks to the client.
///    
///    SimDataBlocks, also known as just datablocks, need to be transmitted to the client 
///    prior to the client entering the game world.  These represent the static data that 
///    most objects in the world reference.  This is typically done during the standard 
///    mission start phase 1 when following Torque's example mission startup sequence.
/// 
///    When the datablocks have all been transmitted, onDataBlocksDone() is called to move 
///    the mission start process to the next phase.
/// 
///    @param sequence The sequence is common between the server and client and ensures 
///    that the client is acting on the most recent mission start process.  If an errant 
///    network packet (one that was lost but has now been found) is received by the client 
///    with an incorrect sequence, it is just ignored.  This sequence number is updated on 
///    the server every time a mission is loaded.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase1Ack(%client, %seq)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 0)
///          return;
///       %client.currentPhase = 1;
///    
///       // Start with the CRC
///       %client.setMissionCRC( $missionCRC );
///    
///       // Send over the datablocks...
///       // OnDataBlocksDone will get called when have confirmation
///       // that they've all been received.
///       %client.transmitDataBlocks($missionSequence);
///    }
///    @endtsexample
///    
///    @see GameConnection::onDataBlocksDone())
/// 
/// </summary>

public void fnGameConnection_transmitDataBlocks (string gameconnection, int sequence)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGameConnection_transmitDataBlocks'" + string.Format("\"{0}\" \"{1}\" ",gameconnection,sequence));
StringBuilder sbgameconnection = null;
if (gameconnection != null)
     sbgameconnection = new StringBuilder(gameconnection, 1024);

SafeNativeMethods.mwle_fnGameConnection_transmitDataBlocks(sbgameconnection, sequence);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force trigger an inspectPostApply. This will transmit 
///                    material and other fields to client objects.
///                    )
/// 
/// </summary>

public void fnGroundPlane_postApply (string groundplane)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGroundPlane_postApply'" + string.Format("\"{0}\" ",groundplane));
StringBuilder sbgroundplane = null;
if (groundplane != null)
     sbgroundplane = new StringBuilder(groundplane, 1024);

SafeNativeMethods.mwle_fnGroundPlane_postApply(sbgroundplane);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, add, void, 3, 5, (string name, int idNum, int scheme=0))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_add (string guiautocompletectrl, string a2, string a3, string a4)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_add'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guiautocompletectrl,a2,a3,a4));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_add(sbguiautocompletectrl, sba2, sba3, sba4);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, addScheme, void, 6, 6, (int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_addScheme (string guiautocompletectrl, string a2, string a3, string a4, string a5)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_addScheme'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guiautocompletectrl,a2,a3,a4,a5));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_addScheme(sbguiautocompletectrl, sba2, sba3, sba4, sba5);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, changeTextById, void, 4, 4, ( int id, string text ) )
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_changeTextById (string guiautocompletectrl, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_changeTextById'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiautocompletectrl,a2,a3));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_changeTextById(sbguiautocompletectrl, sba2, sba3);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, clear, void, 2, 2, Clear the popup list.)
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_clear (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_clear'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_clear(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, clearEntry, void, 3, 3, (S32 entry))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_clearEntry (string guiautocompletectrl, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_clearEntry'" + string.Format("\"{0}\" \"{1}\" ",guiautocompletectrl,a2));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_clearEntry(sbguiautocompletectrl, sba2);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, findText, S32, 3, 3, (string text)
///               Returns the position of the first entry containing the specified text.)
/// 
/// </summary>

public int fnGuiAutoCompleteCtrl_findText (string guiautocompletectrl, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_findText'" + string.Format("\"{0}\" \"{1}\" ",guiautocompletectrl,a2));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

return  SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_findText(sbguiautocompletectrl, sba2);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, forceClose, void, 2, 2, )
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_forceClose (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_forceClose'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_forceClose(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, forceOnAction, void, 2, 2, )
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_forceOnAction (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_forceOnAction'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_forceOnAction(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, getSelected, S32, 2, 2, )
/// 
/// </summary>

public int fnGuiAutoCompleteCtrl_getSelected (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_getSelected'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

return  SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_getSelected(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, getText, void, 2, 2, )
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_getText (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_getText'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_getText(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, getTextById, const char*, 3, 3,  (int id))
/// 
/// </summary>

public string fnGuiAutoCompleteCtrl_getTextById (string guiautocompletectrl, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_getTextById'" + string.Format("\"{0}\" \"{1}\" ",guiautocompletectrl,a2));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_getTextById(sbguiautocompletectrl, sba2, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( GuiAutoCompleteCtrl, replaceText, void, 3, 3, (bool doReplaceText))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_replaceText (string guiautocompletectrl, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_replaceText'" + string.Format("\"{0}\" \"{1}\" ",guiautocompletectrl,a2));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_replaceText(sbguiautocompletectrl, sba2);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, setEnumContent, void, 4, 4, (string class, string enum)
///               This fills the popup with a classrep's field enumeration type info.
///               More of a helper function than anything.   If console access to the field list is added, 
///               at least for the enumerated types, then this should go away..)
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_setEnumContent (string guiautocompletectrl, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_setEnumContent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiautocompletectrl,a2,a3));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_setEnumContent(sbguiautocompletectrl, sba2, sba3);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, setFirstSelected, void, 2, 3, ([scriptCallback=true]))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_setFirstSelected (string guiautocompletectrl, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_setFirstSelected'" + string.Format("\"{0}\" \"{1}\" ",guiautocompletectrl,a2));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_setFirstSelected(sbguiautocompletectrl, sba2);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, setNoneSelected, void, 2, 2, )
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_setNoneSelected (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_setNoneSelected'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_setNoneSelected(sbguiautocompletectrl);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, setSelected, void, 3, 4, (int id, [scriptCallback=true]))
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_setSelected (string guiautocompletectrl, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_setSelected'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiautocompletectrl,a2,a3));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_setSelected(sbguiautocompletectrl, sba2, sba3);
}
/// <summary>
/// ( GuiAutoCompleteCtrl, size, S32, 2, 2, Get the size of the menu - the number of entries in it.)
/// 
/// </summary>

public int fnGuiAutoCompleteCtrl_size (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_size'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

return  SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_size(sbguiautocompletectrl);
}
/// <summary>
/// (GuiAutoCompleteCtrl, sort, void, 2, 2, Sort the list alphabetically.)
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_sort (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_sort'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_sort(sbguiautocompletectrl);
}
/// <summary>
/// (GuiAutoCompleteCtrl, sortID, void, 2, 2, Sort the list by ID.)
/// 
/// </summary>

public void fnGuiAutoCompleteCtrl_sortID (string guiautocompletectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoCompleteCtrl_sortID'" + string.Format("\"{0}\" ",guiautocompletectrl));
StringBuilder sbguiautocompletectrl = null;
if (guiautocompletectrl != null)
     sbguiautocompletectrl = new StringBuilder(guiautocompletectrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoCompleteCtrl_sortID(sbguiautocompletectrl);
}
/// <summary>
/// Reset scrolling. )
/// 
/// </summary>

public void fnGuiAutoScrollCtrl_reset (string guiautoscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiAutoScrollCtrl_reset'" + string.Format("\"{0}\" ",guiautoscrollctrl));
StringBuilder sbguiautoscrollctrl = null;
if (guiautoscrollctrl != null)
     sbguiautoscrollctrl = new StringBuilder(guiautoscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiAutoScrollCtrl_reset(sbguiautoscrollctrl);
}
/// <summary>
/// Set the bitmap to show on the button.
///    @param path Path to the texture file in any of the supported formats. )
/// 
/// </summary>

public void fnGuiBitmapButtonCtrl_setBitmap (string guibitmapbuttonctrl, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiBitmapButtonCtrl_setBitmap'" + string.Format("\"{0}\" \"{1}\" ",guibitmapbuttonctrl,path));
StringBuilder sbguibitmapbuttonctrl = null;
if (guibitmapbuttonctrl != null)
     sbguibitmapbuttonctrl = new StringBuilder(guibitmapbuttonctrl, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnGuiBitmapButtonCtrl_setBitmap(sbguibitmapbuttonctrl, sbpath);
}
/// <summary>
/// Set the offset of the bitmap within the control.
///    @param x The x-axis offset of the image.
///    @param y The y-axis offset of the image.)
/// 
/// </summary>

public void fnGuiBitmapCtrl_setValue (string guibitmapctrl, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiBitmapCtrl_setValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guibitmapctrl,x,y));
StringBuilder sbguibitmapctrl = null;
if (guibitmapctrl != null)
     sbguibitmapctrl = new StringBuilder(guibitmapctrl, 1024);

SafeNativeMethods.mwle_fnGuiBitmapCtrl_setValue(sbguibitmapctrl, x, y);
}
/// <summary>
/// Get the text display on the button's label (if any).
///    @return The button's label. )
/// 
/// </summary>

public string fnGuiButtonBaseCtrl_getText (string guibuttonbasectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_getText'" + string.Format("\"{0}\" ",guibuttonbasectrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_getText(sbguibuttonbasectrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Simulate a click on the button.
///    This method will trigger the button's action just as if the button had been pressed by the 
///    user. )
/// 
/// </summary>

public void fnGuiButtonBaseCtrl_performClick (string guibuttonbasectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_performClick'" + string.Format("\"{0}\" ",guibuttonbasectrl));
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_performClick(sbguibuttonbasectrl);
}
/// <summary>
/// Reset the mousing state of the button.
///    This method should not generally be called. )
/// 
/// </summary>

public void fnGuiButtonBaseCtrl_resetState (string guibuttonbasectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_resetState'" + string.Format("\"{0}\" ",guibuttonbasectrl));
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_resetState(sbguibuttonbasectrl);
}
/// <summary>
/// For toggle or radio buttons, set whether the button is currently activated or not.  For radio buttons, 
///    toggling a button on will toggle all other radio buttons in its group to off.
///    @param isOn If true, the button will be toggled on (if not already); if false, it will be toggled off.
///    @note Toggling the state of a button with this method will em>not/em> not trigger the action associated with the 
///       button.  To do that, use performClick(). )
/// 
/// </summary>

public void fnGuiButtonBaseCtrl_setStateOn (string guibuttonbasectrl, bool isOn)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_setStateOn'" + string.Format("\"{0}\" \"{1}\" ",guibuttonbasectrl,isOn));
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_setStateOn(sbguibuttonbasectrl, isOn);
}
/// <summary>
/// Set the text displayed on the button's label.
///    @param text The text to display as the button's text label.
///    @note Not all buttons render text labels.
///    @see getText
///    @see setTextID )
/// 
/// </summary>

public void fnGuiButtonBaseCtrl_setText (string guibuttonbasectrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_setText'" + string.Format("\"{0}\" \"{1}\" ",guibuttonbasectrl,text));
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_setText(sbguibuttonbasectrl, sbtext);
}
/// <summary>
/// Set the text displayed on the button's label using a string from the string table 
///    assigned to the control.
///    @param id Name of the variable that contains the integer string ID.  Used to look up 
///       string in table.
///    @note Not all buttons render text labels.
///    @see setText
///    @see getText
///    @see GuiControl::langTableMod
///    @see LangTable
///    @ref Gui_i18n )
/// 
/// </summary>

public void fnGuiButtonBaseCtrl_setTextID (string guibuttonbasectrl, string id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiButtonBaseCtrl_setTextID'" + string.Format("\"{0}\" \"{1}\" ",guibuttonbasectrl,id));
StringBuilder sbguibuttonbasectrl = null;
if (guibuttonbasectrl != null)
     sbguibuttonbasectrl = new StringBuilder(guibuttonbasectrl, 1024);
StringBuilder sbid = null;
if (id != null)
     sbid = new StringBuilder(id, 1024);

SafeNativeMethods.mwle_fnGuiButtonBaseCtrl_setTextID(sbguibuttonbasectrl, sbid);
}
/// <summary>
/// Translate a coordinate from canvas window-space to screen-space.
///    @param coordinate The coordinate in window-space.
///    @return The given coordinate translated to screen-space. )
/// 
/// </summary>

public string fnGuiCanvas_clientToScreen (string guicanvas, string coordinate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_clientToScreen'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,coordinate));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbcoordinate = null;
if (coordinate != null)
     sbcoordinate = new StringBuilder(coordinate, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_clientToScreen(sbguicanvas, sbcoordinate, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Turns on the mouse off.
/// 				   @tsexample
/// 				   Canvas.cursorOff();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_cursorOff (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_cursorOff'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_cursorOff(sbguicanvas);
}
/// <summary>
/// @brief Turns on the mouse cursor.
/// 				   @tsexample
/// 				   Canvas.cursorOn();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_cursorOn (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_cursorOn'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_cursorOn(sbguicanvas);
}
/// <summary>
/// @brief Find the first monitor index that matches the given name.
///                The actual match algorithm depends on the implementation.
///                @param name The name to search for.
/// 				   @return The number of monitors attached to the system, including the default monoitor.)
/// 
/// </summary>

public int fnGuiCanvas_findFirstMatchingMonitor (string guicanvas, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_findFirstMatchingMonitor'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,name));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_findFirstMatchingMonitor(sbguicanvas, sbname);
}
/// <summary>
/// @brief Get the GuiControl which is being used as the content.
/// 
/// 				   @tsexample
/// 				   Canvas.getContent();
/// 				   @endtsexample
/// 
/// 				   @return ID of current content control)
/// 
/// </summary>

public int fnGuiCanvas_getContent (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getContent'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_getContent(sbguicanvas);
}
/// <summary>
/// @brief Get the current position of the cursor.
/// 				   @param param Description
/// 				   @tsexample
/// 				   %cursorPos = Canvas.getCursorPos();
/// 				   @endtsexample
/// 				   @return Screen coordinates of mouse cursor, in format \"X Y\")
/// 
/// </summary>

public string fnGuiCanvas_getCursorPos (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getCursorPos'" + string.Format("\"{0}\" ",guicanvas));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getCursorPos(sbguicanvas, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the dimensions of the canvas
/// 
/// 				   @tsexample
/// 				   %extent = Canvas.getExtent();
/// 				   @endtsexample
/// 
/// 				   @return Width and height of canvas. Formatted as numerical values in a single string \"# #\")
/// 
/// </summary>

public string fnGuiCanvas_getExtent (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getExtent'" + string.Format("\"{0}\" ",guicanvas));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getExtent(sbguicanvas, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets information on the specified mode of this device.
/// 				   @param modeId Index of the mode to get data from.
/// 				   @return A video mode string given an adapter and mode index.
/// 				   @see GuiCanvas::getVideoMode())
/// 
/// </summary>

public string fnGuiCanvas_getMode (string guicanvas, int modeId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getMode'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,modeId));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getMode(sbguicanvas, modeId, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the number of modes available on this device.
/// 
/// 				   @param param Description
/// 
/// 				   @tsexample
/// 				   %modeCount = Canvas.getModeCount()
/// 				   @endtsexample
/// 
/// 				   @return The number of video modes supported by the device)
/// 
/// </summary>

public int fnGuiCanvas_getModeCount (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getModeCount'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_getModeCount(sbguicanvas);
}
/// <summary>
/// @brief Gets the number of monitors attached to the system.
/// 
/// 				   @return The number of monitors attached to the system, including the default monoitor.)
/// 
/// </summary>

public int fnGuiCanvas_getMonitorCount (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getMonitorCount'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_getMonitorCount(sbguicanvas);
}
/// <summary>
/// @brief Gets the name of the requested monitor.
///                @param index The monitor index.
/// 				   @return The name of the requested monitor.)
/// 
/// </summary>

public string fnGuiCanvas_getMonitorName (string guicanvas, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getMonitorName'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getMonitorName(sbguicanvas, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the region of the requested monitor.
///                @param index The monitor index.
/// 				   @return The rectangular region of the requested monitor.)
/// 
/// </summary>

public string fnGuiCanvas_getMonitorRect (string guicanvas, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getMonitorRect'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getMonitorRect(sbguicanvas, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the gui control under the mouse.
/// 				   @tsexample
/// 				   %underMouse = Canvas.getMouseControl();
/// 				   @endtsexample
/// 
/// 				   @return ID of the gui control, if one was found. NULL otherwise)
/// 
/// </summary>

public int fnGuiCanvas_getMouseControl (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getMouseControl'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_getMouseControl(sbguicanvas);
}
/// <summary>
/// @brief Gets the current screen mode as a string.
/// 
/// 				   The return string will contain 5 values (width, height, fullscreen, bitdepth, refreshRate). 
/// 				   You will need to parse out each one for individual use.
/// 
/// 				   @tsexample
/// 				   %screenWidth = getWord(Canvas.getVideoMode(), 0);
/// 				   %screenHeight = getWord(Canvas.getVideoMode(), 1);
/// 				   %isFullscreen = getWord(Canvas.getVideoMode(), 2);
/// 				   %bitdepth = getWord(Canvas.getVideoMode(), 3);
/// 				   %refreshRate = getWord(Canvas.getVideoMode(), 4);
/// 				   @endtsexample
/// 
/// 				   @return String formatted with screen width, screen height, screen mode, bit depth, and refresh rate.)
/// 
/// </summary>

public string fnGuiCanvas_getVideoMode (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getVideoMode'" + string.Format("\"{0}\" ",guicanvas));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getVideoMode(sbguicanvas, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the current position of the platform window associated with the canvas.
///    @return The window position of the canvas in screen-space. )
/// 
/// </summary>

public string fnGuiCanvas_getWindowPosition (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_getWindowPosition'" + string.Format("\"{0}\" ",guicanvas));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_getWindowPosition(sbguicanvas, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Disable rendering of the cursor.
/// 
/// 				   @tsexample
/// 				   Canvas.hideCursor();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_hideCursor (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_hideCursor'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_hideCursor(sbguicanvas);
}
/// <summary>
/// ( GuiCanvas, hideWindow, void, 2, 2,  )
/// 
/// </summary>

public void fnGuiCanvas_hideWindow (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_hideWindow'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_hideWindow(sbguicanvas);
}
/// <summary>
/// @brief Determines if mouse cursor is enabled.
/// 
/// 				   @tsexample
/// 				   // Is cursor on?
/// 				   if(Canvas.isCursorOn())
/// 				   	echo(\"Canvas cursor is on\");
/// 				   @endtsexample
/// 				   @return Returns true if the cursor is on.)
/// 
/// </summary>

public bool fnGuiCanvas_isCursorOn (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_isCursorOn'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_isCursorOn(sbguicanvas)>=1;
}
/// <summary>
/// @brief Determines if mouse cursor is rendering.
/// 
/// 				   @tsexample
/// 				   // Is cursor rendering?
/// 				   if(Canvas.isCursorShown())
/// 				   	echo(\"Canvas cursor is rendering\");
/// 				   @endtsexample
/// 				   @return Returns true if the cursor is rendering.)
/// 
/// </summary>

public bool fnGuiCanvas_isCursorShown (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_isCursorShown'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

return  SafeNativeMethods.mwle_fnGuiCanvas_isCursorShown(sbguicanvas)>=1;
}
/// <summary>
/// @brief This turns on/off front-buffer rendering.
/// 
/// 				   @param enable True if all rendering should be done to the front buffer
/// 
/// 				   @tsexample
/// 				   Canvas.renderFront(false);
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_renderFront (string guicanvas, bool enable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_renderFront'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,enable));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_renderFront(sbguicanvas, enable);
}
/// <summary>
/// @brief Force canvas to redraw.
///                If the elapsed time is greater than the time since the last paint 
///                then the repaint will be skipped.
///                @param elapsedMS The optional elapsed time in milliseconds.
/// 
/// 				   @tsexample
/// 				   Canvas.repaint();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_repaint (string guicanvas, int elapsedMS)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_repaint'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,elapsedMS));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_repaint(sbguicanvas, elapsedMS);
}
/// <summary>
/// @brief Reset the update regions for the canvas.
/// 
/// 				   @tsexample
/// 				   Canvas.reset();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_reset (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_reset'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_reset(sbguicanvas);
}
/// <summary>
/// Translate a coordinate from screen-space to canvas window-space.
///    @param coordinate The coordinate in screen-space.
///    @return The given coordinate translated to window-space. )
/// 
/// </summary>

public string fnGuiCanvas_screenToClient (string guicanvas, string coordinate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_screenToClient'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,coordinate));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbcoordinate = null;
if (coordinate != null)
     sbcoordinate = new StringBuilder(coordinate, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_screenToClient(sbguicanvas, sbcoordinate, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Set the content of the canvas to a specified control.
/// 
/// 				   @param ctrl ID or name of GuiControl to set content to
/// 
/// 				   @tsexample
/// 				   Canvas.setContent(PlayGui);
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_setContent (string guicanvas, string ctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_setContent'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,ctrl));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbctrl = null;
if (ctrl != null)
     sbctrl = new StringBuilder(ctrl, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_setContent(sbguicanvas, sbctrl);
}
/// <summary>
/// @brief Sets the cursor for the canvas.
/// 
/// 				   @param cursor Name of the GuiCursor to use
/// 
/// 				   @tsexample
/// 				   Canvas.setCursor(\"DefaultCursor\");
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_setCursor (string guicanvas, string cursor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_setCursor'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,cursor));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbcursor = null;
if (cursor != null)
     sbcursor = new StringBuilder(cursor, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_setCursor(sbguicanvas, sbcursor);
}
/// <summary>
/// (bool shown) - Enabled when a context menu/popup menu is shown.)
/// 
/// </summary>

public void fnGuiCanvas_setPopupShown (string guicanvas, bool shown)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_setPopupShown'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,shown));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_setPopupShown(sbguicanvas, shown);
}
/// <summary>
/// Set the position of the platform window associated with the canvas.
///    @param position The new position of the window in screen-space. )
/// 
/// </summary>

public void fnGuiCanvas_setWindowPosition (string guicanvas, string position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_setWindowPosition'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,position));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbposition = null;
if (position != null)
     sbposition = new StringBuilder(position, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_setWindowPosition(sbguicanvas, sbposition);
}
/// <summary>
/// @brief Change the title of the OS window.
/// 
/// 				   @param newTitle String containing the new name
/// 
/// 				   @tsexample
/// 				   Canvas.setWindowTitle(\"Documentation Rocks!\");
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_setWindowTitle (string guicanvas, string newTitle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_setWindowTitle'" + string.Format("\"{0}\" \"{1}\" ",guicanvas,newTitle));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);
StringBuilder sbnewTitle = null;
if (newTitle != null)
     sbnewTitle = new StringBuilder(newTitle, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_setWindowTitle(sbguicanvas, sbnewTitle);
}
/// <summary>
/// @brief Enable rendering of the cursor.
/// 
/// 				   @tsexample
/// 				   Canvas.showCursor();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_showCursor (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_showCursor'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_showCursor(sbguicanvas);
}
/// <summary>
/// ( GuiCanvas, showWindow, void, 2, 2,  )
/// 
/// </summary>

public void fnGuiCanvas_showWindow (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_showWindow'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_showWindow(sbguicanvas);
}
/// <summary>
/// @brief toggle canvas from fullscreen to windowed mode or back.
/// 
/// 				   @tsexample
/// 				   // If we are in windowed mode, the following will put is in fullscreen
/// 				   Canvas.toggleFullscreen();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiCanvas_toggleFullscreen (string guicanvas)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCanvas_toggleFullscreen'" + string.Format("\"{0}\" ",guicanvas));
StringBuilder sbguicanvas = null;
if (guicanvas != null)
     sbguicanvas = new StringBuilder(guicanvas, 1024);

SafeNativeMethods.mwle_fnGuiCanvas_toggleFullscreen(sbguicanvas);
}
/// <summary>
/// Test whether the checkbox is currently checked.
///    @return True if the checkbox is currently ticked, false otherwise. )
/// 
/// </summary>

public bool fnGuiCheckBoxCtrl_isStateOn (string guicheckboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCheckBoxCtrl_isStateOn'" + string.Format("\"{0}\" ",guicheckboxctrl));
StringBuilder sbguicheckboxctrl = null;
if (guicheckboxctrl != null)
     sbguicheckboxctrl = new StringBuilder(guicheckboxctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiCheckBoxCtrl_isStateOn(sbguicheckboxctrl)>=1;
}
/// <summary>
/// Set whether the checkbox is ticked or not.
///    @param newState If true the box will be checked, if false, it will be unchecked.
///    @note This method will @b not trigger the command associated with the control.  To toggle the 
///       checkbox state as if the user had clicked the control, use performClick(). )
/// 
/// </summary>

public void fnGuiCheckBoxCtrl_setStateOn (string guicheckboxctrl, bool newState)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiCheckBoxCtrl_setStateOn'" + string.Format("\"{0}\" \"{1}\" ",guicheckboxctrl,newState));
StringBuilder sbguicheckboxctrl = null;
if (guicheckboxctrl != null)
     sbguicheckboxctrl = new StringBuilder(guicheckboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiCheckBoxCtrl_setStateOn(sbguicheckboxctrl, newState);
}
/// <summary>
/// @brief Set the image rendered in this control.
///    @param filename The image name you want to set
///    @tsexample
///    ChunkedBitmap.setBitmap(\"images/background.png\");
///    @endtsexample)
/// 
/// </summary>

public void fnGuiChunkedBitmapCtrl_setBitmap (string guichunkedbitmapctrl, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiChunkedBitmapCtrl_setBitmap'" + string.Format("\"{0}\" \"{1}\" ",guichunkedbitmapctrl,filename));
StringBuilder sbguichunkedbitmapctrl = null;
if (guichunkedbitmapctrl != null)
     sbguichunkedbitmapctrl = new StringBuilder(guichunkedbitmapctrl, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnGuiChunkedBitmapCtrl_setBitmap(sbguichunkedbitmapctrl, sbfilename);
}
/// <summary>
/// Returns the current time, in seconds.
/// 													@return timeInseconds Current time, in seconds
/// 													@tsexample
/// 														// Get the current time from the GuiClockHud control
/// 														%timeInSeconds = %guiClockHud.getTime();
/// 													@endtsexample
/// 				  )
/// 
/// </summary>

public float fnGuiClockHud_getTime (string guiclockhud)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiClockHud_getTime'" + string.Format("\"{0}\" ",guiclockhud));
StringBuilder sbguiclockhud = null;
if (guiclockhud != null)
     sbguiclockhud = new StringBuilder(guiclockhud, 1024);

return  SafeNativeMethods.mwle_fnGuiClockHud_getTime(sbguiclockhud);
}
/// <summary>
/// @brief Sets a time for a countdown clock.
///    												Setting the time like this will cause the clock to count backwards from the specified time.
/// 													@param timeInSeconds Time to set the clock, in seconds (IE: 00:02 would be 120)
/// 													@see setTime
/// 				  )
/// 
/// </summary>

public void fnGuiClockHud_setReverseTime (string guiclockhud, float timeInSeconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiClockHud_setReverseTime'" + string.Format("\"{0}\" \"{1}\" ",guiclockhud,timeInSeconds));
StringBuilder sbguiclockhud = null;
if (guiclockhud != null)
     sbguiclockhud = new StringBuilder(guiclockhud, 1024);

SafeNativeMethods.mwle_fnGuiClockHud_setReverseTime(sbguiclockhud, timeInSeconds);
}
/// <summary>
/// Sets the current base time for the clock.
/// 													@param timeInSeconds Time to set the clock, in seconds (IE: 00:02 would be 120)
/// 													@tsexample
/// 														// Define the time, in seconds
/// 														%timeInSeconds = 120;
/// 														// Change the time on the GuiClockHud control
/// 														%guiClockHud.setTime(%timeInSeconds);
/// 													@endtsexample
/// 				  )
/// 
/// </summary>

public void fnGuiClockHud_setTime (string guiclockhud, float timeInSeconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiClockHud_setTime'" + string.Format("\"{0}\" \"{1}\" ",guiclockhud,timeInSeconds));
StringBuilder sbguiclockhud = null;
if (guiclockhud != null)
     sbguiclockhud = new StringBuilder(guiclockhud, 1024);

SafeNativeMethods.mwle_fnGuiClockHud_setTime(sbguiclockhud, timeInSeconds);
}
/// <summary>
/// Add the given control as a child to this control.
///    This is synonymous to calling SimGroup::addObject.
///    @param control The control to add as a child.
///    @note The control will retain its current position and size.
///    @see SimGroup::addObject
///    @ref GuiControl_Hierarchy )
/// 
/// </summary>

public void fnGuiControl_addGuiControl (string guicontrol, string control)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_addGuiControl'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,control));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcontrol = null;
if (control != null)
     sbcontrol = new StringBuilder(control, 1024);

SafeNativeMethods.mwle_fnGuiControl_addGuiControl(sbguicontrol, sbcontrol);
}
/// <summary>
/// Returns if the control's background color can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_canChangeContextBackColor (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_canChangeContextBackColor'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_canChangeContextBackColor(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's fill color can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_canChangeContextFillColor (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_canChangeContextFillColor'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_canChangeContextFillColor(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's font color can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_canChangeContextFontColor (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_canChangeContextFontColor'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_canChangeContextFontColor(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's font size can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_canChangeContextFontSize (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_canChangeContextFontSize'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_canChangeContextFontSize(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's window settings can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_canShowContextWindowSettings (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_canShowContextWindowSettings'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_canShowContextWindowSettings(sbguicontrol)>=1;
}
/// <summary>
/// Clear this control from being the first responder in its hierarchy chain.
///    @param ignored Ignored.  Supported for backwards-compatibility. )
/// 
/// </summary>

public void fnGuiControl_clearFirstResponder (string guicontrol, bool ignored)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_clearFirstResponder'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,ignored));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_clearFirstResponder(sbguicontrol, ignored);
}
/// <summary>
/// Test whether the given control is a direct or indirect child to this control.
///    @param control The potential child control.
///    @return True if the given control is a direct or indirect child to this control. )
/// 
/// </summary>

public bool fnGuiControl_controlIsChild (string guicontrol, string control)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_controlIsChild'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,control));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcontrol = null;
if (control != null)
     sbcontrol = new StringBuilder(control, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_controlIsChild(sbguicontrol, sbcontrol)>=1;
}
/// <summary>
/// Test whether the given control is a sibling of this control.
///    @param control The potential sibling control.
///    @return True if the given control is a sibling of this control. )
/// 
/// </summary>

public bool fnGuiControl_controlIsSibling (string guicontrol, string control)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_controlIsSibling'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,control));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcontrol = null;
if (control != null)
     sbcontrol = new StringBuilder(control, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_controlIsSibling(sbguicontrol, sbcontrol)>=1;
}
/// <summary>
/// Find the topmost child control located at the given coordinates.
///    @note Only children that are both visible and have the 'modal' flag set in their profile will be considered in the search.
///    @param x The X coordinate in the control's own coordinate space.
///    @param y The Y coordinate in the control's own coordinate space.
///    @return The topmost child control at the given coordintes or the control on which the method was called if no matching child could be found.
///    @see GuiControlProfile::modal
///    @see findHitControls )
/// 
/// </summary>

public string fnGuiControl_findHitControl (string guicontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_findHitControl'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guicontrol,x,y));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_findHitControl(sbguicontrol, x, y, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Find all visible child controls that intersect with the given rectangle.
///    @note Invisible child controls will not be included in the search.
///    @param x The X coordinate of the rectangle's upper left corner in the control's own coordinate space.
///    @param y The Y coordinate of the rectangle's upper left corner in the control's own coordinate space.
///    @param width The width of the search rectangle in pixels.
///    @param height The height of the search rectangle in pixels.
///    @return A space-separated list of the IDs of all visible control objects intersecting the given rectangle.
///    @tsexample
///    // Lock all controls in the rectangle at x=10 and y=10 and the extent width=100 and height=100.
///    foreach$( %ctrl in %this.findHitControls( 10, 10, 100, 100 ) )
///       %ctrl.setLocked( true );
///    @endtsexample
///    @see findHitControl )
/// 
/// </summary>

public string fnGuiControl_findHitControls (string guicontrol, int x, int y, int width, int height)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_findHitControls'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guicontrol,x,y,width,height));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_findHitControls(sbguicontrol, x, y, width, height, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the alpha fade time for the object. )
/// 
/// </summary>

public int fnGuiControl_getAlphaFadeTime (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getAlphaFadeTime'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getAlphaFadeTime(sbguicontrol);
}
/// <summary>
/// Get the alpha for the object. )
/// 
/// </summary>

public float fnGuiControl_getAlphaValue (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getAlphaValue'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getAlphaValue(sbguicontrol);
}
/// <summary>
/// Get the aspect ratio of the control's extents.
///    @return The width of the control divided by its height.
///    @see getExtent )
/// 
/// </summary>

public float fnGuiControl_getAspect (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getAspect'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getAspect(sbguicontrol);
}
/// <summary>
/// Get the coordinate of the control's center point relative to its parent.
///    @return The coordinate of the control's center point in parent-relative coordinates. )
/// 
/// </summary>

public string fnGuiControl_getCenter (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getCenter'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getCenter(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Sets the font size of a control. )
/// 
/// </summary>

public int fnGuiControl_getControlFontSize (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getControlFontSize'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getControlFontSize(sbguicontrol);
}
/// <summary>
/// Returns if the control is locked or not. )
/// 
/// </summary>

public bool fnGuiControl_getControlLock (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getControlLock'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getControlLock(sbguicontrol)>=1;
}
/// <summary>
/// Returns the filename of the texture of the control. )
/// 
/// </summary>

public string fnGuiControl_getControlTextureFile (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getControlTextureFile'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getControlTextureFile(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the width and height of the control.
///    @return A point structure containing the width of the control in x and the height in y. )
/// 
/// </summary>

public string fnGuiControl_getExtent (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getExtent'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getExtent(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the first responder set on this GuiControl tree.
///    @return The first responder set on the control's subtree.
///    @see isFirstResponder
///    @see makeFirstResponder
///    @see setFirstResponder
///    @ref GuiControl_FirstResponders )
/// 
/// </summary>

public string fnGuiControl_getFirstResponder (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getFirstResponder'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getFirstResponder(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the coordinate of the control's center point in coordinates relative to the root control in its control hierarchy.
///    @Return the center coordinate of the control in root-relative coordinates. )
/// 
/// </summary>

public string fnGuiControl_getGlobalCenter (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getGlobalCenter'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getGlobalCenter(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the position of the control relative to the root of the GuiControl hierarchy it is contained in.
///    @return The control's current position in root-relative coordinates. )
/// 
/// </summary>

public string fnGuiControl_getGlobalPosition (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getGlobalPosition'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getGlobalPosition(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the maximum allowed size of the control.
///    @return The maximum size to which the control can be shrunk.
///    @see maxExtent )
/// 
/// </summary>

public string fnGuiControl_getMaxExtent (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getMaxExtent'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getMaxExtent(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the minimum allowed size of the control.
///    @return The minimum size to which the control can be shrunk.
///    @see minExtent )
/// 
/// </summary>

public string fnGuiControl_getMinExtent (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getMinExtent'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getMinExtent(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the mouse over alpha for the object. )
/// 
/// </summary>

public float fnGuiControl_getMouseOverAlphaValue (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getMouseOverAlphaValue'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_getMouseOverAlphaValue(sbguicontrol);
}
/// <summary>
/// Get the immediate parent control of the control.
///    @return The immediate parent GuiControl or 0 if the control is not parented to a GuiControl. )
/// 
/// </summary>

public string fnGuiControl_getParent (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getParent'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getParent(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the control's current position relative to its parent.
///    @return The coordinate of the control in its parent's coordinate space. )
/// 
/// </summary>

public string fnGuiControl_getPosition (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getPosition'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getPosition(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the canvas on which the control is placed.
///    @return The canvas on which the control's hierarchy is currently placed or 0 if the control is not currently placed on a GuiCanvas.
///    @see GuiControl_Hierarchy )
/// 
/// </summary>

public string fnGuiControl_getRoot (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getRoot'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getRoot(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get root control )
/// 
/// </summary>

public string fnGuiControl_getRootControl (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_getRootControl'" + string.Format("\"{0}\" ",guicontrol));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_getRootControl(sbguicontrol, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Test whether the control is currently awake.
///    If a control is awake it means that it is part of the GuiControl hierarchy of a GuiCanvas.
///    @return True if the control is awake.
///    @ref GuiControl_Waking )
/// 
/// </summary>

public bool fnGuiControl_isAwake (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isAwake'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isAwake(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's alpha value can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_isContextAlphaEnabled (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isContextAlphaEnabled'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isContextAlphaEnabled(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's alpha fade value can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_isContextAlphaFadeEnabled (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isContextAlphaFadeEnabled'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isContextAlphaFadeEnabled(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control can be locked in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_isContextLockable (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isContextLockable'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isContextLockable(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control's mouse-over alpha value can be changed in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_isContextMouseOverAlphaEnabled (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isContextMouseOverAlphaEnabled'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isContextMouseOverAlphaEnabled(sbguicontrol)>=1;
}
/// <summary>
/// Returns if the control can be moved in the game or not. )
/// 
/// </summary>

public bool fnGuiControl_isContextMovable (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isContextMovable'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isContextMovable(sbguicontrol)>=1;
}
/// <summary>
/// Test whether the control is the current first responder.
///    @return True if the control is the current first responder.
///    @see makeFirstResponder
///    @see setFirstResponder
///    @ref GuiControl_FirstResponders )
/// 
/// </summary>

public bool fnGuiControl_isFirstResponder (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isFirstResponder'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isFirstResponder(sbguicontrol)>=1;
}
/// <summary>
/// Indicates if the mouse is locked in this control.
///    @return True if the mouse is currently locked. )
/// 
/// </summary>

public bool fnGuiControl_isMouseLocked (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isMouseLocked'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isMouseLocked(sbguicontrol)>=1;
}
/// <summary>
/// Test whether the control is currently set to be visible.
///    @return True if the control is currently set to be visible.
///    @note This method does not tell anything about whether the control is actually visible to 
///       the user at the moment.
///    @ref GuiControl_VisibleActive )
/// 
/// </summary>

public bool fnGuiControl_isVisible (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_isVisible'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_isVisible(sbguicontrol)>=1;
}
/// <summary>
/// Test whether the given point lies within the rectangle of the control.
///    @param x X coordinate of the point in parent-relative coordinates.
///    @param y Y coordinate of the point in parent-relative coordinates.
///    @return True if the point is within the control, false if not.
///    @see getExtent
///    @see getPosition )
/// 
/// </summary>

public bool fnGuiControl_pointInControl (string guicontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_pointInControl'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guicontrol,x,y));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_pointInControl(sbguicontrol, x, y)>=1;
}
/// <summary>
/// Recalculates the position and size of this control and all its children. )
/// 
/// </summary>

public void fnGuiControl_refresh (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_refresh'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_refresh(sbguicontrol);
}
/// <summary>
/// Removes the plus cursor.
///    @param ignored Ignored.  Supported for backwards-compatibility. )
/// 
/// </summary>

public void fnGuiControl_resetCur (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_resetCur'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_resetCur(sbguicontrol);
}
/// <summary>
/// Resize and reposition the control using the give coordinates and dimensions.  Child controls 
///    will resize according to their layout behaviors.
///    @param x The new X coordinate of the control in its parent's coordinate space.
///    @param y The new Y coordinate of the control in its parent's coordinate space.
///    @param width The new width to which the control should be resized.
///    @param height The new height to which the control should be resized. )
/// 
/// </summary>

public void fnGuiControl_resize (string guicontrol, int x, int y, int width, int height)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_resize'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guicontrol,x,y,width,height));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_resize(sbguicontrol, x, y, width, height);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnGuiControl_setActive (string guicontrol, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setActive'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,state));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setActive(sbguicontrol, state);
}
/// <summary>
/// Set the alpha for the object.
///    @param value Range 0, 1 for the transparency. )
/// 
/// </summary>

public void fnGuiControl_setAlphaFadeTime (string guicontrol, int fadeTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setAlphaFadeTime'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fadeTime));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setAlphaFadeTime(sbguicontrol, fadeTime);
}
/// <summary>
/// Set the alpha for the object.
///    @param value Range 0, 1 for the transparency. )
/// 
/// </summary>

public void fnGuiControl_setAlphaValue (string guicontrol, float alpha)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setAlphaValue'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,alpha));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setAlphaValue(sbguicontrol, alpha);
}
/// <summary>
/// Set the control's position by its center point.
///    @param x The X coordinate of the new center point of the control relative to the control's parent.
///    @param y The Y coordinate of the new center point of the control relative to the control's parent. )
/// 
/// </summary>

public void fnGuiControl_setCenter (string guicontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setCenter'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guicontrol,x,y));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setCenter(sbguicontrol, x, y);
}
/// <summary>
/// Displays the option to set the alpha of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextAlpha (string guicontrol, bool alpha)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextAlpha'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,alpha));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextAlpha(sbguicontrol, alpha);
}
/// <summary>
/// Displays the option to set the alpha fade value of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextAlphaFade (string guicontrol, bool fade)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextAlphaFade'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fade));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextAlphaFade(sbguicontrol, fade);
}
/// <summary>
/// Displays the option to set the background color of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextBackColor (string guicontrol, bool backColor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextBackColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,backColor));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextBackColor(sbguicontrol, backColor);
}
/// <summary>
/// Displays the option to set the fill color of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextFillColor (string guicontrol, bool fillColor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextFillColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fillColor));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextFillColor(sbguicontrol, fillColor);
}
/// <summary>
/// Displays the option to set the font color of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextFontColor (string guicontrol, bool fontColor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextFontColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fontColor));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextFontColor(sbguicontrol, fontColor);
}
/// <summary>
/// Displays the option to set the font size of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextFontSize (string guicontrol, bool fontSize)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextFontSize'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fontSize));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextFontSize(sbguicontrol, fontSize);
}
/// <summary>
/// Displays the option to lock the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextLockControl (string guicontrol, bool lockx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextLockControl'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,lockx));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextLockControl(sbguicontrol, lockx);
}
/// <summary>
/// Displays the option to set the mouse-over alpha of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextMouseOverAlpha (string guicontrol, bool mouseOver)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextMouseOverAlpha'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,mouseOver));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextMouseOverAlpha(sbguicontrol, mouseOver);
}
/// <summary>
/// Displays the option to move the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setContextMoveControl (string guicontrol, bool move)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setContextMoveControl'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,move));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setContextMoveControl(sbguicontrol, move);
}
/// <summary>
/// Set control background color. )
/// 
/// </summary>

public void fnGuiControl_setControlBackgroundColor (string guicontrol, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlBackgroundColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,color));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlBackgroundColor(sbguicontrol, sbcolor);
}
/// <summary>
/// Set control fill color. )
/// 
/// </summary>

public void fnGuiControl_setControlFillColor (string guicontrol, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlFillColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,color));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlFillColor(sbguicontrol, sbcolor);
}
/// <summary>
/// Set control font color. )
/// 
/// </summary>

public void fnGuiControl_setControlFontColor (string guicontrol, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlFontColor'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,color));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlFontColor(sbguicontrol, sbcolor);
}
/// <summary>
/// Sets the font size of a control. )
/// 
/// </summary>

public void fnGuiControl_setControlFontSize (string guicontrol, int fontSize)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlFontSize'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fontSize));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlFontSize(sbguicontrol, fontSize);
}
/// <summary>
/// Lock the control. )
/// 
/// </summary>

public void fnGuiControl_setControlLock (string guicontrol, bool lockedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlLock'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,lockedx));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlLock(sbguicontrol, lockedx);
}
/// <summary>
/// Set control texture. )
/// 
/// </summary>

public void fnGuiControl_setControlTexture (string guicontrol, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setControlTexture'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,fileName));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

SafeNativeMethods.mwle_fnGuiControl_setControlTexture(sbguicontrol, sbfileName);
}
/// <summary>
/// Sets the cursor as a plus.
///    @param ignored Ignored.  Supported for backwards-compatibility. )
/// 
/// </summary>

public void fnGuiControl_setCur (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setCur'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setCur(sbguicontrol);
}
/// <summary>
/// Make this control the current first responder.
///    @note Only controls with a profile that has canKeyFocus enabled are able to become first responders.
///    @see GuiControlProfile::canKeyFocus
///    @see isFirstResponder
///    @ref GuiControl_FirstResponders )
/// 
/// </summary>

public void fnGuiControl_setFirstResponder (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setFirstResponder'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setFirstResponder(sbguicontrol);
}
/// <summary>
/// Set the alpha for the object.
///    @param value Range 0, 1 for the transparency. )
/// 
/// </summary>

public void fnGuiControl_setMouseOverAlphaValue (string guicontrol, float alpha)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setMouseOverAlphaValue'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,alpha));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setMouseOverAlphaValue(sbguicontrol, alpha);
}
/// <summary>
/// Position the control in the local space of the parent control.
///    @param x The new X coordinate of the control relative to its parent's upper left corner.
///    @param y The new Y coordinate of the control relative to its parent's upper left corner. )
/// 
/// </summary>

public void fnGuiControl_setPosition (string guicontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setPosition'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guicontrol,x,y));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setPosition(sbguicontrol, x, y);
}
/// <summary>
/// Set position of the control relative to the root of the GuiControl hierarchy it is contained in.
///    @param x The new X coordinate of the control relative to the root's upper left corner.
///    @param y The new Y coordinate of the control relative to the root's upper left corner. )
/// 
/// </summary>

public void fnGuiControl_setPositionGlobal (string guicontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setPositionGlobal'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guicontrol,x,y));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setPositionGlobal(sbguicontrol, x, y);
}
/// <summary>
/// Set the control profile for the control to use.
///    The profile used by a control determines a great part of its behavior and appearance.
///    @param profile The new profile the control should use.
///    @ref GuiControl_Profiles )
/// 
/// </summary>

public void fnGuiControl_setProfile (string guicontrol, string profile)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setProfile'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,profile));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbprofile = null;
if (profile != null)
     sbprofile = new StringBuilder(profile, 1024);

SafeNativeMethods.mwle_fnGuiControl_setProfile(sbguicontrol, sbprofile);
}
/// <summary>
/// Displays the option to set the window settings of the control in the game when true. )
/// 
/// </summary>

public void fnGuiControl_setShowContextWindowSettings (string guicontrol, bool lockx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setShowContextWindowSettings'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,lockx));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setShowContextWindowSettings(sbguicontrol, lockx);
}
/// <summary>
/// Set the value associated with the control.
///    @param value The new value for the control. )
/// 
/// </summary>

public void fnGuiControl_setValue (string guicontrol, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setValue'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,value));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnGuiControl_setValue(sbguicontrol, sbvalue);
}
/// <summary>
/// Set whether the control is visible or not.
///    @param state The new visiblity flag state for the control.
///    @ref GuiControl_VisibleActive )
/// 
/// </summary>

public void fnGuiControl_setVisible (string guicontrol, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_setVisible'" + string.Format("\"{0}\" \"{1}\" ",guicontrol,state));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

SafeNativeMethods.mwle_fnGuiControl_setVisible(sbguicontrol, state);
}
/// <summary>
/// Returns true if the control is transparent. )
/// 
/// </summary>

public bool fnGuiControl_transparentControlCheck (string guicontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiControl_transparentControlCheck'" + string.Format("\"{0}\" ",guicontrol));
StringBuilder sbguicontrol = null;
if (guicontrol != null)
     sbguicontrol = new StringBuilder(guicontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiControl_transparentControlCheck(sbguicontrol)>=1;
}
/// <summary>
/// Get the currently selected filename.
///    @return The filename of the currently selected file )
/// 
/// </summary>

public string fnGuiDirectoryFileListCtrl_getSelectedFile (string guidirectoryfilelistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDirectoryFileListCtrl_getSelectedFile'" + string.Format("\"{0}\" ",guidirectoryfilelistctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguidirectoryfilelistctrl = null;
if (guidirectoryfilelistctrl != null)
     sbguidirectoryfilelistctrl = new StringBuilder(guidirectoryfilelistctrl, 1024);

SafeNativeMethods.mwle_fnGuiDirectoryFileListCtrl_getSelectedFile(sbguidirectoryfilelistctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the list of selected files.
///    @return A space separated list of selected files )
/// 
/// </summary>

public string fnGuiDirectoryFileListCtrl_getSelectedFiles (string guidirectoryfilelistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDirectoryFileListCtrl_getSelectedFiles'" + string.Format("\"{0}\" ",guidirectoryfilelistctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguidirectoryfilelistctrl = null;
if (guidirectoryfilelistctrl != null)
     sbguidirectoryfilelistctrl = new StringBuilder(guidirectoryfilelistctrl, 1024);

SafeNativeMethods.mwle_fnGuiDirectoryFileListCtrl_getSelectedFiles(sbguidirectoryfilelistctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Update the file list. )
/// 
/// </summary>

public void fnGuiDirectoryFileListCtrl_reload (string guidirectoryfilelistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDirectoryFileListCtrl_reload'" + string.Format("\"{0}\" ",guidirectoryfilelistctrl));
StringBuilder sbguidirectoryfilelistctrl = null;
if (guidirectoryfilelistctrl != null)
     sbguidirectoryfilelistctrl = new StringBuilder(guidirectoryfilelistctrl, 1024);

SafeNativeMethods.mwle_fnGuiDirectoryFileListCtrl_reload(sbguidirectoryfilelistctrl);
}
/// <summary>
/// Set the file filter.
///    @param filter Tab-delimited list of file name patterns. Only matched files will be displayed. )
/// 
/// </summary>

public void fnGuiDirectoryFileListCtrl_setFilter (string guidirectoryfilelistctrl, string filter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDirectoryFileListCtrl_setFilter'" + string.Format("\"{0}\" \"{1}\" ",guidirectoryfilelistctrl,filter));
StringBuilder sbguidirectoryfilelistctrl = null;
if (guidirectoryfilelistctrl != null)
     sbguidirectoryfilelistctrl = new StringBuilder(guidirectoryfilelistctrl, 1024);
StringBuilder sbfilter = null;
if (filter != null)
     sbfilter = new StringBuilder(filter, 1024);

SafeNativeMethods.mwle_fnGuiDirectoryFileListCtrl_setFilter(sbguidirectoryfilelistctrl, sbfilter);
}
/// <summary>
/// Set the search path and file filter.
///    @param path   Path in game directory from which to list files.
///    @param filter Tab-delimited list of file name patterns. Only matched files will be displayed. )
/// 
/// </summary>

public bool fnGuiDirectoryFileListCtrl_setPath (string guidirectoryfilelistctrl, string path, string filter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDirectoryFileListCtrl_setPath'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guidirectoryfilelistctrl,path,filter));
StringBuilder sbguidirectoryfilelistctrl = null;
if (guidirectoryfilelistctrl != null)
     sbguidirectoryfilelistctrl = new StringBuilder(guidirectoryfilelistctrl, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);
StringBuilder sbfilter = null;
if (filter != null)
     sbfilter = new StringBuilder(filter, 1024);

return  SafeNativeMethods.mwle_fnGuiDirectoryFileListCtrl_setPath(sbguidirectoryfilelistctrl, sbpath, sbfilter)>=1;
}
/// <summary>
/// Start the drag operation.
///    @param x X coordinate for the mouse pointer offset which the drag control should position itself.
///    @param y Y coordinate for the mouse pointer offset which the drag control should position itself.)
/// 
/// </summary>

public void fnGuiDragAndDropControl_startDragging (string guidraganddropcontrol, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDragAndDropControl_startDragging'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guidraganddropcontrol,x,y));
StringBuilder sbguidraganddropcontrol = null;
if (guidraganddropcontrol != null)
     sbguidraganddropcontrol = new StringBuilder(guidraganddropcontrol, 1024);

SafeNativeMethods.mwle_fnGuiDragAndDropControl_startDragging(sbguidraganddropcontrol, x, y);
}
/// <summary>
/// Recalculates the position and size of this control and all its children. )
/// 
/// </summary>

public void fnGuiDynamicCtrlArrayControl_refresh (string guidynamicctrlarraycontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiDynamicCtrlArrayControl_refresh'" + string.Format("\"{0}\" ",guidynamicctrlarraycontrol));
StringBuilder sbguidynamicctrlarraycontrol = null;
if (guidynamicctrlarraycontrol != null)
     sbguidynamicctrlarraycontrol = new StringBuilder(guidynamicctrlarraycontrol, 1024);

SafeNativeMethods.mwle_fnGuiDynamicCtrlArrayControl_refresh(sbguidynamicctrlarraycontrol);
}
/// <summary>
/// Gets the set of GUI controls currently selected in the editor. )
/// 
/// </summary>

public string fnGuiEditCtrl_getSelection (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiEditCtrl_getSelection'" + string.Format("\"{0}\" ",guieditctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fnGuiEditCtrl_getSelection(sbguieditctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Gets the GUI controls(s) that are currently in the trash.)
/// 
/// </summary>

public string fnGuiEditCtrl_getTrash (string guieditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiEditCtrl_getTrash'" + string.Format("\"{0}\" ",guieditctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguieditctrl = null;
if (guieditctrl != null)
     sbguieditctrl = new StringBuilder(guieditctrl, 1024);

SafeNativeMethods.mwle_fnGuiEditCtrl_getTrash(sbguieditctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( GuiFilterCtrl, setValue, void, 3, 20, (f1, f2, ...)
///               Reset the filter to use the specified points, spread equidistantly across the domain.
/// 			  @internal)
/// 
/// </summary>

public void fnGuiFilterCtrl_setValue (string guifilterctrl, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFilterCtrl_setValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",guifilterctrl,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbguifilterctrl = null;
if (guifilterctrl != null)
     sbguifilterctrl = new StringBuilder(guifilterctrl, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnGuiFilterCtrl_setValue(sbguifilterctrl, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Get the ID of this form's menu.
///    @return The ID of the form menu )
/// 
/// </summary>

public int fnGuiFormCtrl_getMenuID (string guiformctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFormCtrl_getMenuID'" + string.Format("\"{0}\" ",guiformctrl));
StringBuilder sbguiformctrl = null;
if (guiformctrl != null)
     sbguiformctrl = new StringBuilder(guiformctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiFormCtrl_getMenuID(sbguiformctrl);
}
/// <summary>
/// Sets the title of the form.
///    @param caption Form caption )
/// 
/// </summary>

public void fnGuiFormCtrl_setCaption (string guiformctrl, string caption)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFormCtrl_setCaption'" + string.Format("\"{0}\" \"{1}\" ",guiformctrl,caption));
StringBuilder sbguiformctrl = null;
if (guiformctrl != null)
     sbguiformctrl = new StringBuilder(guiformctrl, 1024);
StringBuilder sbcaption = null;
if (caption != null)
     sbcaption = new StringBuilder(caption, 1024);

SafeNativeMethods.mwle_fnGuiFormCtrl_setCaption(sbguiformctrl, sbcaption);
}
/// <summary>
/// Add a new column. )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_addColumn (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_addColumn'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_addColumn(sbguiframesetctrl);
}
/// <summary>
/// Add a new row. )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_addRow (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_addRow'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_addRow(sbguiframesetctrl);
}
/// <summary>
/// dynamic ),
///    Override the i>borderEnable/i> setting for this frame.
///    @param index  Index of the frame to modify
///    @param state  New borderEnable state: \"on\", \"off\" or \"dynamic\" )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_frameBorder (string guiframesetctrl, int index, string state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_frameBorder'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiframesetctrl,index,state));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);
StringBuilder sbstate = null;
if (state != null)
     sbstate = new StringBuilder(state, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_frameBorder(sbguiframesetctrl, index, sbstate);
}
/// <summary>
/// Set the minimum width and height for the frame. It will not be possible 
///    for the user to resize the frame smaller than this.
///    @param index  Index of the frame to modify
///    @param width  Minimum width in pixels
///    @param height Minimum height in pixels )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_frameMinExtent (string guiframesetctrl, int index, int width, int height)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_frameMinExtent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guiframesetctrl,index,width,height));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_frameMinExtent(sbguiframesetctrl, index, width, height);
}
/// <summary>
/// dynamic ),
///    Override the i>borderMovable/i> setting for this frame.
///    @param index  Index of the frame to modify
///    @param state  New borderEnable state: \"on\", \"off\" or \"dynamic\" )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_frameMovable (string guiframesetctrl, int index, string state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_frameMovable'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiframesetctrl,index,state));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);
StringBuilder sbstate = null;
if (state != null)
     sbstate = new StringBuilder(state, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_frameMovable(sbguiframesetctrl, index, sbstate);
}
/// <summary>
/// Set the padding for this frame. Padding introduces blank space on the inside 
///    edge of the frame.
///    @param index     Index of the frame to modify
///    @param padding   Frame top, bottom, left, and right padding )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_framePadding (string guiframesetctrl, int index, string padding)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_framePadding'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiframesetctrl,index,padding));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);
StringBuilder sbpadding = null;
if (padding != null)
     sbpadding = new StringBuilder(padding, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_framePadding(sbguiframesetctrl, index, sbpadding);
}
/// <summary>
/// Get the number of columns.
///    @return The number of columns )
/// 
/// </summary>

public int fnGuiFrameSetCtrl_getColumnCount (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_getColumnCount'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiFrameSetCtrl_getColumnCount(sbguiframesetctrl);
}
/// <summary>
/// Get the horizontal offset of a column.
///    @param index Index of the column to query
///    @return Column offset in pixels )
/// 
/// </summary>

public int fnGuiFrameSetCtrl_getColumnOffset (string guiframesetctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_getColumnOffset'" + string.Format("\"{0}\" \"{1}\" ",guiframesetctrl,index));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiFrameSetCtrl_getColumnOffset(sbguiframesetctrl, index);
}
/// <summary>
/// Get the padding for this frame.
///    @param index     Index of the frame to query )
/// 
/// </summary>

public string fnGuiFrameSetCtrl_getFramePadding (string guiframesetctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_getFramePadding'" + string.Format("\"{0}\" \"{1}\" ",guiframesetctrl,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_getFramePadding(sbguiframesetctrl, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of rows.
///    @return The number of rows )
/// 
/// </summary>

public int fnGuiFrameSetCtrl_getRowCount (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_getRowCount'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiFrameSetCtrl_getRowCount(sbguiframesetctrl);
}
/// <summary>
/// Get the vertical offset of a row.
///    @param index Index of the row to query
///    @return Row offset in pixels )
/// 
/// </summary>

public int fnGuiFrameSetCtrl_getRowOffset (string guiframesetctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_getRowOffset'" + string.Format("\"{0}\" \"{1}\" ",guiframesetctrl,index));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiFrameSetCtrl_getRowOffset(sbguiframesetctrl, index);
}
/// <summary>
/// Remove the last (rightmost) column. )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_removeColumn (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_removeColumn'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_removeColumn(sbguiframesetctrl);
}
/// <summary>
/// Remove the last (bottom) row. )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_removeRow (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_removeRow'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_removeRow(sbguiframesetctrl);
}
/// <summary>
/// Set the horizontal offset of a column.
///    Note that column offsets must always be in increasing order, and therefore 
///    this offset must be between the offsets of the colunns either side.
///    @param index  Index of the column to modify
///    @param offset New column offset )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_setColumnOffset (string guiframesetctrl, int index, int offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_setColumnOffset'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiframesetctrl,index,offset));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_setColumnOffset(sbguiframesetctrl, index, offset);
}
/// <summary>
/// Set the vertical offset of a row.
///    Note that row offsets must always be in increasing order, and therefore 
///    this offset must be between the offsets of the rows either side.
///    @param index  Index of the row to modify
///    @param offset New row offset )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_setRowOffset (string guiframesetctrl, int index, int offset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_setRowOffset'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiframesetctrl,index,offset));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_setRowOffset(sbguiframesetctrl, index, offset);
}
/// <summary>
/// Recalculates child control sizes. )
/// 
/// </summary>

public void fnGuiFrameSetCtrl_updateSizes (string guiframesetctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiFrameSetCtrl_updateSizes'" + string.Format("\"{0}\" ",guiframesetctrl));
StringBuilder sbguiframesetctrl = null;
if (guiframesetctrl != null)
     sbguiframesetctrl = new StringBuilder(guiframesetctrl, 1024);

SafeNativeMethods.mwle_fnGuiFrameSetCtrl_updateSizes(sbguiframesetctrl);
}
/// <summary>
/// Activates the current row. The script callback of  the current row will be called (if it has one). )
/// 
/// </summary>

public void fnGuiGameListMenuCtrl_activateRow (string guigamelistmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_activateRow'" + string.Format("\"{0}\" ",guigamelistmenuctrl));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_activateRow(sbguigamelistmenuctrl);
}
/// <summary>
/// Add a row to the list control.
///    @param label The text to display on the row as a label.
///    @param callback Name of a script function to use as a callback when this row is activated.
///    @param icon [optional] Index of the icon to use as a marker.
///    @param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
///    @param useHighlightIcon [optional] Does this row use the highlight icon?.
///    @param enabled [optional] If this row is initially enabled. )
/// 
/// </summary>

public void fnGuiGameListMenuCtrl_addRow (string guigamelistmenuctrl, string label, string callback, int icon, int yPad, bool useHighlightIcon, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_addRow'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",guigamelistmenuctrl,label,callback,icon,yPad,useHighlightIcon,enabled));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);
StringBuilder sblabel = null;
if (label != null)
     sblabel = new StringBuilder(label, 1024);
StringBuilder sbcallback = null;
if (callback != null)
     sbcallback = new StringBuilder(callback, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_addRow(sbguigamelistmenuctrl, sblabel, sbcallback, icon, yPad, useHighlightIcon, enabled);
}
/// <summary>
/// Gets the number of rows on the control.
///    @return (int) The number of rows on the control. )
/// 
/// </summary>

public int fnGuiGameListMenuCtrl_getRowCount (string guigamelistmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_getRowCount'" + string.Format("\"{0}\" ",guigamelistmenuctrl));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_getRowCount(sbguigamelistmenuctrl);
}
/// <summary>
/// Gets the label displayed on the specified row.
///    @param row Index of the row to get the label of.
///    @return The label for the row. )
/// 
/// </summary>

public string fnGuiGameListMenuCtrl_getRowLabel (string guigamelistmenuctrl, int row)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_getRowLabel'" + string.Format("\"{0}\" \"{1}\" ",guigamelistmenuctrl,row));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_getRowLabel(sbguigamelistmenuctrl, row, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Gets the index of the currently selected row.
///    @return Index of the selected row. )
/// 
/// </summary>

public int fnGuiGameListMenuCtrl_getSelectedRow (string guigamelistmenuctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_getSelectedRow'" + string.Format("\"{0}\" ",guigamelistmenuctrl));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_getSelectedRow(sbguigamelistmenuctrl);
}
/// <summary>
/// Determines if the specified row is enabled or disabled.
///    @param row The row to set the enabled status of.
///    @return True if the specified row is enabled. False if the row is not enabled or the given index was not valid. )
/// 
/// </summary>

public bool fnGuiGameListMenuCtrl_isRowEnabled (string guigamelistmenuctrl, int row)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_isRowEnabled'" + string.Format("\"{0}\" \"{1}\" ",guigamelistmenuctrl,row));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_isRowEnabled(sbguigamelistmenuctrl, row)>=1;
}
/// <summary>
/// Sets a row's enabled status according to the given parameters.
///    @param row The index to check for validity.
///    @param enabled Indicate true to enable the row or false to disable it. )
/// 
/// </summary>

public void fnGuiGameListMenuCtrl_setRowEnabled (string guigamelistmenuctrl, int row, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_setRowEnabled'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigamelistmenuctrl,row,enabled));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_setRowEnabled(sbguigamelistmenuctrl, row, enabled);
}
/// <summary>
/// Sets the label on the given row.
///    @param row Index of the row to set the label on.
///    @param label Text to set as the label of the row. )
/// 
/// </summary>

public void fnGuiGameListMenuCtrl_setRowLabel (string guigamelistmenuctrl, int row, string label)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_setRowLabel'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigamelistmenuctrl,row,label));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);
StringBuilder sblabel = null;
if (label != null)
     sblabel = new StringBuilder(label, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_setRowLabel(sbguigamelistmenuctrl, row, sblabel);
}
/// <summary>
/// Sets the selected row. Only rows that are enabled can be selected.
///    @param row Index of the row to set as selected. )
/// 
/// </summary>

public void fnGuiGameListMenuCtrl_setSelected (string guigamelistmenuctrl, int row)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListMenuCtrl_setSelected'" + string.Format("\"{0}\" \"{1}\" ",guigamelistmenuctrl,row));
StringBuilder sbguigamelistmenuctrl = null;
if (guigamelistmenuctrl != null)
     sbguigamelistmenuctrl = new StringBuilder(guigamelistmenuctrl, 1024);

SafeNativeMethods.mwle_fnGuiGameListMenuCtrl_setSelected(sbguigamelistmenuctrl, row);
}
/// <summary>
/// Add a row to the list control.
///    @param label The text to display on the row as a label.
///    @param options A tab separated list of options.
///    @param wrapOptions Specify true to allow options to wrap at each end or false to prevent wrapping.
///    @param callback Name of a script function to use as a callback when this row is activated.
///    @param icon [optional] Index of the icon to use as a marker.
///    @param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
///    @param enabled [optional] If this row is initially enabled. )
/// 
/// </summary>

public void fnGuiGameListOptionsCtrl_addRow (string guigamelistoptionsctrl, string label, string options, bool wrapOptions, string callback, int icon, int yPad, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListOptionsCtrl_addRow'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" ",guigamelistoptionsctrl,label,options,wrapOptions,callback,icon,yPad,enabled));
StringBuilder sbguigamelistoptionsctrl = null;
if (guigamelistoptionsctrl != null)
     sbguigamelistoptionsctrl = new StringBuilder(guigamelistoptionsctrl, 1024);
StringBuilder sblabel = null;
if (label != null)
     sblabel = new StringBuilder(label, 1024);
StringBuilder sboptions = null;
if (options != null)
     sboptions = new StringBuilder(options, 1024);
StringBuilder sbcallback = null;
if (callback != null)
     sbcallback = new StringBuilder(callback, 1024);

SafeNativeMethods.mwle_fnGuiGameListOptionsCtrl_addRow(sbguigamelistoptionsctrl, sblabel, sboptions, wrapOptions, sbcallback, icon, yPad, enabled);
}
/// <summary>
/// Gets the text for the currently selected option of the given row.
///    @param row Index of the row to get the option from.
///    @return A string representing the text currently displayed as the selected option on the given row. If there is no such displayed text then the empty string is returned. )
/// 
/// </summary>

public string fnGuiGameListOptionsCtrl_getCurrentOption (string guigamelistoptionsctrl, int row)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListOptionsCtrl_getCurrentOption'" + string.Format("\"{0}\" \"{1}\" ",guigamelistoptionsctrl,row));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguigamelistoptionsctrl = null;
if (guigamelistoptionsctrl != null)
     sbguigamelistoptionsctrl = new StringBuilder(guigamelistoptionsctrl, 1024);

SafeNativeMethods.mwle_fnGuiGameListOptionsCtrl_getCurrentOption(sbguigamelistoptionsctrl, row, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Set the row's current option to the one specified
///    @param row Index of the row to set an option on.
///    @param option The option to be made active.
///    @return True if the row contained the option and was set, false otherwise. )
/// 
/// </summary>

public bool fnGuiGameListOptionsCtrl_selectOption (string guigamelistoptionsctrl, int row, string option)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListOptionsCtrl_selectOption'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigamelistoptionsctrl,row,option));
StringBuilder sbguigamelistoptionsctrl = null;
if (guigamelistoptionsctrl != null)
     sbguigamelistoptionsctrl = new StringBuilder(guigamelistoptionsctrl, 1024);
StringBuilder sboption = null;
if (option != null)
     sboption = new StringBuilder(option, 1024);

return  SafeNativeMethods.mwle_fnGuiGameListOptionsCtrl_selectOption(sbguigamelistoptionsctrl, row, sboption)>=1;
}
/// <summary>
/// Sets the list of options on the given row.
///    @param row Index of the row to set options on.
///    @param optionsList A tab separated list of options for the control. )
/// 
/// </summary>

public void fnGuiGameListOptionsCtrl_setOptions (string guigamelistoptionsctrl, int row, string optionsList)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGameListOptionsCtrl_setOptions'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigamelistoptionsctrl,row,optionsList));
StringBuilder sbguigamelistoptionsctrl = null;
if (guigamelistoptionsctrl != null)
     sbguigamelistoptionsctrl = new StringBuilder(guigamelistoptionsctrl, 1024);
StringBuilder sboptionsList = null;
if (optionsList != null)
     sboptionsList = new StringBuilder(optionsList, 1024);

SafeNativeMethods.mwle_fnGuiGameListOptionsCtrl_setOptions(sbguigamelistoptionsctrl, row, sboptionsList);
}
/// <summary>
/// Sets up the given plotting curve to automatically plot the value of the @a variable with a 
///    frequency of @a updateFrequency.
///    @param plotId Index of the plotting curve.  Must be 0=plotId6.
///    @param variable Name of the global variable.
///    @param updateFrequency Frequency with which to add new data points to the plotting curve (in milliseconds).
///    @tsexample
///    // Plot FPS counter at 1 second intervals.
///    %graph.addAutoPlot( 0, \"fps::real\", 1000 );
///    @endtsexample )
/// 
/// </summary>

public void fnGuiGraphCtrl_addAutoPlot (string guigraphctrl, int plotId, string variable, int updateFrequency)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGraphCtrl_addAutoPlot'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guigraphctrl,plotId,variable,updateFrequency));
StringBuilder sbguigraphctrl = null;
if (guigraphctrl != null)
     sbguigraphctrl = new StringBuilder(guigraphctrl, 1024);
StringBuilder sbvariable = null;
if (variable != null)
     sbvariable = new StringBuilder(variable, 1024);

SafeNativeMethods.mwle_fnGuiGraphCtrl_addAutoPlot(sbguigraphctrl, plotId, sbvariable, updateFrequency);
}
/// <summary>
/// Add a data point to the plot's curve.
///    @param plotId Index of the plotting curve to which to add the data point.  Must be 0=plotId6.
///    @param value Value of the data point to add to the curve.
///    @note Data values are added to the @b left end of the plotting curve.
///    @note A maximum number of 200 data points can be added to any single plotting curve at any one time.  If 
///       this limit is exceeded, data points on the right end of the curve are culled. )
/// 
/// </summary>

public void fnGuiGraphCtrl_addDatum (string guigraphctrl, int plotId, float value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGraphCtrl_addDatum'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigraphctrl,plotId,value));
StringBuilder sbguigraphctrl = null;
if (guigraphctrl != null)
     sbguigraphctrl = new StringBuilder(guigraphctrl, 1024);

SafeNativeMethods.mwle_fnGuiGraphCtrl_addDatum(sbguigraphctrl, plotId, value);
}
/// <summary>
/// Get a data point on the given plotting curve.
///    @param plotId Index of the plotting curve from which to fetch the data point.  Must be 0=plotId6.
///    @param index Index of the data point on the curve.
///    @return The value of the data point or -1 if @a plotId or @a index are out of range. )
/// 
/// </summary>

public float fnGuiGraphCtrl_getDatum (string guigraphctrl, int plotId, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGraphCtrl_getDatum'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigraphctrl,plotId,index));
StringBuilder sbguigraphctrl = null;
if (guigraphctrl != null)
     sbguigraphctrl = new StringBuilder(guigraphctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiGraphCtrl_getDatum(sbguigraphctrl, plotId, index);
}
/// <summary>
/// Stop automatic variable plotting for the given curve.
///    @param plotId Index of the plotting curve.  Must be 0=plotId6. )
/// 
/// </summary>

public void fnGuiGraphCtrl_removeAutoPlot (string guigraphctrl, int plotId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGraphCtrl_removeAutoPlot'" + string.Format("\"{0}\" \"{1}\" ",guigraphctrl,plotId));
StringBuilder sbguigraphctrl = null;
if (guigraphctrl != null)
     sbguigraphctrl = new StringBuilder(guigraphctrl, 1024);

SafeNativeMethods.mwle_fnGuiGraphCtrl_removeAutoPlot(sbguigraphctrl, plotId);
}
/// <summary>
/// Change the charting type of the given plotting curve.
///    @param plotId Index of the plotting curve.  Must be 0=plotId6.
///    @param graphType Charting type to use for the curve.
///    @note Instead of calling this method, you can directly assign to #plotType. )
/// 
/// </summary>

public void fnGuiGraphCtrl_setGraphType (string guigraphctrl, int plotId, int graphType)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiGraphCtrl_setGraphType'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guigraphctrl,plotId,graphType));
StringBuilder sbguigraphctrl = null;
if (guigraphctrl != null)
     sbguigraphctrl = new StringBuilder(guigraphctrl, 1024);

SafeNativeMethods.mwle_fnGuiGraphCtrl_setGraphType(sbguigraphctrl, plotId, graphType);
}
/// <summary>
/// @brief Set the bitmap to use for the button portion of this control.
///    @param buttonFilename Filename for the image
///    @tsexample
///    // Define the button filename
///    %buttonFilename = \"pearlButton\";
///    // Inform the GuiIconButtonCtrl control to update its main button graphic to the defined bitmap
///    %thisGuiIconButtonCtrl.setBitmap(%buttonFilename);
///    @endtsexample
///    @see GuiControl
///    @see GuiButtonCtrl)
/// 
/// </summary>

public void fnGuiIconButtonCtrl_setBitmap (string guiiconbuttonctrl, string buttonFilename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiIconButtonCtrl_setBitmap'" + string.Format("\"{0}\" \"{1}\" ",guiiconbuttonctrl,buttonFilename));
StringBuilder sbguiiconbuttonctrl = null;
if (guiiconbuttonctrl != null)
     sbguiiconbuttonctrl = new StringBuilder(guiiconbuttonctrl, 1024);
StringBuilder sbbuttonFilename = null;
if (buttonFilename != null)
     sbbuttonFilename = new StringBuilder(buttonFilename, 1024);

SafeNativeMethods.mwle_fnGuiIconButtonCtrl_setBitmap(sbguiiconbuttonctrl, sbbuttonFilename);
}
/// <summary>
/// @brief Clears the imagelist
///    @tsexample
///    // Inform the GuiImageList control to clear itself.
///    %isFinished = %thisGuiImageList.clear();
///    @endtsexample
///    @return Returns true when finished.
///    @see SimObject)
/// 
/// </summary>

public bool fnGuiImageList_clear (string guiimagelist)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_clear'" + string.Format("\"{0}\" ",guiimagelist));
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);

return  SafeNativeMethods.mwle_fnGuiImageList_clear(sbguiimagelist)>=1;
}
/// <summary>
/// @brief Gets the number of images in the list.
///    @tsexample
///    // Request the number of images from the GuiImageList control.
///    %imageCount = %thisGuiImageList.count();
///    @endtsexample
///    @return Number of images in the control.
///    @see SimObject)
/// 
/// </summary>

public int fnGuiImageList_count (string guiimagelist)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_count'" + string.Format("\"{0}\" ",guiimagelist));
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);

return  SafeNativeMethods.mwle_fnGuiImageList_count(sbguiimagelist);
}
/// <summary>
/// @brief Get a path to the texture at the specified index.
///    @param index Index of the image in the list.
///    @tsexample
///    // Define the image index/n
///    %index = \"5\";
///    // Request the image path location from the control.
///    %imagePath = %thisGuiImageList.getImage(%index);
///    @endtsexample
///    @return File path to the image map for the specified index.
///    @see SimObject)
/// 
/// </summary>

public string fnGuiImageList_getImage (string guiimagelist, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_getImage'" + string.Format("\"{0}\" \"{1}\" ",guiimagelist,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);

SafeNativeMethods.mwle_fnGuiImageList_getImage(sbguiimagelist, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Retrieves the imageindex of a specified texture in the list.
///    @param imagePath Imagemap including filepath of image to search for
///    @tsexample
///    // Define the imagemap to search for
///    %imagePath = \"./game/client/data/images/thisImage\";
///    // Request the index entry for the defined imagemap
///    %imageIndex = %thisGuiImageList.getIndex(%imagePath);
///    @endtsexample
///    @return Index of the imagemap matching the defined image path.
///    @see SimObject)
/// 
/// </summary>

public int fnGuiImageList_getIndex (string guiimagelist, string imagePath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_getIndex'" + string.Format("\"{0}\" \"{1}\" ",guiimagelist,imagePath));
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);
StringBuilder sbimagePath = null;
if (imagePath != null)
     sbimagePath = new StringBuilder(imagePath, 1024);

return  SafeNativeMethods.mwle_fnGuiImageList_getIndex(sbguiimagelist, sbimagePath);
}
/// <summary>
/// @brief Insert an image into imagelist- returns the image index or -1 for failure.
///    @param imagePath Imagemap, with path, to add to the list.
///    @tsexample
///    // Define the imagemap to add to the list
///    %imagePath = \"./game/client/data/images/thisImage\";
///    // Request the GuiImageList control to add the defined image to its list.
///    %imageIndex = %thisGuiImageList.insert(%imagePath);
///    @endtsexample
///    @return The index of the newly inserted imagemap, or -1 if the insertion failed.
///    @see SimObject)
/// 
/// </summary>

public int fnGuiImageList_insert (string guiimagelist, string imagePath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_insert'" + string.Format("\"{0}\" \"{1}\" ",guiimagelist,imagePath));
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);
StringBuilder sbimagePath = null;
if (imagePath != null)
     sbimagePath = new StringBuilder(imagePath, 1024);

return  SafeNativeMethods.mwle_fnGuiImageList_insert(sbguiimagelist, sbimagePath);
}
/// <summary>
/// @brief Removes an image from the list by index.
///    @param index Image index to remove.
///    @tsexample
///    // Define the image index.
///    %imageIndex = \"4\";
///    // Inform the GuiImageList control to remove the image at the defined index.
///    %wasSuccessful = %thisGuiImageList.remove(%imageIndex);
///    @endtsexample
///    @return True if the operation was successful, false if it was not.
///    @see SimObject)
/// 
/// </summary>

public bool fnGuiImageList_remove (string guiimagelist, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiImageList_remove'" + string.Format("\"{0}\" \"{1}\" ",guiimagelist,index));
StringBuilder sbguiimagelist = null;
if (guiimagelist != null)
     sbguiimagelist = new StringBuilder(guiimagelist, 1024);

return  SafeNativeMethods.mwle_fnGuiImageList_remove(sbguiimagelist, index)>=1;
}
/// <summary>
/// ( GuiInspectorTypeBitMask32, applyBit, void, 2,2, apply(); )
/// 
/// </summary>

public void fnGuiInspectorTypeBitMask32_applyBit (string guiinspectortypebitmask32)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiInspectorTypeBitMask32_applyBit'" + string.Format("\"{0}\" ",guiinspectortypebitmask32));
StringBuilder sbguiinspectortypebitmask32 = null;
if (guiinspectortypebitmask32 != null)
     sbguiinspectortypebitmask32 = new StringBuilder(guiinspectortypebitmask32, 1024);

SafeNativeMethods.mwle_fnGuiInspectorTypeBitMask32_applyBit(sbguiinspectortypebitmask32);
}
/// <summary>
/// ( GuiInspectorTypeFileName, apply, void, 3,3, apply(newValue); )
/// 
/// </summary>

public void fnGuiInspectorTypeFileName_apply (string guiinspectortypefilename, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiInspectorTypeFileName_apply'" + string.Format("\"{0}\" \"{1}\" ",guiinspectortypefilename,a2));
StringBuilder sbguiinspectortypefilename = null;
if (guiinspectortypefilename != null)
     sbguiinspectortypefilename = new StringBuilder(guiinspectortypefilename, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnGuiInspectorTypeFileName_apply(sbguiinspectortypefilename, sba2);
}
/// <summary>
/// @brief Checks if there is an item with the exact text of what is passed in, and if so
///    the item is removed from the list and adds that item's data to the filtered list.
///    @param itemName Name of the item that we wish to add to the filtered item list of the GuiListBoxCtrl.
///    @tsexample
///    // Define the itemName that we wish to add to the filtered item list.
///    %itemName = \"This Item Name\";
///    // Add the item name to the filtered item list.
///    %thisGuiListBoxCtrl.addFilteredItem(%filteredItemName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_addFilteredItem (string guilistboxctrl, string newItem)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_addFilteredItem'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,newItem));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbnewItem = null;
if (newItem != null)
     sbnewItem = new StringBuilder(newItem, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_addFilteredItem(sbguilistboxctrl, sbnewItem);
}
/// <summary>
///  ),
///    @brief Adds an item to the end of the list with an optional color.
///    @param newItem New item to add to the list.
///    @param color Optional color parameter to add to the new item.
///    @tsexample
///    // Define the item to add to the list.
///    %newItem = \"Gideon's Blue Coat\";
///    // Define the optional color for the new list item.
///    %color = \"0.0 0.0 1.0\";
///    // Inform the GuiListBoxCtrl object to add the item to the end of the list with the defined color.
///    %thisGuiListBoxCtrl.addItem(%newItem,%color);
///    @endtsexample
///    @return If not void, return value and description
///    @see GuiControl
///    @hide)
/// 
/// </summary>

public int fnGuiListBoxCtrl_addItem (string guilistboxctrl, string newItem, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_addItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,newItem,color));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbnewItem = null;
if (newItem != null)
     sbnewItem = new StringBuilder(newItem, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_addItem(sbguilistboxctrl, sbnewItem, sbcolor);
}
/// <summary>
/// @brief Removes any custom coloring from an item at the defined index id in the list.
///    @param index Index id for the item to clear any custom color from.
///    @tsexample
///    // Define the index id
///    %index = \"4\";
///    // Request the GuiListBoxCtrl object to remove any custom coloring from the defined index entry
///    %thisGuiListBoxCtrl.clearItemColor(%index);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_clearItemColor (string guilistboxctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_clearItemColor'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,index));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_clearItemColor(sbguilistboxctrl, index);
}
/// <summary>
/// @brief Clears all the items in the listbox.
///    @tsexample
///    // Inform the GuiListBoxCtrl object to clear all items from its list.
///    %thisGuiListBoxCtrl.clearItems();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_clearItems (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_clearItems'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_clearItems(sbguilistboxctrl);
}
/// <summary>
/// @brief Sets all currently selected items to unselected.
///    Detailed description
///    @tsexample
///    // Inform the GuiListBoxCtrl object to set all of its items to unselected./n
///    %thisGuiListBoxCtrl.clearSelection();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_clearSelection (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_clearSelection'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_clearSelection(sbguilistboxctrl);
}
/// <summary>
/// @brief Removes the list entry at the requested index id from the control and clears the memory associated with it.
///    @param itemIndex Index id location to remove the item from.
///    @tsexample
///    // Define the index id we want to remove from the list
///    %itemIndex = \"8\";
///    // Inform the GuiListBoxCtrl object to remove the item at the defined index id.
///    %thisGuiListBoxCtrl.deleteItem(%itemIndex);
///    @endtsexample
///    @see References)
/// 
/// </summary>

public void fnGuiListBoxCtrl_deleteItem (string guilistboxctrl, int itemIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_deleteItem'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,itemIndex));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_deleteItem(sbguilistboxctrl, itemIndex);
}
/// <summary>
/// @brief Informs the GuiListBoxCtrl object to mirror the contents of the GuiListBoxCtrl stored in the mirrorSet field.
///    @tsexample
///    \\ Inform the object to mirror the object located at %thisGuiListBox.mirrorSet
///    %thisGuiListBox.doMirror();
///    @endtsexample
///    @see GuiCore)
/// 
/// </summary>

public void fnGuiListBoxCtrl_doMirror (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_doMirror'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_doMirror(sbguilistboxctrl);
}
/// <summary>
/// @brief Returns index of item with matching text or -1 if none found.
///    @param findText Text in the list to find.
///    @param isCaseSensitive If true, the search will be case sensitive.
///    @tsexample
///    // Define the text we wish to find in the list.
///    %findText = \"Hickory Smoked Gideon\"/n/n
///    // Define if this is a case sensitive search or not.
///    %isCaseSensitive = \"false\";
///    // Ask the GuiListBoxCtrl object what item id in the list matches the requested text.
///    %matchingId = %thisGuiListBoxCtrl.findItemText(%findText,%isCaseSensitive);
///    @endtsexample
///    @return Index id of item with matching text or -1 if none found.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiListBoxCtrl_findItemText (string guilistboxctrl, string findText, bool bCaseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_findItemText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,findText,bCaseSensitive));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbfindText = null;
if (findText != null)
     sbfindText = new StringBuilder(findText, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_findItemText(sbguilistboxctrl, sbfindText, bCaseSensitive);
}
/// <summary>
/// @brief Returns the number of items in the list.
///    @tsexample
///    // Request the number of items in the list of the GuiListBoxCtrl object.
///    %listItemCount = %thisGuiListBoxCtrl.getItemCount();
///    @endtsexample
///    @return The number of items in the list.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiListBoxCtrl_getItemCount (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getItemCount'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_getItemCount(sbguilistboxctrl);
}
/// <summary>
/// @brief Returns the object associated with an item. This only makes sense if you are mirroring a simset.
///    @param index Index id to request the associated item from.
///    @tsexample
///    // Define the index id
///    %index = \"12\";
///    // Request the item from the GuiListBoxCtrl object
///    %object = %thisGuiListBoxCtrl.getItemObject(%index);
///    @endtsexample
///    @return The object associated with the item in the list.
///    @see References)
/// 
/// </summary>

public string fnGuiListBoxCtrl_getItemObject (string guilistboxctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getItemObject'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_getItemObject(sbguilistboxctrl, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the text of the item at the specified index.
///    @param index Index id to return the item text from.
///    @tsexample
///    // Define the index id entry to request the text from
///    %index = \"12\";
///    // Request the item id text from the GuiListBoxCtrl object.
///    %text = %thisGuiListBoxCtrl.getItemText(%index);
///    @endtsexample
///    @return The text of the requested index id.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiListBoxCtrl_getItemText (string guilistboxctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getItemText'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_getItemText(sbguilistboxctrl, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Request the item index for the item that was last clicked.
///    @tsexample
///    // Request the item index for the last clicked item in the list
///    %lastClickedIndex = %thisGuiListBoxCtrl.getLastClickItem();
///    @endtsexample
///    @return Index id for the last clicked item in the list.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiListBoxCtrl_getLastClickItem (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getLastClickItem'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_getLastClickItem(sbguilistboxctrl);
}
/// <summary>
/// @brief Returns the number of items currently selected.
///    @tsexample
///    // Request the number of currently selected items
///    %selectedItemCount = %thisGuiListBoxCtrl.getSelCount();
///    @endtsexample
///    @return Number of currently selected items.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiListBoxCtrl_getSelCount (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getSelCount'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_getSelCount(sbguilistboxctrl);
}
/// <summary>
/// @brief Returns the selected items index or -1 if none selected. If multiple selections exist it returns the first selected item. 
///    @tsexample
///    // Request the index id of the currently selected item
///    %selectedItemId = %thisGuiListBoxCtrl.getSelectedItem();
///    @endtsexample
///    @return The selected items index or -1 if none selected.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiListBoxCtrl_getSelectedItem (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getSelectedItem'" + string.Format("\"{0}\" ",guilistboxctrl));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiListBoxCtrl_getSelectedItem(sbguilistboxctrl);
}
/// <summary>
/// @brief Returns a space delimited list of the selected items indexes in the list.
///    @tsexample
///    // Request a space delimited list of the items in the GuiListBoxCtrl object.
///    %selectionList = %thisGuiListBoxCtrl.getSelectedItems();
///    @endtsexample
///    @return Space delimited list of the selected items indexes in the list
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiListBoxCtrl_getSelectedItems (string guilistboxctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_getSelectedItems'" + string.Format("\"{0}\" ",guilistboxctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_getSelectedItems(sbguilistboxctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Inserts an item into the list at the specified index and returns the index assigned or -1 on error.
///    @param text Text item to add.
///    @param index Index id to insert the list item text at.
///    @tsexample
///    // Define the text to insert
///    %text = \"Secret Agent Gideon\";
///    // Define the index entry to insert the text at
///    %index = \"14\";
///    // In form the GuiListBoxCtrl object to insert the text at the defined index.
///    %assignedId = %thisGuiListBoxCtrl.insertItem(%text,%index);
///    @endtsexample
///    @return If successful will return the index id assigned. If unsuccessful, will return -1.
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_insertItem (string guilistboxctrl, string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_insertItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,text,index));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_insertItem(sbguilistboxctrl, sbtext, index);
}
/// <summary>
/// @brief Removes an item of the entered name from the filtered items list.
///    @param itemName Name of the item to remove from the filtered list.
///    @tsexample
///    // Define the itemName that you wish to remove.
///    %itemName = \"This Item Name\";
///    // Remove the itemName from the GuiListBoxCtrl
///    %thisGuiListBoxCtrl.removeFilteredItem(%itemName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_removeFilteredItem (string guilistboxctrl, string itemName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_removeFilteredItem'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,itemName));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbitemName = null;
if (itemName != null)
     sbitemName = new StringBuilder(itemName, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_removeFilteredItem(sbguilistboxctrl, sbitemName);
}
/// <summary>
/// @brief Sets the currently selected item at the specified index.
///    @param indexId Index Id to set selected.
///    @tsexample
///    // Define the index id that we wish to select.
///    %selectId = \"4\";
///    // Inform the GuiListBoxCtrl object to set the requested index as selected.
///    %thisGuiListBoxCtrl.setCurSel(%selectId);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setCurSel (string guilistboxctrl, int indexId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setCurSel'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,indexId));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setCurSel(sbguilistboxctrl, indexId);
}
/// <summary>
/// @brief Sets the current selection range from index start to stop. If no stop is specified it sets from start index to the end of the list
///    @param indexStart Index Id to start selection.
///    @param indexStop Index Id to end selection.
///    @tsexample
///    // Set start id
///    %indexStart = \"3\";
///    // Set end id
///    %indexEnd = \"6\";
///    // Request the GuiListBoxCtrl object to select the defined range.
///    %thisGuiListBoxCtrl.setCurSelRange(%indexStart,%indexEnd);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setCurSelRange (string guilistboxctrl, int indexStart, int indexStop)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setCurSelRange'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,indexStart,indexStop));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setCurSelRange(sbguilistboxctrl, indexStart, indexStop);
}
/// <summary>
/// @brief Sets the color of a single list entry at the specified index id.
///    @param index Index id to modify the color of in the list.
///    @param color Color value to set the list entry to.
///    @tsexample
///    // Define the index id value
///    %index = \"5\";
///    // Define the color value
///    %color = \"1.0 0.0 0.0\";
///    // Inform the GuiListBoxCtrl object to change the color of the requested index
///    %thisGuiListBoxCtrl.setItemColor(%index,%color);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setItemColor (string guilistboxctrl, int index, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setItemColor'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,index,color));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setItemColor(sbguilistboxctrl, index, sbcolor);
}
/// <summary>
/// @brief Sets the items text at the specified index.
///    @param index Index id to set the item text at.
///    @param newtext Text to change the list item at index id to.
///    @tsexample
///    // Define the index id/n
///    %index = \"12\";
///    // Define the text to set the list item to
///    %newtext = \"Gideon's Fancy Goggles\";
///    // Inform the GuiListBoxCtrl object to change the text at the requested index
///    %thisGuiListBoxCtrl.setItemText(%index,%newText);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setItemText (string guilistboxctrl, int index, string newtext)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setItemText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,index,newtext));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbnewtext = null;
if (newtext != null)
     sbnewtext = new StringBuilder(newtext, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setItemText(sbguilistboxctrl, index, sbnewtext);
}
/// <summary>
/// @brief Set the tooltip text to display for the given list item.
///    @param index Index id to change the tooltip text
///    @param text Text for the tooltip.
///    @tsexample
///    // Define the index id
///    %index = \"12\";
///    // Define the tooltip text
///    %tooltip = \"Gideon's goggles can see through space and time.\"
///    // Inform the GuiListBoxCtrl object to set the tooltop for the item at the defined index id
///    %thisGuiListBoxCtrl.setItemToolTip(%index,%tooltip);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setItemTooltip (string guilistboxctrl, int index, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setItemTooltip'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,index,text));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setItemTooltip(sbguilistboxctrl, index, sbtext);
}
/// <summary>
/// @brief Enable or disable multiple selections for this GuiListBoxCtrl object.
///    @param allowMultSelections Boolean variable to set the use of multiple selections or not.
///    @tsexample
///    // Define the multiple selection use state.
///    %allowMultSelections = \"true\";
///    // Set the allow  multiple selection state on the GuiListBoxCtrl object.
///    %thisGuiListBoxCtrl.setMultipleSelection(%allowMultSelections);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setMultipleSelection (string guilistboxctrl, bool allowMultSelections)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setMultipleSelection'" + string.Format("\"{0}\" \"{1}\" ",guilistboxctrl,allowMultSelections));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setMultipleSelection(sbguilistboxctrl, allowMultSelections);
}
/// <summary>
/// @brief Sets the item at the index specified to selected or not.
///    Detailed description
///    @param index Item index to set selected or unselected.
///    @param setSelected Boolean selection state to set the requested item index.
///    @tsexample
///    // Define the index
///    %index = \"5\";
///    // Define the selection state
///    %selected = \"true\"
///    // Inform the GuiListBoxCtrl object of the new selection state for the requested index entry.
///    %thisGuiListBoxCtrl.setSelected(%index,%selected);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiListBoxCtrl_setSelected (string guilistboxctrl, int index, bool setSelected)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiListBoxCtrl_setSelected'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guilistboxctrl,index,setSelected));
StringBuilder sbguilistboxctrl = null;
if (guilistboxctrl != null)
     sbguilistboxctrl = new StringBuilder(guilistboxctrl, 1024);

SafeNativeMethods.mwle_fnGuiListBoxCtrl_setSelected(sbguilistboxctrl, index, setSelected);
}
/// <summary>
/// Deletes the preview model.)
/// 
/// </summary>

public void fnGuiMaterialPreview_deleteModel (string guimaterialpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_deleteModel'" + string.Format("\"{0}\" ",guimaterialpreview));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_deleteModel(sbguimaterialpreview);
}
/// <summary>
/// Resets the viewport to default zoom, pan, rotate and lighting.)
/// 
/// </summary>

public void fnGuiMaterialPreview_reset (string guimaterialpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_reset'" + string.Format("\"{0}\" ",guimaterialpreview));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_reset(sbguimaterialpreview);
}
/// <summary>
/// Sets the color of the ambient light in the scene.)
/// 
/// </summary>

public void fnGuiMaterialPreview_setAmbientLightColor (string guimaterialpreview, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_setAmbientLightColor'" + string.Format("\"{0}\" \"{1}\" ",guimaterialpreview,color));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_setAmbientLightColor(sbguimaterialpreview, sbcolor);
}
/// <summary>
/// Sets the color of the light in the scene.)
/// 
/// </summary>

public void fnGuiMaterialPreview_setLightColor (string guimaterialpreview, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_setLightColor'" + string.Format("\"{0}\" \"{1}\" ",guimaterialpreview,color));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_setLightColor(sbguimaterialpreview, sbcolor);
}
/// <summary>
/// Sets the model to be displayed in this control
///    @param shapeName Name of the model to display.)
/// 
/// </summary>

public void fnGuiMaterialPreview_setModel (string guimaterialpreview, string shapeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_setModel'" + string.Format("\"{0}\" \"{1}\" ",guimaterialpreview,shapeName));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);
StringBuilder sbshapeName = null;
if (shapeName != null)
     sbshapeName = new StringBuilder(shapeName, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_setModel(sbguimaterialpreview, sbshapeName);
}
/// <summary>
/// Sets the distance at which the camera orbits the object. Clamped to the 
///    acceptable range defined in the class by min and max orbit distances.
///    @param distance The distance to set the orbit to (will be clamped).)
/// 
/// </summary>

public void fnGuiMaterialPreview_setOrbitDistance (string guimaterialpreview, float distance)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMaterialPreview_setOrbitDistance'" + string.Format("\"{0}\" \"{1}\" ",guimaterialpreview,distance));
StringBuilder sbguimaterialpreview = null;
if (guimaterialpreview != null)
     sbguimaterialpreview = new StringBuilder(guimaterialpreview, 1024);

SafeNativeMethods.mwle_fnGuiMaterialPreview_setOrbitDistance(sbguimaterialpreview, distance);
}
/// <summary>
/// @brief Adds a new menu to the menu bar.
///    @param menuText Text to display for the new menu item.
///    @param menuId ID for the new menu item.
///    @tsexample
///    // Define the menu text
///    %menuText = \"New Menu\";
///    // Define the menu ID.
///    %menuId = \"2\";
///    // Inform the GuiMenuBar control to add the new menu
///    %thisGuiMenuBar.addMenu(%menuText,%menuId);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_addMenu (string guimenubar, string menuText, int menuId)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_addMenu'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,menuText,menuId));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuText = null;
if (menuText != null)
     sbmenuText = new StringBuilder(menuText, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_addMenu(sbguimenubar, sbmenuText, menuId);
}
/// <summary>
/// ,,0,,-1),
///    @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.
///    @param menu Menu name or menu Id to add the new item to.
///    @param menuItemText Text for the new menu item.
///    @param menuItemId Id for the new menu item.
///    @param accelerator Accelerator key for the new menu item.
///    @param checkGroup Check group to include this menu item in.
///    @tsexample
///    // Define the menu we wish to add the item to
///    %targetMenu = \"New Menu\";  or  %menu = \"4\";
///    // Define the text for the new menu item
///    %menuItemText = \"Menu Item\";
///    // Define the id for the new menu item
///    %menuItemId = \"3\";
///    // Set the accelerator key to toggle this menu item with
///    %accelerator = \"n\";
///    // Define the Check Group that this menu item will be in, if we want it to be in a check group. -1 sets it in no check group.
///    %checkGroup = \"4\";
///    // Inform the GuiMenuBar control to add the new menu item with the defined fields
///    %thisGuiMenuBar.addMenuItem(%menu,%menuItemText,%menuItemId,%accelerator,%checkGroup);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_addMenuItem (string guimenubar, string targetMenu, string menuItemText, int menuItemId, string accelerator, int checkGroup)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_addMenuItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",guimenubar,targetMenu,menuItemText,menuItemId,accelerator,checkGroup));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbtargetMenu = null;
if (targetMenu != null)
     sbtargetMenu = new StringBuilder(targetMenu, 1024);
StringBuilder sbmenuItemText = null;
if (menuItemText != null)
     sbmenuItemText = new StringBuilder(menuItemText, 1024);
StringBuilder sbaccelerator = null;
if (accelerator != null)
     sbaccelerator = new StringBuilder(accelerator, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_addMenuItem(sbguimenubar, sbtargetMenu, sbmenuItemText, menuItemId, sbaccelerator, checkGroup);
}
/// <summary>
/// @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.
///    @param menuTarget Menu to affect a submenu in
///    @param menuItem Menu item to affect
///    @param submenuItemText Text to show for the new submenu
///    @param submenuItemId Id for the new submenu
///    @param accelerator Accelerator key for the new submenu
///    @param checkGroup Which check group the new submenu should be in, or -1 for none.
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
///    // Define the text for the new submenu
///    %submenuItemText = \"New Submenu Item\";
///    // Define the id for the new submenu
///    %submenuItemId = \"4\";
///    // Define the accelerator key for the new submenu
///    %accelerator = \"n\";
///    // Define the checkgroup for the new submenu
///    %checkgroup = \"7\";
///    // Request the GuiMenuBar control to add the new submenu with the defined information
///    %thisGuiMenuBar.addSubmenuItem(%menuTarget,%menuItem,%submenuItemText,%submenuItemId,%accelerator,%checkgroup);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_addSubmenuItem (string guimenubar, string menuTarget, string menuItem, string submenuItemText, int submenuItemId, string accelerator, int checkGroup)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_addSubmenuItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",guimenubar,menuTarget,menuItem,submenuItemText,submenuItemId,accelerator,checkGroup));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItem = null;
if (menuItem != null)
     sbmenuItem = new StringBuilder(menuItem, 1024);
StringBuilder sbsubmenuItemText = null;
if (submenuItemText != null)
     sbsubmenuItemText = new StringBuilder(submenuItemText, 1024);
StringBuilder sbaccelerator = null;
if (accelerator != null)
     sbaccelerator = new StringBuilder(accelerator, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_addSubmenuItem(sbguimenubar, sbmenuTarget, sbmenuItem, sbsubmenuItemText, submenuItemId, sbaccelerator, checkGroup);
}
/// <summary>
/// @brief Removes all the menu items from the specified menu.
///    @param menuTarget Menu to remove all items from  
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Inform the GuiMenuBar control to clear all menu items from the defined menu
///    %thisGuiMenuBar.clearMenuItems(%menuTarget);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_clearMenuItems (string guimenubar, string menuTarget)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_clearMenuItems'" + string.Format("\"{0}\" \"{1}\" ",guimenubar,menuTarget));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_clearMenuItems(sbguimenubar, sbmenuTarget);
}
/// <summary>
/// @brief Clears all the menus from the menu bar.
///    @tsexample
///    // Inform the GuiMenuBar control to clear all menus from itself.
///    %thisGuiMenuBar.clearMenus();
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_clearMenus (string guimenubar, int param1, int param2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_clearMenus'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,param1,param2));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_clearMenus(sbguimenubar, param1, param2);
}
/// <summary>
/// @brief Removes all the menu items from the specified submenu.
///    @param menuTarget Menu to affect a submenu in
///    @param menuItem Menu item to affect
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
///    // Inform the GuiMenuBar to remove all submenu items from the defined menu item
///    %thisGuiMenuBar.clearSubmenuItems(%menuTarget,%menuItem);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMenuBar_clearSubmenuItems (string guimenubar, string menuTarget, string menuItem)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_clearSubmenuItems'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,menuTarget,menuItem));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItem = null;
if (menuItem != null)
     sbmenuItem = new StringBuilder(menuItem, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_clearSubmenuItems(sbguimenubar, sbmenuTarget, sbmenuItem);
}
/// <summary>
/// @brief Removes the specified menu from the menu bar.
///    @param menuTarget Menu to remove from the menu bar  
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Inform the GuiMenuBar to remove the defined menu from the menu bar
///    %thisGuiMenuBar.removeMenu(%menuTarget);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_removeMenu (string guimenubar, string menuTarget)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_removeMenu'" + string.Format("\"{0}\" \"{1}\" ",guimenubar,menuTarget));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_removeMenu(sbguimenubar, sbmenuTarget);
}
/// <summary>
/// @brief Removes the specified menu item from the menu.
///    @param menuTarget Menu to affect the menu item in
///    @param menuItem Menu item to affect
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
///    // Request the GuiMenuBar control to remove the define menu item
///    %thisGuiMenuBar.removeMenuItem(%menuTarget,%menuItem);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_removeMenuItem (string guimenubar, string menuTarget, string menuItemTarget)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_removeMenuItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,menuTarget,menuItemTarget));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_removeMenuItem(sbguimenubar, sbmenuTarget, sbmenuItemTarget);
}
/// <summary>
/// @brief Sets the menu bitmap index for the check mark image.
///    @param bitmapIndex Bitmap index for the check mark image.
///    @tsexample
///    // Define the bitmap index
///    %bitmapIndex = \"2\";
///    // Inform the GuiMenuBar control of the proper bitmap index for the check mark image
///    %thisGuiMenuBar.setCheckmarkBitmapIndex(%bitmapIndex);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setCheckmarkBitmapIndex (string guimenubar, int bitmapindex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setCheckmarkBitmapIndex'" + string.Format("\"{0}\" \"{1}\" ",guimenubar,bitmapindex));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setCheckmarkBitmapIndex(sbguimenubar, bitmapindex);
}
/// <summary>
/// @brief Sets the bitmap index for the menu and toggles rendering only the bitmap.
///    @param menuTarget Menu to affect
///    @param bitmapindex Bitmap index to set for the menu
///    @param bitmaponly If true, only the bitmap will be rendered
///    @param drawborder If true, a border will be drawn around the menu.
///    @tsexample
///    // Define the menuTarget to affect
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Set the bitmap index
///    %bitmapIndex = \"5\";
///    // Set if we are only to render the bitmap or not
///    %bitmaponly = \"true\";
///    // Set if we are rendering a border or not
///    %drawborder = \"true\";
///    // Inform the GuiMenuBar of the bitmap and rendering changes
///    %thisGuiMenuBar.setMenuBitmapIndex(%menuTarget,%bitmapIndex,%bitmapOnly,%drawBorder);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuBitmapIndex (string guimenubar, string menuTarget, int bitmapindex, bool bitmaponly, bool drawborder)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuBitmapIndex'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guimenubar,menuTarget,bitmapindex,bitmaponly,drawborder));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuBitmapIndex(sbguimenubar, sbmenuTarget, bitmapindex, bitmaponly, drawborder);
}
/// <summary>
/// @brief Sets the specified menu item bitmap index in the bitmap array.  Setting the item's index to -1 will remove any bitmap.
///    @param menuTarget Menu to affect the menuItem in
///    @param menuItem Menu item to affect
///    @param bitmapIndex Bitmap index to set the menu item to
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
///    // Define the menuItem\"
///    %menuItem = \"New Menu Item\";  or %menuItem = \"2\";
///    // Define the bitmapIndex
///    %bitmapIndex = \"6\";
///    // Inform the GuiMenuBar control to set the menu item to the defined bitmap
///    %thisGuiMenuBar.setMenuItemBitmap(%menuTarget,%menuItem,%bitmapIndex);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemBitmap (string guimenubar, string menuTarget, string menuItemTarget, int bitmapIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemBitmap'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItemTarget,bitmapIndex));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemBitmap(sbguimenubar, sbmenuTarget, sbmenuItemTarget, bitmapIndex);
}
/// <summary>
/// @brief Sets the menu item bitmap to a check mark, which by default is the first element in
///    the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
///    Any other menu items in the menu with the same check group become unchecked if they are checked.
///    @param menuTarget Menu to work in
///    @param menuItem Menu item to affect
///    @param checked Whether we are setting it to checked or not
///    @tsexample
///    
///    @endtsexample
///    @return If not void, return value and description
///    @see References)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemChecked (string guimenubar, string menuTarget, string menuItemTarget, bool checkedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemChecked'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItemTarget,checkedx));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemChecked(sbguimenubar, sbmenuTarget, sbmenuItemTarget, checkedx);
}
/// <summary>
/// @brief sets the menu item to enabled or disabled based on the enable parameter.
///    The specified menu and menu item can either be text or ids.
///    Detailed description
///    @param menuTarget Menu to work in
///    @param menuItemTarget The menu item inside of the menu to enable or disable
///    @param enabled Boolean enable / disable value.
///    @tsexample
///    // Define the menu
///    %menu = \"New Menu\";  or  %menu = \"4\";
///    // Define the menu item
///    %menuItem = \"New Menu Item\";  or %menuItem = \"2\";
///    // Define the enabled state
///    %enabled = \"true\";
///    // Inform the GuiMenuBar control to set the enabled state of the requested menu item
///    %thisGuiMenuBar.setMenuItemEnable(%menu,%menuItme,%enabled);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemEnable (string guimenubar, string menuTarget, string menuItemTarget, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemEnable'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItemTarget,enabled));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemEnable(sbguimenubar, sbmenuTarget, sbmenuItemTarget, enabled);
}
/// <summary>
/// @brief Sets the given menu item to be a submenu.
///    @param menuTarget Menu to affect a submenu in
///    @param menuItem Menu item to affect
///    @param isSubmenu Whether or not the menuItem will become a subMenu or not
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
///    // Define whether or not the Menu Item is a sub menu or not
///    %isSubmenu = \"true\";
///    // Inform the GuiMenuBar control to set the defined menu item to be a submenu or not.
///    %thisGuiMenuBar.setMenuItemSubmenuState(%menuTarget,%menuItem,%isSubmenu);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemSubmenuState (string guimenubar, string menuTarget, string menuItem, bool isSubmenu)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemSubmenuState'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItem,isSubmenu));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItem = null;
if (menuItem != null)
     sbmenuItem = new StringBuilder(menuItem, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemSubmenuState(sbguimenubar, sbmenuTarget, sbmenuItem, isSubmenu);
}
/// <summary>
/// @brief Sets the text of the specified menu item to the new string.
///    @param menuTarget Menu to affect
///    @param menuItem Menu item in the menu to change the text at
///    @param newMenuItemText New menu text
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or  %menuTarget = \"4\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"2\";
///    // Define the new text for the menu item
///    %newMenuItemText = \"Very New Menu Item\";
///    // Inform the GuiMenuBar control to change the defined menu item with the new text
///    %thisGuiMenuBar.setMenuItemText(%menuTarget,%menuItem,%newMenuItemText);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemText (string guimenubar, string menuTarget, string menuItemTarget, string newMenuItemText)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItemTarget,newMenuItemText));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);
StringBuilder sbnewMenuItemText = null;
if (newMenuItemText != null)
     sbnewMenuItemText = new StringBuilder(newMenuItemText, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemText(sbguimenubar, sbmenuTarget, sbmenuItemTarget, sbnewMenuItemText);
}
/// <summary>
/// @brief Brief Description.
///    Detailed description
///    @param menuTarget Menu to affect the menu item in
///    @param menuItem Menu item to affect
///    @param isVisible Visible state to set the menu item to.
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or  %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"2\";
///    // Define the visibility state
///    %isVisible = \"true\";
///    // Inform the GuiMenuBarControl of the visibility state of the defined menu item
///    %thisGuiMenuBar.setMenuItemVisible(%menuTarget,%menuItem,%isVisible);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuItemVisible (string guimenubar, string menuTarget, string menuItemTarget, bool isVisible)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuItemVisible'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,menuTarget,menuItemTarget,isVisible));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuItemVisible(sbguimenubar, sbmenuTarget, sbmenuItemTarget, isVisible);
}
/// <summary>
/// @brief Sets the menu rendering margins: horizontal, vertical, bitmap spacing.
///    Detailed description
///    @param horizontalMargin Number of pixels on the left and right side of a menu's text.
///    @param verticalMargin Number of pixels on the top and bottom of a menu's text.
///    @param bitmapToTextSpacing Number of pixels between a menu's bitmap and text.
///    @tsexample
///    // Define the horizontalMargin
///    %horizontalMargin = \"5\";
///    // Define the verticalMargin
///    %verticalMargin = \"5\";
///    // Define the bitmapToTextSpacing
///    %bitmapToTextSpacing = \"12\";
///    // Inform the GuiMenuBar control to set its margins based on the defined values.
///    %thisGuiMenuBar.setMenuMargins(%horizontalMargin,%verticalMargin,%bitmapToTextSpacing);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuMargins (string guimenubar, int horizontalMargin, int verticalMargin, int bitmapToTextSpacing)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuMargins'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guimenubar,horizontalMargin,verticalMargin,bitmapToTextSpacing));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuMargins(sbguimenubar, horizontalMargin, verticalMargin, bitmapToTextSpacing);
}
/// <summary>
/// @brief Sets the text of the specified menu to the new string.
///    @param menuTarget Menu to affect
///    @param newMenuText New menu text
///    @tsexample
///    // Define the menu to affect
///    %menu = \"New Menu\";  or %menu = \"3\";
///    // Define the text to change the menu to
///    %newMenuText = \"Still a New Menu\";
///    // Inform the GuiMenuBar control to change the defined menu to the defined text
///    %thisGuiMenuBar.setMenuText(%menu,%newMenuText);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuText (string guimenubar, string menuTarget, string newMenuText)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,menuTarget,newMenuText));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbnewMenuText = null;
if (newMenuText != null)
     sbnewMenuText = new StringBuilder(newMenuText, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuText(sbguimenubar, sbmenuTarget, sbnewMenuText);
}
/// <summary>
/// @brief Sets the whether or not to display the specified menu.
///    @param menuTarget Menu item to affect
///    @param visible Whether the menu item will be visible or not
///    @tsexample
///    // Define the menu to work with
///    %menuTarget = \"New Menu\";  or  %menuTarget = \"4\";
///    // Define if the menu should be visible or not
///    %visible = \"true\";
///    // Inform the GuiMenuBar control of the new visibility state for the defined menu
///    %thisGuiMenuBar.setMenuVisible(%menuTarget,%visible);
///    @endtsexample
///    @see GuiTickCtrl)
/// 
/// </summary>

public void fnGuiMenuBar_setMenuVisible (string guimenubar, string menuTarget, bool visible)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setMenuVisible'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimenubar,menuTarget,visible));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setMenuVisible(sbguimenubar, sbmenuTarget, visible);
}
/// <summary>
/// @brief Sets the menu item bitmap to a check mark, which by default is the first element in the
///    bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
///    Any other menu items in the menu with the same check group become unchecked if they are checked.
///    @param menuTarget Menu to affect a submenu in
///    @param menuItem Menu item to affect
///    @param submenuItemText Text to show for submenu
///    @param checked Whether or not this submenu item will be checked.
///    @tsexample
///    // Define the menuTarget
///    %menuTarget = \"New Menu\";  or %menuTarget = \"3\";
///    // Define the menuItem
///    %menuItem = \"New Menu Item\";  or  %menuItem = \"5\";
///    // Define the text for the new submenu
///    %submenuItemText = \"Submenu Item\";
///    // Define if this submenu item should be checked or not
///    %checked = \"true\";
///    // Inform the GuiMenuBar control to set the checked state of the defined submenu item
///    %thisGuiMenuBar.setSubmenuItemChecked(%menuTarget,%menuItem,%submenuItemText,%checked);
///    @endtsexample
///    @return If not void, return value and description
///    @see References)
/// 
/// </summary>

public void fnGuiMenuBar_setSubmenuItemChecked (string guimenubar, string menuTarget, string menuItemTarget, string submenuItemText, bool checkedx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMenuBar_setSubmenuItemChecked'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guimenubar,menuTarget,menuItemTarget,submenuItemText,checkedx));
StringBuilder sbguimenubar = null;
if (guimenubar != null)
     sbguimenubar = new StringBuilder(guimenubar, 1024);
StringBuilder sbmenuTarget = null;
if (menuTarget != null)
     sbmenuTarget = new StringBuilder(menuTarget, 1024);
StringBuilder sbmenuItemTarget = null;
if (menuItemTarget != null)
     sbmenuItemTarget = new StringBuilder(menuItemTarget, 1024);
StringBuilder sbsubmenuItemText = null;
if (submenuItemText != null)
     sbsubmenuItemText = new StringBuilder(submenuItemText, 1024);

SafeNativeMethods.mwle_fnGuiMenuBar_setSubmenuItemChecked(sbguimenubar, sbmenuTarget, sbmenuItemTarget, sbsubmenuItemText, checkedx);
}
/// <summary>
/// @brief Push a line onto the back of the list.
/// 
/// 	   @param item The GUI element being pushed into the control
/// 
/// 	   @tsexample
/// 	   // All messages are stored in this HudMessageVector, the actual
/// 	   // MainChatHud only displays the contents of this vector.
/// 	   new MessageVector(HudMessageVector);
/// 	   // Attach the MessageVector to the chat control
/// 	   chatHud.attach(HudMessageVector);
/// 	   @endtsexample
/// 
/// 	   @return Value)
/// 
/// </summary>

public bool fnGuiMessageVectorCtrl_attach (string guimessagevectorctrl, string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMessageVectorCtrl_attach'" + string.Format("\"{0}\" \"{1}\" ",guimessagevectorctrl,item));
StringBuilder sbguimessagevectorctrl = null;
if (guimessagevectorctrl != null)
     sbguimessagevectorctrl = new StringBuilder(guimessagevectorctrl, 1024);
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

return  SafeNativeMethods.mwle_fnGuiMessageVectorCtrl_attach(sbguimessagevectorctrl, sbitem)>=1;
}
/// <summary>
/// @brief Stop listing messages from the MessageVector previously attached to, if any.
/// 
/// 				   Detailed description
/// 
/// 				   @param param Description
/// 
/// 				   @tsexample
/// 				   // Deatch the MessageVector from HudMessageVector
/// 				   // HudMessageVector will no longer render the text
/// 				   chatHud.detach();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnGuiMessageVectorCtrl_detach (string guimessagevectorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMessageVectorCtrl_detach'" + string.Format("\"{0}\" ",guimessagevectorctrl));
StringBuilder sbguimessagevectorctrl = null;
if (guimessagevectorctrl != null)
     sbguimessagevectorctrl = new StringBuilder(guimessagevectorctrl, 1024);

SafeNativeMethods.mwle_fnGuiMessageVectorCtrl_detach(sbguimessagevectorctrl);
}
/// <summary>
/// @brief Set the MissionArea to edit.)
/// 
/// </summary>

public void fnGuiMissionAreaCtrl_setMissionArea (string guimissionareactrl, string area)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMissionAreaCtrl_setMissionArea'" + string.Format("\"{0}\" \"{1}\" ",guimissionareactrl,area));
StringBuilder sbguimissionareactrl = null;
if (guimissionareactrl != null)
     sbguimissionareactrl = new StringBuilder(guimissionareactrl, 1024);
StringBuilder sbarea = null;
if (area != null)
     sbarea = new StringBuilder(area, 1024);

SafeNativeMethods.mwle_fnGuiMissionAreaCtrl_setMissionArea(sbguimissionareactrl, sbarea);
}
/// <summary>
/// @brief Update the terrain bitmap.)
/// 
/// </summary>

public void fnGuiMissionAreaCtrl_updateTerrain (string guimissionareactrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMissionAreaCtrl_updateTerrain'" + string.Format("\"{0}\" ",guimissionareactrl));
StringBuilder sbguimissionareactrl = null;
if (guimissionareactrl != null)
     sbguimissionareactrl = new StringBuilder(guimissionareactrl, 1024);

SafeNativeMethods.mwle_fnGuiMissionAreaCtrl_updateTerrain(sbguimissionareactrl);
}
/// <summary>
/// @brief Appends the text in the control with additional text. Also .
///    @param text New text to append to the existing text.
///    @param reformat If true, the control will also be visually reset (defaults to true).
///    @tsexample
///    // Define new text to add
///    %text = \"New Text to Add\";
///    // Set reformat boolean
///    %reformat = \"true\";
///    // Inform the control to add the new text
///    %thisGuiMLTextCtrl.addText(%text,%reformat);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_addText (string guimltextctrl, string text, bool reformat)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_addText'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimltextctrl,text,reformat));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_addText(sbguimltextctrl, sbtext, reformat);
}
/// <summary>
/// @brief Forces the text control to reflow the text after new text is added, possibly resizing the control.
///    @tsexample
///    // Define new text to add
///    %newText = \"BACON!\";
///    // Add the new text to the control
///    %thisGuiMLTextCtrl.addText(%newText);
///    // Inform the GuiMLTextCtrl object to force a reflow to ensure the added text fits properly.
///    %thisGuiMLTextCtrl.forceReflow();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_forceReflow (string guimltextctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_forceReflow'" + string.Format("\"{0}\" ",guimltextctrl));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_forceReflow(sbguimltextctrl);
}
/// <summary>
/// @brief Returns the text from the control, including TorqueML characters.
///    @tsexample
///    // Get the text displayed in the control
///    %controlText = %thisGuiMLTextCtrl.getText();
///    @endtsexample
///    @return Text string displayed in the control, including any TorqueML characters.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiMLTextCtrl_getText (string guimltextctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_getText'" + string.Format("\"{0}\" ",guimltextctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_getText(sbguimltextctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Scroll to the bottom of the text.
///    @tsexample
///    // Inform GuiMLTextCtrl object to scroll to its bottom
///    %thisGuiMLTextCtrl.scrollToBottom();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_scrollToBottom (string guimltextctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_scrollToBottom'" + string.Format("\"{0}\" ",guimltextctrl));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_scrollToBottom(sbguimltextctrl);
}
/// <summary>
/// @brief Scroll down to a specified tag.
///    Detailed description
///    @param tagID TagID to scroll the control to
///    @tsexample
///    // Define the TagID we want to scroll the control to
///    %tagId = \"4\";
///    // Inform the GuiMLTextCtrl to scroll to the defined TagID
///    %thisGuiMLTextCtrl.scrollToTag(%tagId);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_scrollToTag (string guimltextctrl, int tagID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_scrollToTag'" + string.Format("\"{0}\" \"{1}\" ",guimltextctrl,tagID));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_scrollToTag(sbguimltextctrl, tagID);
}
/// <summary>
/// @brief Scroll to the top of the text.
///    @tsexample
///    // Inform GuiMLTextCtrl object to scroll to its top
///    %thisGuiMLTextCtrl.scrollToTop();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_scrollToTop (string guimltextctrl, int param1, int param2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_scrollToTop'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guimltextctrl,param1,param2));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_scrollToTop(sbguimltextctrl, param1, param2);
}
/// <summary>
/// @brief Sets the alpha value of the control.
///    @param alphaVal n - 1.0 floating value for the alpha
///    @tsexample
///    // Define the alphe value
///    %alphaVal = \"0.5\";
///    // Inform the control to update its alpha value.
///    %thisGuiMLTextCtrl.setAlpha(%alphaVal);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_setAlpha (string guimltextctrl, float alphaVal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_setAlpha'" + string.Format("\"{0}\" \"{1}\" ",guimltextctrl,alphaVal));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_setAlpha(sbguimltextctrl, alphaVal);
}
/// <summary>
/// @brief Change the text cursor's position to a new defined offset within the text in the control.
///    @param newPos Offset to place cursor.
///    @tsexample
///    // Define cursor offset position
///    %position = \"23\";
///    // Inform the GuiMLTextCtrl object to move the cursor to the new position.
///    %thisGuiMLTextCtrl.setCursorPosition(%position);
///    @endtsexample
///    @return Returns true if the cursor position moved, or false if the position was not changed.
///    @see GuiControl)
/// 
/// </summary>

public bool fnGuiMLTextCtrl_setCursorPosition (string guimltextctrl, int newPos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_setCursorPosition'" + string.Format("\"{0}\" \"{1}\" ",guimltextctrl,newPos));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiMLTextCtrl_setCursorPosition(sbguimltextctrl, newPos)>=1;
}
/// <summary>
/// @brief Set the text contained in the control.
///    @param text The text to display in the control.
///    @tsexample
///    // Define the text to display
///    %text = \"Nifty Control Text\";
///    // Set the text displayed within the control
///    %thisGuiMLTextCtrl.setText(%text);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiMLTextCtrl_setText (string guimltextctrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiMLTextCtrl_setText'" + string.Format("\"{0}\" \"{1}\" ",guimltextctrl,text));
StringBuilder sbguimltextctrl = null;
if (guimltextctrl != null)
     sbguimltextctrl = new StringBuilder(guimltextctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiMLTextCtrl_setText(sbguimltextctrl, sbtext);
}
/// <summary>
/// @brief Build the currently selected tile.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_buildTile (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_buildTile'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_buildTile(sbguinaveditorctrl);
}
/// <summary>
/// @brief Delete the currently selected link.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_deleteLink (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_deleteLink'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_deleteLink(sbguinaveditorctrl);
}
/// <summary>
/// @brief Deselect whatever is currently selected in the editor.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_deselect (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_deselect'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_deselect(sbguinaveditorctrl);
}
/// <summary>
/// @brief Select a NavMesh object.)
/// 
/// </summary>

public int fnGuiNavEditorCtrl_getMesh (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_getMesh'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiNavEditorCtrl_getMesh(sbguinaveditorctrl);
}
/// <summary>
/// @brief Select a NavMesh object.)
/// 
/// </summary>

public int fnGuiNavEditorCtrl_getPlayer (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_getPlayer'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiNavEditorCtrl_getPlayer(sbguinaveditorctrl);
}
/// <summary>
/// @brief Select a NavMesh object.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_selectMesh (string guinaveditorctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_selectMesh'" + string.Format("\"{0}\" \"{1}\" ",guinaveditorctrl,id));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_selectMesh(sbguinaveditorctrl, id);
}
/// <summary>
/// @Brief Set jump and drop properties of the selected link.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_setLinkFlags (string guinaveditorctrl, uint flags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_setLinkFlags'" + string.Format("\"{0}\" \"{1}\" ",guinaveditorctrl,flags));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_setLinkFlags(sbguinaveditorctrl, flags);
}
/// <summary>
/// @brief Spawn an AIPlayer at the centre of the screen.)
/// 
/// </summary>

public void fnGuiNavEditorCtrl_spawnPlayer (string guinaveditorctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiNavEditorCtrl_spawnPlayer'" + string.Format("\"{0}\" ",guinaveditorctrl));
StringBuilder sbguinaveditorctrl = null;
if (guinaveditorctrl != null)
     sbguinaveditorctrl = new StringBuilder(guinaveditorctrl, 1024);

SafeNativeMethods.mwle_fnGuiNavEditorCtrl_spawnPlayer(sbguinaveditorctrl);
}
/// <summary>
/// @brief Return the current multiplier for camera zooming and rotation.
///    @tsexample
///    // Request the current camera zooming and rotation multiplier value
///    %multiplier = %thisGuiObjectView.getCameraSpeed();
///    @endtsexample
///    @return Camera zooming / rotation multiplier value.
///    @see GuiControl)
/// 
/// </summary>

public float fnGuiObjectView_getCameraSpeed (string guiobjectview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getCameraSpeed'" + string.Format("\"{0}\" ",guiobjectview));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

return  SafeNativeMethods.mwle_fnGuiObjectView_getCameraSpeed(sbguiobjectview);
}
/// <summary>
/// @brief Return the model displayed in this view.
///    @tsexample
///    // Request the displayed model name from the GuiObjectView object.
///    %modelName = %thisGuiObjectView.getModel();
///    @endtsexample
///    @return Name of the displayed model.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiObjectView_getModel (string guiobjectview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getModel'" + string.Format("\"{0}\" ",guiobjectview));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_getModel(sbguiobjectview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Return the name of the mounted model.
///    @tsexample
///    // Request the name of the mounted model from the GuiObjectView object
///    %mountedModelName = %thisGuiObjectView.getMountedModel();
///    @endtsexample
///    @return Name of the mounted model.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiObjectView_getMountedModel (string guiobjectview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getMountedModel'" + string.Format("\"{0}\" ",guiobjectview));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_getMountedModel(sbguiobjectview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Return the name of skin used on the mounted model.
///    @tsexample
///    // Request the skin name from the model mounted on to the main model in the control
///    %mountModelSkin = %thisGuiObjectView.getMountSkin();
///    @endtsexample
///    @return Name of the skin used on the mounted model.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiObjectView_getMountSkin (string guiobjectview, int param1, int param2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getMountSkin'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiobjectview,param1,param2));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_getMountSkin(sbguiobjectview, param1, param2, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Return the current distance at which the camera orbits the object.
///    @tsexample
///    // Request the current orbit distance
///    %orbitDistance = %thisGuiObjectView.getOrbitDistance();
///    @endtsexample
///    @return The distance at which the camera orbits the object.
///    @see GuiControl)
/// 
/// </summary>

public float fnGuiObjectView_getOrbitDistance (string guiobjectview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getOrbitDistance'" + string.Format("\"{0}\" ",guiobjectview));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

return  SafeNativeMethods.mwle_fnGuiObjectView_getOrbitDistance(sbguiobjectview);
}
/// <summary>
/// @brief Return the name of skin used on the primary model.
///    @tsexample
///    // Request the name of the skin used on the primary model in the control
///    %skinName = %thisGuiObjectView.getSkin();
///    @endtsexample
///    @return Name of the skin used on the primary model.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiObjectView_getSkin (string guiobjectview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_getSkin'" + string.Format("\"{0}\" ",guiobjectview));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_getSkin(sbguiobjectview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Sets the multiplier for the camera rotation and zoom speed.
///    @param factor Multiplier for camera rotation and zoom speed.
///    @tsexample
///    // Set the factor value
///    %factor = \"0.75\";
///    // Inform the GuiObjectView object to set the camera speed.
///    %thisGuiObjectView.setCameraSpeed(%factor);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setCameraSpeed (string guiobjectview, float factor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setCameraSpeed'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,factor));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setCameraSpeed(sbguiobjectview, factor);
}
/// <summary>
/// @brief Set the light ambient color on the sun object used to render the model.
///    @param color Ambient color of sunlight.
///    @tsexample
///    // Define the sun ambient color value
///    %color = \"1.0 0.4 0.6\";
///    // Inform the GuiObjectView object to set the sun ambient color to the requested value
///    %thisGuiObjectView.setLightAmbient(%color);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setLightAmbient (string guiobjectview, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setLightAmbient'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,color));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setLightAmbient(sbguiobjectview, sbcolor);
}
/// <summary>
/// @brief Set the light color on the sun object used to render the model.
///    @param color Color of sunlight.
///    @tsexample
///    // Set the color value for the sun
///    %color = \"1.0 0.4 0.5\";
///    // Inform the GuiObjectView object to change the sun color to the defined value
///    %thisGuiObjectView.setLightColor(%color);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setLightColor (string guiobjectview, string color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setLightColor'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,color));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbcolor = null;
if (color != null)
     sbcolor = new StringBuilder(color, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setLightColor(sbguiobjectview, sbcolor);
}
/// <summary>
/// @brief Set the light direction from which to light the model.
///    @param direction XYZ direction from which the light will shine on the model
///    @tsexample
///    // Set the light direction
///    %direction = \"1.0 0.2 0.4\"
///    // Inform the GuiObjectView object to change the light direction to the defined value
///    %thisGuiObjectView.setLightDirection(%direction);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setLightDirection (string guiobjectview, string direction)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setLightDirection'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,direction));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbdirection = null;
if (direction != null)
     sbdirection = new StringBuilder(direction, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setLightDirection(sbguiobjectview, sbdirection);
}
/// <summary>
/// @brief Sets the model to be displayed in this control.
///    @param shapeName Name of the model to display.
///    @tsexample
///    // Define the model we want to display
///    %shapeName = \"gideon.dts\";
///    // Tell the GuiObjectView object to display the defined model
///    %thisGuiObjectView.setModel(%shapeName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setModel (string guiobjectview, string shapeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setModel'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,shapeName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbshapeName = null;
if (shapeName != null)
     sbshapeName = new StringBuilder(shapeName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setModel(sbguiobjectview, sbshapeName);
}
/// <summary>
/// @brief Mounts the given model to the specified mount point of the primary model displayed in this control.
///    Detailed description
///    @param shapeName Name of the model to mount.
///    @param mountNodeIndexOrName Index or name of the mount point to be mounted to. If index, corresponds to \"mountN\" in your shape where N is the number passed here.
///    @tsexample
///    // Set the shapeName to mount
///    %shapeName = \"GideonGlasses.dts\"
///    // Set the mount node of the primary model in the control to mount the new shape at
///    %mountNodeIndexOrName = \"3\";
///    //OR:
///    %mountNodeIndexOrName = \"Face\";
///    // Inform the GuiObjectView object to mount the shape at the specified node.
///    %thisGuiObjectView.setMount(%shapeName,%mountNodeIndexOrName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setMount (string guiobjectview, string shapeName, string mountNodeIndexOrName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setMount'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiobjectview,shapeName,mountNodeIndexOrName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbshapeName = null;
if (shapeName != null)
     sbshapeName = new StringBuilder(shapeName, 1024);
StringBuilder sbmountNodeIndexOrName = null;
if (mountNodeIndexOrName != null)
     sbmountNodeIndexOrName = new StringBuilder(mountNodeIndexOrName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setMount(sbguiobjectview, sbshapeName, sbmountNodeIndexOrName);
}
/// <summary>
/// @brief Sets the model to be mounted on the primary model.
///    @param shapeName Name of the model to mount.
///    @tsexample
///    // Define the model name to mount
///    %modelToMount = \"GideonGlasses.dts\";
///    // Inform the GuiObjectView object to mount the defined model to the existing model in the control
///    %thisGuiObjectView.setMountedModel(%modelToMount);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setMountedModel (string guiobjectview, string shapeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setMountedModel'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,shapeName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbshapeName = null;
if (shapeName != null)
     sbshapeName = new StringBuilder(shapeName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setMountedModel(sbguiobjectview, sbshapeName);
}
/// <summary>
/// @brief Sets the skin to use on the mounted model.
///    @param skinName Name of the skin to set on the model mounted to the main model in the control
///    @tsexample
///    // Define the name of the skin
///    %skinName = \"BronzeGlasses\";
///    // Inform the GuiObjectView Control of the skin to use on the mounted model
///    %thisGuiObjectViewCtrl.setMountSkin(%skinName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setMountSkin (string guiobjectview, string skinName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setMountSkin'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,skinName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbskinName = null;
if (skinName != null)
     sbskinName = new StringBuilder(skinName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setMountSkin(sbguiobjectview, sbskinName);
}
/// <summary>
/// @brief Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.
///    Detailed description
///    @param distance The distance to set the orbit to (will be clamped).
///    @tsexample
///    // Define the orbit distance value
///    %orbitDistance = \"1.5\";
///    // Inform the GuiObjectView object to set the orbit distance to the defined value
///    %thisGuiObjectView.setOrbitDistance(%orbitDistance);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setOrbitDistance (string guiobjectview, float distance)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setOrbitDistance'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,distance));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setOrbitDistance(sbguiobjectview, distance);
}
/// <summary>
/// @brief Sets the animation to play for the viewed object.
///    @param indexOrName The index or name of the animation to play.
///    @tsexample
///    // Set the animation index value, or animation sequence name.
///    %indexVal = \"3\";
///    //OR:
///    %indexVal = \"idle\";
///    // Inform the GuiObjectView object to set the animation sequence of the object in the control.
///    %thisGuiObjectVew.setSeq(%indexVal);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setSeq (string guiobjectview, string indexOrName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setSeq'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,indexOrName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbindexOrName = null;
if (indexOrName != null)
     sbindexOrName = new StringBuilder(indexOrName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setSeq(sbguiobjectview, sbindexOrName);
}
/// <summary>
/// @brief Sets the skin to use on the model being displayed.
///    @param skinName Name of the skin to use.
///    @tsexample
///    // Define the skin we want to apply to the main model in the control
///    %skinName = \"disco_gideon\";
///    // Inform the GuiObjectView control to update the skin the to defined skin
///    %thisGuiObjectView.setSkin(%skinName);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiObjectView_setSkin (string guiobjectview, string skinName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiObjectView_setSkin'" + string.Format("\"{0}\" \"{1}\" ",guiobjectview,skinName));
StringBuilder sbguiobjectview = null;
if (guiobjectview != null)
     sbguiobjectview = new StringBuilder(guiobjectview, 1024);
StringBuilder sbskinName = null;
if (skinName != null)
     sbskinName = new StringBuilder(skinName, 1024);

SafeNativeMethods.mwle_fnGuiObjectView_setSkin(sbguiobjectview, sbskinName);
}
/// <summary>
/// Collapse or un-collapse the control.
///    @param collapse True to collapse the control, false to un-collapse it )
/// 
/// </summary>

public void fnGuiPaneControl_setCollapsed (string guipanecontrol, bool collapse)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPaneControl_setCollapsed'" + string.Format("\"{0}\" \"{1}\" ",guipanecontrol,collapse));
StringBuilder sbguipanecontrol = null;
if (guipanecontrol != null)
     sbguipanecontrol = new StringBuilder(guipanecontrol, 1024);

SafeNativeMethods.mwle_fnGuiPaneControl_setCollapsed(sbguipanecontrol, collapse);
}
/// <summary>
/// @brief Add a category to the list.
/// 
/// 				   Acts as a separator between entries, allowing for sub-lists
/// 
/// 				   @param text Name of the new category)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_addCategory (string guipopupmenuctrlex, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_addCategory'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,text));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_addCategory(sbguipopupmenuctrlex, sbtext);
}
/// <summary>
/// @brief Create a new scheme and add it to the list of choices for when a new text entry is added.
/// 				   @param id Numerical id associated with this scheme
/// 				   @param fontColor The base text font color. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.
/// 				   @param fontColorHL Color of text when being highlighted. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.
/// 				   @param fontColorSel Color of text when being selected. Formatted as \"Red Green Blue\", each a numerical between 0 and 255.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_addScheme (string guipopupmenuctrlex, int id, string fontColor, string fontColorHL, string fontColorSEL)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_addScheme'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guipopupmenuctrlex,id,fontColor,fontColorHL,fontColorSEL));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbfontColor = null;
if (fontColor != null)
     sbfontColor = new StringBuilder(fontColor, 1024);
StringBuilder sbfontColorHL = null;
if (fontColorHL != null)
     sbfontColorHL = new StringBuilder(fontColorHL, 1024);
StringBuilder sbfontColorSEL = null;
if (fontColorSEL != null)
     sbfontColorSEL = new StringBuilder(fontColorSEL, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_addScheme(sbguipopupmenuctrlex, id, sbfontColor, sbfontColorHL, sbfontColorSEL);
}
/// <summary>
/// @brief Clear the popup list.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_clear (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_clear'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_clear(sbguipopupmenuctrlex);
}
/// <summary>
/// @brief Manually force this control to collapse and close.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_forceClose (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_forceClose'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_forceClose(sbguipopupmenuctrlex);
}
/// <summary>
/// @brief Manually for the onAction function, which updates everything in this control.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_forceOnAction (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_forceOnAction'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_forceOnAction(sbguipopupmenuctrlex);
}
/// <summary>
/// @brief Get the current selection of the menu.
/// 				   @return Returns the ID of the currently selected entry)
/// 
/// </summary>

public int fnGuiPopUpMenuCtrlEx_getSelected (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_getSelected'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

return  SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_getSelected(sbguipopupmenuctrlex);
}
/// <summary>
/// @brief Get the.
/// 
/// 				   Detailed description
/// 
/// 				   @param param Description
/// 
/// 				   @tsexample
/// 				   // Comment
/// 				   code();
/// 				   @endtsexample
/// 
/// 				   @return Returns current text in string format)
/// 
/// </summary>

public string fnGuiPopUpMenuCtrlEx_getText (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_getText'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_getText(sbguipopupmenuctrlex, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the text of an entry based on an ID.
/// 				   @param id The ID assigned to the entry being queried
/// 				   @return String contained by the specified entry, NULL if empty or bad ID)
/// 
/// </summary>

public string fnGuiPopUpMenuCtrlEx_getTextById (string guipopupmenuctrlex, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_getTextById'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_getTextById(sbguipopupmenuctrlex, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Clears selection in the menu.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_setNoneSelected (string guipopupmenuctrlex, int param)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_setNoneSelected'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,param));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_setNoneSelected(sbguipopupmenuctrlex, param);
}
/// <summary>
/// @brief Set the current text to a specified value.
/// 				   @param text String containing new text to set)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_setText (string guipopupmenuctrlex, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_setText'" + string.Format("\"{0}\" \"{1}\" ",guipopupmenuctrlex,text));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_setText(sbguipopupmenuctrlex, sbtext);
}
/// <summary>
/// @brief Sort the list alphabetically.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_sort (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_sort'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_sort(sbguipopupmenuctrlex);
}
/// <summary>
/// @brief Sort the list by ID.)
/// 
/// </summary>

public void fnGuiPopUpMenuCtrlEx_sortID (string guipopupmenuctrlex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiPopUpMenuCtrlEx_sortID'" + string.Format("\"{0}\" ",guipopupmenuctrlex));
StringBuilder sbguipopupmenuctrlex = null;
if (guipopupmenuctrlex != null)
     sbguipopupmenuctrlex = new StringBuilder(guipopupmenuctrlex, 1024);

SafeNativeMethods.mwle_fnGuiPopUpMenuCtrlEx_sortID(sbguipopupmenuctrlex);
}
/// <summary>
/// Set the bitmap to use for rendering the progress bar.
///    @param filename ~Path to the bitmap file.
///    @note Directly assign to #bitmap rather than using this method.
///    @see GuiProgressBitmapCtrl::setBitmap )
/// 
/// </summary>

public void fnGuiProgressBitmapCtrl_setBitmap (string guiprogressbitmapctrl, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiProgressBitmapCtrl_setBitmap'" + string.Format("\"{0}\" \"{1}\" ",guiprogressbitmapctrl,filename));
StringBuilder sbguiprogressbitmapctrl = null;
if (guiprogressbitmapctrl != null)
     sbguiprogressbitmapctrl = new StringBuilder(guiprogressbitmapctrl, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnGuiProgressBitmapCtrl_setBitmap(sbguiprogressbitmapctrl, sbfilename);
}
/// <summary>
/// Collapse the rollout if it is currently expanded.  This will make the rollout's child control invisible.
///    @note The rollout will animate to collapsed state.  To instantly collapse without animation, use instantCollapse(). )
/// 
/// </summary>

public void fnGuiRolloutCtrl_collapse (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_collapse'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_collapse(sbguirolloutctrl);
}
/// <summary>
/// Expand the rollout if it is currently collapsed.  This will make the rollout's child control visible.
///    @note The rollout will animate to expanded state.  To instantly expand without animation, use instantExpand(). )
/// 
/// </summary>

public void fnGuiRolloutCtrl_expand (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_expand'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_expand(sbguirolloutctrl);
}
/// <summary>
/// Instantly collapse the rollout without animation.  To smoothly slide the rollout to collapsed state, use collapse(). )
/// 
/// </summary>

public void fnGuiRolloutCtrl_instantCollapse (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_instantCollapse'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_instantCollapse(sbguirolloutctrl);
}
/// <summary>
/// Instantly expand the rollout without animation.  To smoothly slide the rollout to expanded state, use expand(). )
/// 
/// </summary>

public void fnGuiRolloutCtrl_instantExpand (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_instantExpand'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_instantExpand(sbguirolloutctrl);
}
/// <summary>
/// Determine whether the rollout is currently expanded, i.e. whether the child control is visible.
///    @return True if the rollout is expanded, false if not. )
/// 
/// </summary>

public bool fnGuiRolloutCtrl_isExpanded (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_isExpanded'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiRolloutCtrl_isExpanded(sbguirolloutctrl)>=1;
}
/// <summary>
/// Resize the rollout to exactly fit around its child control.  This can be used to manually trigger a recomputation of 
///    the rollout size. )
/// 
/// </summary>

public void fnGuiRolloutCtrl_sizeToContents (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_sizeToContents'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_sizeToContents(sbguirolloutctrl);
}
/// <summary>
/// Toggle the current collapse state of the rollout.  If it is currently expanded, then collapse it.  If it 
///    is currently collapsed, then expand it. )
/// 
/// </summary>

public void fnGuiRolloutCtrl_toggleCollapse (string guirolloutctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_toggleCollapse'" + string.Format("\"{0}\" ",guirolloutctrl));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_toggleCollapse(sbguirolloutctrl);
}
/// <summary>
/// Toggle the current expansion state of the rollout  If it is currently expanded, then collapse it.  If it 
///    is currently collapsed, then expand it.
///    @param instant If true, the rollout will toggle its state without animation.  Otherwise, the rollout will 
///       smoothly slide into the opposite state. )
/// 
/// </summary>

public void fnGuiRolloutCtrl_toggleExpanded (string guirolloutctrl, bool instantly)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiRolloutCtrl_toggleExpanded'" + string.Format("\"{0}\" \"{1}\" ",guirolloutctrl,instantly));
StringBuilder sbguirolloutctrl = null;
if (guirolloutctrl != null)
     sbguirolloutctrl = new StringBuilder(guirolloutctrl, 1024);

SafeNativeMethods.mwle_fnGuiRolloutCtrl_toggleExpanded(sbguirolloutctrl, instantly);
}
/// <summary>
/// Refresh sizing and positioning of child controls. )
/// 
/// </summary>

public void fnGuiScrollCtrl_computeSizes (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_computeSizes'" + string.Format("\"{0}\" ",guiscrollctrl));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_computeSizes(sbguiscrollctrl);
}
/// <summary>
/// Get the current coordinates of the scrolled content.
///    @return The current position of the scrolled content. )
/// 
/// </summary>

public string fnGuiScrollCtrl_getScrollPosition (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_getScrollPosition'" + string.Format("\"{0}\" ",guiscrollctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_getScrollPosition(sbguiscrollctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the current X coordinate of the scrolled content.
///    @return The current X coordinate of the scrolled content. )
/// 
/// </summary>

public int fnGuiScrollCtrl_getScrollPositionX (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_getScrollPositionX'" + string.Format("\"{0}\" ",guiscrollctrl));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiScrollCtrl_getScrollPositionX(sbguiscrollctrl);
}
/// <summary>
/// Get the current Y coordinate of the scrolled content.
///    @return The current Y coordinate of the scrolled content. )
/// 
/// </summary>

public int fnGuiScrollCtrl_getScrollPositionY (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_getScrollPositionY'" + string.Format("\"{0}\" ",guiscrollctrl));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiScrollCtrl_getScrollPositionY(sbguiscrollctrl);
}
/// <summary>
/// Scroll all the way to the bottom of the vertical scrollbar and the left of the horizontal bar. )
/// 
/// </summary>

public void fnGuiScrollCtrl_scrollToBottom (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_scrollToBottom'" + string.Format("\"{0}\" ",guiscrollctrl));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_scrollToBottom(sbguiscrollctrl);
}
/// <summary>
/// Scroll the control so that the given child @a control is visible.
///    @param control A child control. )
/// 
/// </summary>

public void fnGuiScrollCtrl_scrollToObject (string guiscrollctrl, string control)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_scrollToObject'" + string.Format("\"{0}\" \"{1}\" ",guiscrollctrl,control));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);
StringBuilder sbcontrol = null;
if (control != null)
     sbcontrol = new StringBuilder(control, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_scrollToObject(sbguiscrollctrl, sbcontrol);
}
/// <summary>
/// Scroll all the way to the top of the vertical and left of the horizontal scrollbar. )
/// 
/// </summary>

public void fnGuiScrollCtrl_scrollToTop (string guiscrollctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_scrollToTop'" + string.Format("\"{0}\" ",guiscrollctrl));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_scrollToTop(sbguiscrollctrl);
}
/// <summary>
/// Set the position of the scrolled content.
///    @param x Position on X axis.
///    @param y Position on y axis. )
/// 
/// </summary>

public void fnGuiScrollCtrl_setScrollPosition (string guiscrollctrl, int x, int y)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiScrollCtrl_setScrollPosition'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guiscrollctrl,x,y));
StringBuilder sbguiscrollctrl = null;
if (guiscrollctrl != null)
     sbguiscrollctrl = new StringBuilder(guiscrollctrl, 1024);

SafeNativeMethods.mwle_fnGuiScrollCtrl_setScrollPosition(sbguiscrollctrl, x, y);
}
/// <summary>
/// Add a new thread (initially without any sequence set) )
/// 
/// </summary>

public void fnGuiShapeEdPreview_addThread (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_addThread'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_addThread(sbguishapeedpreview);
}
/// <summary>
/// Compute the bounding box of the shape using the current detail and node transforms
///    @return the bounding box \"min.x min.y min.z max.x max.y max.z\" )
/// 
/// </summary>

public string fnGuiShapeEdPreview_computeShapeBounds (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_computeShapeBounds'" + string.Format("\"{0}\" ",guishapeedpreview));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_computeShapeBounds(sbguishapeedpreview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Export the current shape and all mounted objects to COLLADA (.dae).
///    Note that animation is not exported, and all geometry is combined into a 
///    single mesh.
///    @param path Destination filename )
/// 
/// </summary>

public void fnGuiShapeEdPreview_exportToCollada (string guishapeedpreview, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_exportToCollada'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,path));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_exportToCollada(sbguishapeedpreview, sbpath);
}
/// <summary>
/// Adjust the camera position and zoom to fit the shape within the view. )
/// 
/// </summary>

public void fnGuiShapeEdPreview_fitToShape (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_fitToShape'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_fitToShape(sbguishapeedpreview);
}
/// <summary>
/// Return whether the named object is currently hidden )
/// 
/// </summary>

public bool fnGuiShapeEdPreview_getMeshHidden (string guishapeedpreview, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getMeshHidden'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,name));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_getMeshHidden(sbguishapeedpreview, sbname)>=1;
}
/// <summary>
/// Get the playback direction of the sequence playing on this mounted shape
///    @param slot mounted shape slot
///    @return direction of the sequence (-1=reverse, 0=paused, 1=forward) )
/// 
/// </summary>

public float fnGuiShapeEdPreview_getMountThreadDir (string guishapeedpreview, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getMountThreadDir'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,slot));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_getMountThreadDir(sbguishapeedpreview, slot);
}
/// <summary>
/// Get the playback position of the sequence playing on this mounted shape
///    @param slot mounted shape slot
///    @return playback position of the sequence (0-1) )
/// 
/// </summary>

public float fnGuiShapeEdPreview_getMountThreadPos (string guishapeedpreview, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getMountThreadPos'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,slot));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_getMountThreadPos(sbguishapeedpreview, slot);
}
/// <summary>
/// Get the name of the sequence playing on this mounted shape
///    @param slot mounted shape slot
///    @return name of the sequence (if any) )
/// 
/// </summary>

public string fnGuiShapeEdPreview_getMountThreadSequence (string guishapeedpreview, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getMountThreadSequence'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,slot));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_getMountThreadSequence(sbguishapeedpreview, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of threads
///    @return the number of threads )
/// 
/// </summary>

public int fnGuiShapeEdPreview_getThreadCount (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getThreadCount'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_getThreadCount(sbguishapeedpreview);
}
/// <summary>
/// Get the name of the sequence assigned to the active thread )
/// 
/// </summary>

public string fnGuiShapeEdPreview_getThreadSequence (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_getThreadSequence'" + string.Format("\"{0}\" ",guishapeedpreview));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_getThreadSequence(sbguishapeedpreview, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Mount a shape onto the main shape at the specified node
///    @param shapePath path to the shape to mount
///    @param nodeName name of the node on the main shape to mount to
///    @param type type of mounting to use (Object, Image or Wheel)
///    @param slot mount slot )
/// 
/// </summary>

public bool fnGuiShapeEdPreview_mountShape (string guishapeedpreview, string shapePath, string nodeName, string type, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_mountShape'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guishapeedpreview,shapePath,nodeName,type,slot));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbshapePath = null;
if (shapePath != null)
     sbshapePath = new StringBuilder(shapePath, 1024);
StringBuilder sbnodeName = null;
if (nodeName != null)
     sbnodeName = new StringBuilder(nodeName, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_mountShape(sbguishapeedpreview, sbshapePath, sbnodeName, sbtype, slot)>=1;
}
/// <summary>
/// Refresh the shape (used when the shape meshes or nodes have been added or removed) )
/// 
/// </summary>

public void fnGuiShapeEdPreview_refreshShape (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_refreshShape'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_refreshShape(sbguishapeedpreview);
}
/// <summary>
/// Refreshes thread sequences (in case of removed/renamed sequences )
/// 
/// </summary>

public void fnGuiShapeEdPreview_refreshThreadSequences (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_refreshThreadSequences'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_refreshThreadSequences(sbguishapeedpreview);
}
/// <summary>
/// Removes the specifed thread
///    @param slot index of the thread to remove )
/// 
/// </summary>

public void fnGuiShapeEdPreview_removeThread (string guishapeedpreview, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_removeThread'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,slot));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_removeThread(sbguishapeedpreview, slot);
}
/// <summary>
/// Show or hide all objects in the shape )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setAllMeshesHidden (string guishapeedpreview, bool hidden)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setAllMeshesHidden'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,hidden));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setAllMeshesHidden(sbguishapeedpreview, hidden);
}
/// <summary>
/// Show or hide the named object in the shape )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setMeshHidden (string guishapeedpreview, string name, bool hidden)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setMeshHidden'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guishapeedpreview,name,hidden));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setMeshHidden(sbguishapeedpreview, sbname, hidden);
}
/// <summary>
/// Sets the model to be displayed in this control
///    @param shapeName Name of the model to display.
///    @return True if the model was loaded successfully, false otherwise. )
/// 
/// </summary>

public bool fnGuiShapeEdPreview_setModel (string guishapeedpreview, string shapePath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setModel'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,shapePath));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbshapePath = null;
if (shapePath != null)
     sbshapePath = new StringBuilder(shapePath, 1024);

return  SafeNativeMethods.mwle_fnGuiShapeEdPreview_setModel(sbguishapeedpreview, sbshapePath)>=1;
}
/// <summary>
/// Set the node a shape is mounted to.
///    @param slot mounted shape slot
///    @param nodename name of the node to mount to )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setMountNode (string guishapeedpreview, int slot, string nodeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setMountNode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guishapeedpreview,slot,nodeName));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbnodeName = null;
if (nodeName != null)
     sbnodeName = new StringBuilder(nodeName, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setMountNode(sbguishapeedpreview, slot, sbnodeName);
}
/// <summary>
/// Set the playback direction of the shape mounted in the specified slot
///    @param slot mounted shape slot
///    @param dir playback direction (-1=backwards, 0=paused, 1=forwards) )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setMountThreadDir (string guishapeedpreview, int slot, float dir)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setMountThreadDir'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guishapeedpreview,slot,dir));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setMountThreadDir(sbguishapeedpreview, slot, dir);
}
/// <summary>
/// Set the sequence position of the shape mounted in the specified slot
///    @param slot mounted shape slot
///    @param pos sequence position (0-1) )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setMountThreadPos (string guishapeedpreview, int slot, float pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setMountThreadPos'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guishapeedpreview,slot,pos));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setMountThreadPos(sbguishapeedpreview, slot, pos);
}
/// <summary>
/// Set the sequence to play for the shape mounted in the specified slot
///    @param slot mounted shape slot
///    @param name name of the sequence to play )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setMountThreadSequence (string guishapeedpreview, int slot, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setMountThreadSequence'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guishapeedpreview,slot,name));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setMountThreadSequence(sbguishapeedpreview, slot, sbname);
}
/// <summary>
/// Set the camera orbit position
///    @param pos Position in the form \"x y z\" )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setOrbitPos (string guishapeedpreview, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setOrbitPos'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,pos));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setOrbitPos(sbguishapeedpreview, sbpos);
}
/// <summary>
/// Sets the sequence to play for the active thread.
///    @param name name of the sequence to play
///    @param duration transition duration (0 for no transition)
///    @param pos position in the new sequence to transition to
///    @param play if true, the new sequence will play during the transition )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setThreadSequence (string guishapeedpreview, string name, float duration, float pos, bool play)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setThreadSequence'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",guishapeedpreview,name,duration,pos,play));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setThreadSequence(sbguishapeedpreview, sbname, duration, pos, play);
}
/// <summary>
/// Set the time scale of all threads
///    @param scale new time scale value )
/// 
/// </summary>

public void fnGuiShapeEdPreview_setTimeScale (string guishapeedpreview, float scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_setTimeScale'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,scale));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_setTimeScale(sbguishapeedpreview, scale);
}
/// <summary>
/// Unmount all shapes )
/// 
/// </summary>

public void fnGuiShapeEdPreview_unmountAll (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_unmountAll'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_unmountAll(sbguishapeedpreview);
}
/// <summary>
/// Unmount the shape in the specified slot
///    @param slot mounted shape slot )
/// 
/// </summary>

public void fnGuiShapeEdPreview_unmountShape (string guishapeedpreview, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_unmountShape'" + string.Format("\"{0}\" \"{1}\" ",guishapeedpreview,slot));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_unmountShape(sbguishapeedpreview, slot);
}
/// <summary>
/// Refresh the shape node transforms (used when a node transform has been modified externally) )
/// 
/// </summary>

public void fnGuiShapeEdPreview_updateNodeTransforms (string guishapeedpreview)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiShapeEdPreview_updateNodeTransforms'" + string.Format("\"{0}\" ",guishapeedpreview));
StringBuilder sbguishapeedpreview = null;
if (guishapeedpreview != null)
     sbguishapeedpreview = new StringBuilder(guishapeedpreview, 1024);

SafeNativeMethods.mwle_fnGuiShapeEdPreview_updateNodeTransforms(sbguishapeedpreview);
}
/// <summary>
/// Get the current value of the slider based on the position of the thumb.
///    @return Slider position (from range.x to range.y). )
/// 
/// </summary>

public float fnGuiSliderCtrl_getValue (string guisliderctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiSliderCtrl_getValue'" + string.Format("\"{0}\" ",guisliderctrl));
StringBuilder sbguisliderctrl = null;
if (guisliderctrl != null)
     sbguisliderctrl = new StringBuilder(guisliderctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiSliderCtrl_getValue(sbguisliderctrl);
}
/// <summary>
/// Returns true if the thumb is currently being dragged by the user.  This method is mainly useful 
///    for scrubbing type sliders where the slider position is sync'd to a changing value.  When the 
///    user is dragging the thumb, however, the sync'ing should pause and not get in the way of the user. )
/// 
/// </summary>

public bool fnGuiSliderCtrl_isThumbBeingDragged (string guisliderctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiSliderCtrl_isThumbBeingDragged'" + string.Format("\"{0}\" ",guisliderctrl));
StringBuilder sbguisliderctrl = null;
if (guisliderctrl != null)
     sbguisliderctrl = new StringBuilder(guisliderctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiSliderCtrl_isThumbBeingDragged(sbguisliderctrl)>=1;
}
/// <summary>
/// Set position of the thumb on the slider.
///    @param pos New slider position (from range.x to range.y)
///    @param doCallback If true, the altCommand callback will be invoked )
/// 
/// </summary>

public void fnGuiSliderCtrl_setValue (string guisliderctrl, float pos, bool doCallback)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiSliderCtrl_setValue'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guisliderctrl,pos,doCallback));
StringBuilder sbguisliderctrl = null;
if (guisliderctrl != null)
     sbguisliderctrl = new StringBuilder(guisliderctrl, 1024);

SafeNativeMethods.mwle_fnGuiSliderCtrl_setValue(sbguisliderctrl, pos, doCallback);
}
/// <summary>
/// Prevents control from restacking - useful when adding or removing child controls
///    @param freeze True to freeze the control, false to unfreeze it
///    @tsexample
///    %stackCtrl.freeze(true);
///    // add controls to stack
///    %stackCtrl.freeze(false);
///    @endtsexample )
/// 
/// </summary>

public void fnGuiStackControl_freeze (string guistackcontrol, bool freeze)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiStackControl_freeze'" + string.Format("\"{0}\" \"{1}\" ",guistackcontrol,freeze));
StringBuilder sbguistackcontrol = null;
if (guistackcontrol != null)
     sbguistackcontrol = new StringBuilder(guistackcontrol, 1024);

SafeNativeMethods.mwle_fnGuiStackControl_freeze(sbguistackcontrol, freeze);
}
/// <summary>
/// Return whether or not this control is frozen )
/// 
/// </summary>

public bool fnGuiStackControl_isFrozen (string guistackcontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiStackControl_isFrozen'" + string.Format("\"{0}\" ",guistackcontrol));
StringBuilder sbguistackcontrol = null;
if (guistackcontrol != null)
     sbguistackcontrol = new StringBuilder(guistackcontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiStackControl_isFrozen(sbguistackcontrol)>=1;
}
/// <summary>
/// Restack the child controls. )
/// 
/// </summary>

public void fnGuiStackControl_updateStack (string guistackcontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiStackControl_updateStack'" + string.Format("\"{0}\" ",guistackcontrol));
StringBuilder sbguistackcontrol = null;
if (guistackcontrol != null)
     sbguistackcontrol = new StringBuilder(guistackcontrol, 1024);

SafeNativeMethods.mwle_fnGuiStackControl_updateStack(sbguistackcontrol);
}
/// <summary>
/// Set the color of the swatch control.
///    @param newColor The new color string given to the swatch control in float format \"r g b a\".
///    @note It's also important to note that when setColor is called causes
///    the control's altCommand field to be executed. )
/// 
/// </summary>

public void fnGuiSwatchButtonCtrl_setColor (string guiswatchbuttonctrl, string newColor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiSwatchButtonCtrl_setColor'" + string.Format("\"{0}\" \"{1}\" ",guiswatchbuttonctrl,newColor));
StringBuilder sbguiswatchbuttonctrl = null;
if (guiswatchbuttonctrl != null)
     sbguiswatchbuttonctrl = new StringBuilder(guiswatchbuttonctrl, 1024);
StringBuilder sbnewColor = null;
if (newColor != null)
     sbnewColor = new StringBuilder(newColor, 1024);

SafeNativeMethods.mwle_fnGuiSwatchButtonCtrl_setColor(sbguiswatchbuttonctrl, sbnewColor);
}
/// <summary>
///  ),
///    Add a new tab page to the control.
///    @param title Title text for the tab page header. )
/// 
/// </summary>

public void fnGuiTabBookCtrl_addPage (string guitabbookctrl, string title)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTabBookCtrl_addPage'" + string.Format("\"{0}\" \"{1}\" ",guitabbookctrl,title));
StringBuilder sbguitabbookctrl = null;
if (guitabbookctrl != null)
     sbguitabbookctrl = new StringBuilder(guitabbookctrl, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);

SafeNativeMethods.mwle_fnGuiTabBookCtrl_addPage(sbguitabbookctrl, sbtitle);
}
/// <summary>
/// Get the index of the currently selected tab page.
///    @return Index of the selected tab page or -1 if no tab page is selected. )
/// 
/// </summary>

public int fnGuiTabBookCtrl_getSelectedPage (string guitabbookctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTabBookCtrl_getSelectedPage'" + string.Format("\"{0}\" ",guitabbookctrl));
StringBuilder sbguitabbookctrl = null;
if (guitabbookctrl != null)
     sbguitabbookctrl = new StringBuilder(guitabbookctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTabBookCtrl_getSelectedPage(sbguitabbookctrl);
}
/// <summary>
/// Set the selected tab page.
///    @param index Index of the tab page. )
/// 
/// </summary>

public void fnGuiTabBookCtrl_selectPage (string guitabbookctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTabBookCtrl_selectPage'" + string.Format("\"{0}\" \"{1}\" ",guitabbookctrl,index));
StringBuilder sbguitabbookctrl = null;
if (guitabbookctrl != null)
     sbguitabbookctrl = new StringBuilder(guitabbookctrl, 1024);

SafeNativeMethods.mwle_fnGuiTabBookCtrl_selectPage(sbguitabbookctrl, index);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnGuiTableControl_addChildRow (string guitablecontrol, string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_addChildRow'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitablecontrol,text,index));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiTableControl_addChildRow(sbguitablecontrol, sbtext, index);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnGuiTableControl_addHeading (string guitablecontrol, string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_addHeading'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitablecontrol,text,index));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiTableControl_addHeading(sbguitablecontrol, sbtext, index);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnGuiTableControl_clearChildren (string guitablecontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_clearChildren'" + string.Format("\"{0}\" ",guitablecontrol));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);

SafeNativeMethods.mwle_fnGuiTableControl_clearChildren(sbguitablecontrol);
}
/// <summary>
/// )
/// 
/// </summary>

public int fnGuiTableControl_findColumnTextIndex (string guitablecontrol, int columnId, string columnText)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_findColumnTextIndex'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitablecontrol,columnId,columnText));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);
StringBuilder sbcolumnText = null;
if (columnText != null)
     sbcolumnText = new StringBuilder(columnText, 1024);

return  SafeNativeMethods.mwle_fnGuiTableControl_findColumnTextIndex(sbguitablecontrol, columnId, sbcolumnText);
}
/// <summary>
/// @brief Returns the selected row index (not the row ID).
///    @tsexample
///    // Acquire the selected row index
///    %rowIndex = %thisGuiTextListCtrl.getSelectedRow();
///    @endtsexample
///    @return Index of the selected row
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTableControl_getSelectedRow (string guitablecontrol)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_getSelectedRow'" + string.Format("\"{0}\" ",guitablecontrol));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);

return  SafeNativeMethods.mwle_fnGuiTableControl_getSelectedRow(sbguitablecontrol);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnGuiTableControl_setColumnSort (string guitablecontrol, int column, bool ascending)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_setColumnSort'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitablecontrol,column,ascending));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);

SafeNativeMethods.mwle_fnGuiTableControl_setColumnSort(sbguitablecontrol, column, ascending);
}
/// <summary>
/// @briefSelects the specified row.
///    @param rowNum Row number to set selected.
///    @tsexample
///    // Define the row number to set selected
///    %rowNum = \"4\";
///    %guiTextListCtrl.setSelectedRow(%rowNum);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTableControl_setSelectedRow (string guitablecontrol, int rowNum)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTableControl_setSelectedRow'" + string.Format("\"{0}\" \"{1}\" ",guitablecontrol,rowNum));
StringBuilder sbguitablecontrol = null;
if (guitablecontrol != null)
     sbguitablecontrol = new StringBuilder(guitablecontrol, 1024);

SafeNativeMethods.mwle_fnGuiTableControl_setSelectedRow(sbguitablecontrol, rowNum);
}
/// <summary>
/// Select this page in its tab book. )
/// 
/// </summary>

public void fnGuiTabPageCtrl_select (string guitabpagectrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTabPageCtrl_select'" + string.Format("\"{0}\" ",guitabpagectrl));
StringBuilder sbguitabpagectrl = null;
if (guitabpagectrl != null)
     sbguitabpagectrl = new StringBuilder(guitabpagectrl, 1024);

SafeNativeMethods.mwle_fnGuiTabPageCtrl_select(sbguitabpagectrl);
}
/// <summary>
/// @brief Sets the text in the control.
///    @param text Text to display in the control.
///    @tsexample
///    // Set the text to show in the control
///    %text = \"Gideon - Destroyer of World\";
///    // Inform the GuiTextCtrl control to change its text to the defined value
///    %thisGuiTextCtrl.setText(%text);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextCtrl_setText (string guitextctrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextCtrl_setText'" + string.Format("\"{0}\" \"{1}\" ",guitextctrl,text));
StringBuilder sbguitextctrl = null;
if (guitextctrl != null)
     sbguitextctrl = new StringBuilder(guitextctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiTextCtrl_setText(sbguitextctrl, sbtext);
}
/// <summary>
/// @brief Maps the text ctrl to a variable used in localization, rather than raw text.
///    @param textID Name of variable text should be mapped to
///    @tsexample
///    // Inform the GuiTextCtrl control of the textID to use
///    %thisGuiTextCtrl.setTextID(\"STR_QUIT\");
///    @endtsexample
///    @see GuiControl
///    @see Localization)
/// 
/// </summary>

public void fnGuiTextCtrl_setTextID (string guitextctrl, string textID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextCtrl_setTextID'" + string.Format("\"{0}\" \"{1}\" ",guitextctrl,textID));
StringBuilder sbguitextctrl = null;
if (guitextctrl != null)
     sbguitextctrl = new StringBuilder(guitextctrl, 1024);
StringBuilder sbtextID = null;
if (textID != null)
     sbtextID = new StringBuilder(textID, 1024);

SafeNativeMethods.mwle_fnGuiTextCtrl_setTextID(sbguitextctrl, sbtextID);
}
/// <summary>
/// @brief Unselects all selected text in the control.
///    @tsexample
///    // Inform the control to unselect all of its selected text
///    %thisGuiTextEditCtrl.clearSelectedText();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextEditCtrl_clearSelectedText (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_clearSelectedText'" + string.Format("\"{0}\" ",guitexteditctrl));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_clearSelectedText(sbguitexteditctrl);
}
/// <summary>
/// @brief Force a validation to occur.
///    @tsexample
///    // Inform the control to force a validation of its text.
///    %thisGuiTextEditCtrl.forceValidateText();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextEditCtrl_forceValidateText (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_forceValidateText'" + string.Format("\"{0}\" ",guitexteditctrl));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_forceValidateText(sbguitexteditctrl);
}
/// <summary>
/// @brief Returns the current position of the text cursor in the control.
///    @tsexample
///    // Acquire the cursor position in the control
///    %position = %thisGuiTextEditCtrl.getCursorPost();
///    @endtsexample
///    @return Text cursor position within the control.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextEditCtrl_getCursorPos (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_getCursorPos'" + string.Format("\"{0}\" ",guitexteditctrl));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextEditCtrl_getCursorPos(sbguitexteditctrl);
}
/// <summary>
/// @brief Acquires the current text displayed in this control.
///    @tsexample
///    // Acquire the value of the text control.
///    %text = %thisGuiTextEditCtrl.getText();
///    @endtsexample
///    @return The current text within the control.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiTextEditCtrl_getText (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_getText'" + string.Format("\"{0}\" ",guitexteditctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_getText(sbguitexteditctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Checks to see if all text in the control has been selected.
///    @tsexample
///    // Check to see if all text has been selected or not.
///    %allSelected = %thisGuiTextEditCtrl.isAllTextSelected();
///    @endtsexample
///    @return True if all text in the control is selected, otherwise false.
///    @see GuiControl)
/// 
/// </summary>

public bool fnGuiTextEditCtrl_isAllTextSelected (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_isAllTextSelected'" + string.Format("\"{0}\" ",guitexteditctrl));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextEditCtrl_isAllTextSelected(sbguitexteditctrl)>=1;
}
/// <summary>
/// @brief Selects all text within the control.
///    @tsexample
///    // Inform the control to select all of its text.
///    %thisGuiTextEditCtrl.selectAllText();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextEditCtrl_selectAllText (string guitexteditctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_selectAllText'" + string.Format("\"{0}\" ",guitexteditctrl));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_selectAllText(sbguitexteditctrl);
}
/// <summary>
/// @brief Sets the text cursor at the defined position within the control.
///    @param position Text position to set the text cursor.
///    @tsexample
///    // Define the cursor position
///    %position = \"12\";
///    // Inform the GuiTextEditCtrl control to place the text cursor at the defined position
///    %thisGuiTextEditCtrl.setCursorPos(%position);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextEditCtrl_setCursorPos (string guitexteditctrl, int position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_setCursorPos'" + string.Format("\"{0}\" \"{1}\" ",guitexteditctrl,position));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_setCursorPos(sbguitexteditctrl, position);
}
/// <summary>
/// @brief Sets the text in the control.
///    @param text Text to place in the control.
///    @tsexample
///    // Define the text to display
///    %text = \"Text!\"
///    // Inform the GuiTextEditCtrl to display the defined text
///    %thisGuiTextEditCtrl.setText(%text);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextEditCtrl_setText (string guitexteditctrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextEditCtrl_setText'" + string.Format("\"{0}\" \"{1}\" ",guitexteditctrl,text));
StringBuilder sbguitexteditctrl = null;
if (guitexteditctrl != null)
     sbguitexteditctrl = new StringBuilder(guitexteditctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiTextEditCtrl_setText(sbguitexteditctrl, sbtext);
}
/// <summary>
/// ,-1),
///    @brief Adds a new row at end of the list with the defined id and text.
///    If index is used, then the new row is inserted at the row location of 'index'.
///    @param id Id of the new row.
///    @param text Text to display at the new row.
///    @param index Index to insert the new row at. If not used, new row will be placed at the end of the list.
///    @tsexample
///    // Define the id
///    %id = \"4\";
///    // Define the text to display
///    %text = \"Display Text\"
///    // Define the index (optional)
///    %index = \"2\"
///    // Inform the GuiTextListCtrl control to add the new row with the defined information.
///    %rowIndex = %thisGuiTextListCtrl.addRow(%id,%text,%index);
///    @endtsexample
///    @return Returns the row index of the new row. If 'index' was defined, then this just returns the number of rows in the list.
///    @see References)
/// 
/// </summary>

public int fnGuiTextListCtrl_addRow (string guitextlistctrl, int id, string text, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_addRow'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guitextlistctrl,id,text,index));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_addRow(sbguitextlistctrl, id, sbtext, index);
}
/// <summary>
/// @brief Clear the list.
///    @tsexample
///    // Inform the GuiTextListCtrl control to clear its contents
///    %thisGuiTextListCtrl.clear();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_clear (string guitextlistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_clear'" + string.Format("\"{0}\" ",guitextlistctrl));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_clear(sbguitextlistctrl);
}
/// <summary>
/// @brief Set the selection to nothing.
///    @tsexample
///    // Deselect anything that is currently selected
///    %thisGuiTextListCtrl.clearSelection();
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_clearSelection (string guitextlistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_clearSelection'" + string.Format("\"{0}\" ",guitextlistctrl));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_clearSelection(sbguitextlistctrl);
}
/// <summary>
/// )
/// 
/// </summary>

public int fnGuiTextListCtrl_findColumnTextIndex (string guitextlistctrl, int columnId, string columnText)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_findColumnTextIndex'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitextlistctrl,columnId,columnText));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);
StringBuilder sbcolumnText = null;
if (columnText != null)
     sbcolumnText = new StringBuilder(columnText, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_findColumnTextIndex(sbguitextlistctrl, columnId, sbcolumnText);
}
/// <summary>
/// @brief Find needle in the list, and return the row number it was found in.
///    @param needle Text to find in the list.
///    @tsexample
///    // Define the text to find in the list
///    %needle = \"Text To Find\";
///    // Request the row number that contains the defined text to find
///    %rowNumber = %thisGuiTextListCtrl.findTextIndex(%needle);
///    @endtsexample
///    @return Row number that the defined text was found in,
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_findTextIndex (string guitextlistctrl, string needle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_findTextIndex'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,needle));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);
StringBuilder sbneedle = null;
if (needle != null)
     sbneedle = new StringBuilder(needle, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_findTextIndex(sbguitextlistctrl, sbneedle);
}
/// <summary>
/// @brief Get the row ID for an index.
///    @param index Index to get the RowID at
///    @tsexample
///    // Define the index
///    %index = \"3\";
///    // Request the row ID at the defined index
///    %rowId = %thisGuiTextListCtrl.getRowId(%index);
///    @endtsexample
///    @return RowId at the defined index.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_getRowId (string guitextlistctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getRowId'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,index));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_getRowId(sbguitextlistctrl, index);
}
/// <summary>
/// @brief Get the row number for a specified id.
///    @param id Id to get the row number at
///    @tsexample
///    // Define the id
///    %id = \"4\";
///    // Request the row number from the GuiTextListCtrl control at the defined id.
///    %rowNumber = %thisGuiTextListCtrl.getRowNumById(%id);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_getRowNumById (string guitextlistctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getRowNumById'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,id));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_getRowNumById(sbguitextlistctrl, id);
}
/// <summary>
/// @brief Get the text of the row with the specified index.
///    @param index Row index to acquire the text at.
///    @tsexample
///    // Define the row index
///    %index = \"5\";
///    // Request the text from the row at the defined index
///    %rowText = %thisGuiTextListCtrl.getRowText(%index);
///    @endtsexample
///    @return Text at the defined row index.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiTextListCtrl_getRowText (string guitextlistctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getRowText'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_getRowText(sbguitextlistctrl, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the text of a row with the specified id.
///    @tsexample
///    // Define the id
///    %id = \"4\";
///    // Inform the GuiTextListCtrl control to return the text at the defined row id
///    %rowText = %thisGuiTextListCtrl.getRowTextById(%id);
///    @endtsexample
///    @return Row text at the requested row id.
///    @see GuiControl)
/// 
/// </summary>

public string fnGuiTextListCtrl_getRowTextById (string guitextlistctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getRowTextById'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,id));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_getRowTextById(sbguitextlistctrl, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the ID of the currently selected item.
///    @tsexample
///    // Acquire the ID of the selected item in the list.
///    %id = %thisGuiTextListCtrl.getSelectedId();
///    @endtsexample
///    @return The id of the selected item in the list.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_getSelectedId (string guitextlistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getSelectedId'" + string.Format("\"{0}\" ",guitextlistctrl));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_getSelectedId(sbguitextlistctrl);
}
/// <summary>
/// @brief Returns the selected row index (not the row ID).
///    @tsexample
///    // Acquire the selected row index
///    %rowIndex = %thisGuiTextListCtrl.getSelectedRow();
///    @endtsexample
///    @return Index of the selected row
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_getSelectedRow (string guitextlistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_getSelectedRow'" + string.Format("\"{0}\" ",guitextlistctrl));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_getSelectedRow(sbguitextlistctrl);
}
/// <summary>
/// @brief Check if the specified row is currently active or not.
///    @param rowNum Row number to check the active state.
///    @tsexample
///    // Define the row number
///    %rowNum = \"5\";
///    // Request the active state of the defined row number from the GuiTextListCtrl control.
///    %rowActiveState = %thisGuiTextListCtrl.isRowActive(%rowNum);
///    @endtsexample
///    @return Active state of the defined row number.
///    @see GuiControl)
/// 
/// </summary>

public bool fnGuiTextListCtrl_isRowActive (string guitextlistctrl, int rowNum)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_isRowActive'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,rowNum));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_isRowActive(sbguitextlistctrl, rowNum)>=1;
}
/// <summary>
/// @brief Remove a row from the table, based on its index.
///    @param index Row index to remove from the list.
///    @tsexample
///    // Define the row index
///    %index = \"4\";
///    // Inform the GuiTextListCtrl control to remove the row at the defined row index
///    %thisGuiTextListCtrl.removeRow(%index);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_removeRow (string guitextlistctrl, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_removeRow'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,index));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_removeRow(sbguitextlistctrl, index);
}
/// <summary>
/// @brief Remove row with the specified id.
///    @param id Id to remove the row entry at
///    @tsexample
///    // Define the id
///    %id = \"4\";
///    // Inform the GuiTextListCtrl control to remove the row at the defined id
///    %thisGuiTextListCtrl.removeRowById(%id);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_removeRowById (string guitextlistctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_removeRowById'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,id));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_removeRowById(sbguitextlistctrl, id);
}
/// <summary>
/// @brief Get the number of rows.
///    @tsexample
///    // Get the number of rows in the list
///    %rowCount = %thisGuiTextListCtrl.rowCount();
///    @endtsexample
///    @return Number of rows in the list.
///    @see GuiControl)
/// 
/// </summary>

public int fnGuiTextListCtrl_rowCount (string guitextlistctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_rowCount'" + string.Format("\"{0}\" ",guitextlistctrl));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTextListCtrl_rowCount(sbguitextlistctrl);
}
/// <summary>
/// @brief Scroll so the specified row is visible
///    @param rowNum Row number to make visible
///    @tsexample
///    // Define the row number to make visible
///    %rowNum = \"4\";
///    // Inform the GuiTextListCtrl control to scroll the list so the defined rowNum is visible.
///    %thisGuiTextListCtrl.scrollVisible(%rowNum);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_scrollVisible (string guitextlistctrl, int rowNum)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_scrollVisible'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,rowNum));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_scrollVisible(sbguitextlistctrl, rowNum);
}
/// <summary>
/// @brief Mark a specified row as active/not.
///    @param rowNum Row number to change the active state.
///    @param active Boolean active state to set the row number.
///    @tsexample
///    // Define the row number
///    %rowNum = \"4\";
///    // Define the boolean active state
///    %active = \"true\";
///    // Informthe GuiTextListCtrl control to set the defined active state at the defined row number.
///    %thisGuiTextListCtrl.setRowActive(%rowNum,%active);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_setRowActive (string guitextlistctrl, int rowNum, bool active)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_setRowActive'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitextlistctrl,rowNum,active));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_setRowActive(sbguitextlistctrl, rowNum, active);
}
/// <summary>
/// @brief Sets the text at the defined id.
///    @param id Id to change.
///    @param text Text to use at the Id.
///    @tsexample
///    // Define the id
///    %id = \"4\";
///    // Define the text
///    %text = \"Text To Display\";
///    // Inform the GuiTextListCtrl control to display the defined text at the defined id
///    %thisGuiTextListCtrl.setRowById(%id,%text);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_setRowById (string guitextlistctrl, int id, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_setRowById'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitextlistctrl,id,text));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_setRowById(sbguitextlistctrl, id, sbtext);
}
/// <summary>
/// @brief Finds the specified entry by id, then marks its row as selected.
///    @param id Entry within the text list to make selected.
///    @tsexample
///    // Define the id
///    %id = \"5\";
///    // Inform the GuiTextListCtrl control to set the defined id entry as selected
///    %thisGuiTextListCtrl.setSelectedById(%id);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_setSelectedById (string guitextlistctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_setSelectedById'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,id));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_setSelectedById(sbguitextlistctrl, id);
}
/// <summary>
/// @briefSelects the specified row.
///    @param rowNum Row number to set selected.
///    @tsexample
///    // Define the row number to set selected
///    %rowNum = \"4\";
///    %guiTextListCtrl.setSelectedRow(%rowNum);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_setSelectedRow (string guitextlistctrl, int rowNum)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_setSelectedRow'" + string.Format("\"{0}\" \"{1}\" ",guitextlistctrl,rowNum));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_setSelectedRow(sbguitextlistctrl, rowNum);
}
/// <summary>
/// @brief Performs a standard (alphabetical) sort on the values in the specified column.
///    @param columnId Column ID to perform the sort on.
///    @param increasing If false, sort will be performed in reverse.
///    @tsexample
///    // Define the columnId
///    %id = \"1\";
///    // Define if we are increasing or not
///    %increasing = \"false\";
///    // Inform the GuiTextListCtrl to perform the sort operation
///    %thisGuiTextListCtrl.sort(%id,%increasing);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_sort (string guitextlistctrl, int columnId, bool increasing)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_sort'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitextlistctrl,columnId,increasing));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_sort(sbguitextlistctrl, columnId, increasing);
}
/// <summary>
/// @brief Perform a numerical sort on the values in the specified column.
///    Detailed description
///    @param columnId Column ID to perform the sort on.
///    @param increasing If false, sort will be performed in reverse.
///    @tsexample
///    // Define the columnId
///    %id = \"1\";
///    // Define if we are increasing or not
///    %increasing = \"false\";
///    // Inform the GuiTextListCtrl to perform the sort operation
///    %thisGuiTextListCtrl.sortNumerical(%id,%increasing);
///    @endtsexample
///    @see GuiControl)
/// 
/// </summary>

public void fnGuiTextListCtrl_sortNumerical (string guitextlistctrl, int columnID, bool increasing)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTextListCtrl_sortNumerical'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitextlistctrl,columnID,increasing));
StringBuilder sbguitextlistctrl = null;
if (guitextlistctrl != null)
     sbguitextlistctrl = new StringBuilder(guitextlistctrl, 1024);

SafeNativeMethods.mwle_fnGuiTextListCtrl_sortNumerical(sbguitextlistctrl, columnID, increasing);
}
/// <summary>
/// Get the current playback time.
///    @return The elapsed playback time in seconds. )
/// 
/// </summary>

public float fnGuiTheoraCtrl_getCurrentTime (string guitheoractrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_getCurrentTime'" + string.Format("\"{0}\" ",guitheoractrl));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTheoraCtrl_getCurrentTime(sbguitheoractrl);
}
/// <summary>
/// Test whether the video has finished playing.
///    @return True if the video has finished playing, false otherwise. )
/// 
/// </summary>

public bool fnGuiTheoraCtrl_isPlaybackDone (string guitheoractrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_isPlaybackDone'" + string.Format("\"{0}\" ",guitheoractrl));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTheoraCtrl_isPlaybackDone(sbguitheoractrl)>=1;
}
/// <summary>
/// Pause playback of the video.  If the video is not currently playing, the call is ignored.
///    While stopped, the control displays the last frame. )
/// 
/// </summary>

public void fnGuiTheoraCtrl_pause (string guitheoractrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_pause'" + string.Format("\"{0}\" ",guitheoractrl));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);

SafeNativeMethods.mwle_fnGuiTheoraCtrl_pause(sbguitheoractrl);
}
/// <summary>
/// Start playing the video.  If the video is already playing, the call is ignored. )
/// 
/// </summary>

public void fnGuiTheoraCtrl_play (string guitheoractrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_play'" + string.Format("\"{0}\" ",guitheoractrl));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);

SafeNativeMethods.mwle_fnGuiTheoraCtrl_play(sbguitheoractrl);
}
/// <summary>
/// Set the video file to play.  If a video is already playing, playback is stopped and 
///    the new video file is loaded.
///    @param filename The video file to load. )
/// 
/// </summary>

public void fnGuiTheoraCtrl_setFile (string guitheoractrl, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_setFile'" + string.Format("\"{0}\" \"{1}\" ",guitheoractrl,filename));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnGuiTheoraCtrl_setFile(sbguitheoractrl, sbfilename);
}
/// <summary>
/// Stop playback of the video.  The next call to play() will then start playback from the beginning of the video.
///    While stopped, the control renders empty with just the background color. )
/// 
/// </summary>

public void fnGuiTheoraCtrl_stop (string guitheoractrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTheoraCtrl_stop'" + string.Format("\"{0}\" ",guitheoractrl));
StringBuilder sbguitheoractrl = null;
if (guitheoractrl != null)
     sbguitheoractrl = new StringBuilder(guitheoractrl, 1024);

SafeNativeMethods.mwle_fnGuiTheoraCtrl_stop(sbguitheoractrl);
}
/// <summary>
/// Add an item/object to the current selection.
///    @param id ID of item/object to add to the selection.
///    @param isLastSelection Whether there are more pending items/objects to be added to the selection.  If false, 
///       the control will defer refreshing the tree and wait until addSelection() is called with this parameter set 
///       to true. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_addSelection (string guitreeviewctrl, int id, bool isLastSelection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_addSelection'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,id,isLastSelection));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_addSelection(sbguitreeviewctrl, id, isLastSelection);
}
/// <summary>
/// Clear the current item filtering pattern.
///    @see setFilterText
///    @see getFilterText )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_clearFilterText (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_clearFilterText'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_clearFilterText(sbguitreeviewctrl);
}
/// <summary>
/// Unselect all currently selected items. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_clearSelection (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_clearSelection'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_clearSelection(sbguitreeviewctrl);
}
/// <summary>
/// Delete all items/objects in the current selection. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_deleteSelection (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_deleteSelection'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_deleteSelection(sbguitreeviewctrl);
}
/// <summary>
/// Get the child item of the given parent item whose text matches @a childName.
///    @param parentId Item ID of the parent in which to look for the child.
///    @param childName Text of the child item to find.
///    @return ID of the child item or -1 if no child in @a parentId has the given text @a childName.
///    @note This method does not recurse, i.e. it only looks for direct children. )
/// 
/// </summary>

public int fnGuiTreeViewCtrl_findChildItemByName (string guitreeviewctrl, int parentId, string childName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_findChildItemByName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",guitreeviewctrl,parentId,childName));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbchildName = null;
if (childName != null)
     sbchildName = new StringBuilder(childName, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_findChildItemByName(sbguitreeviewctrl, parentId, sbchildName);
}
/// <summary>
/// Get the ID of the item whose text matches the given @a text.
///    @param text Item text to match.
///    @return ID of the item or -1 if no item matches the given text. )
/// 
/// </summary>

public int fnGuiTreeViewCtrl_findItemByName (string guitreeviewctrl, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_findItemByName'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,text));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_findItemByName(sbguitreeviewctrl, sbtext);
}
/// <summary>
/// Get the ID of the item whose value matches @a value.
///    @param value Value text to match.
///    @return ID of the item or -1 if no item has the given value. )
/// 
/// </summary>

public int fnGuiTreeViewCtrl_findItemByValue (string guitreeviewctrl, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_findItemByValue'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,value));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_findItemByValue(sbguitreeviewctrl, sbvalue);
}
/// <summary>
/// Get the current filter expression.  Only tree items whose text matches this expression 
///    are displayed.  By default, the expression is empty and all items are shown.
///    @return The current filter pattern or an empty string if no filter pattern is currently active.
///    @see setFilterText
///    @see clearFilterText )
/// 
/// </summary>

public string fnGuiTreeViewCtrl_getFilterText (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_getFilterText'" + string.Format("\"{0}\" ",guitreeviewctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_getFilterText(sbguitreeviewctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Call SimObject::setHidden( @a state ) on all objects in the current selection.
///    @param state Visibility state to set objects in selection to. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_hideSelection (string guitreeviewctrl, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_hideSelection'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,state));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_hideSelection(sbguitreeviewctrl, state);
}
/// <summary>
/// , , 0, 0 ),
///    Add a new item to the tree.
///    @param parentId Item ID of parent to which to add the item as a child.  0 is root item.
///    @param text Text to display on the item in the tree.
///    @param value Behind-the-scenes value of the item.
///    @param icon
///    @param normalImage
///    @param expandedImage
///    @return The ID of the newly added item. )
/// 
/// </summary>

public int fnGuiTreeViewCtrl_insertItem (string guitreeviewctrl, int parentId, string text, string value, string icon, int normalImage, int expandedImage)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_insertItem'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",guitreeviewctrl,parentId,text,value,icon,normalImage,expandedImage));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);
StringBuilder sbicon = null;
if (icon != null)
     sbicon = new StringBuilder(icon, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_insertItem(sbguitreeviewctrl, parentId, sbtext, sbvalue, sbicon, normalImage, expandedImage);
}
/// <summary>
/// Inserts object as a child to the given parent. )
/// 
/// </summary>

public int fnGuiTreeViewCtrl_insertObject (string guitreeviewctrl, int parentId, string obj, bool OKToEdit)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_insertObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",guitreeviewctrl,parentId,obj,OKToEdit));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_insertObject(sbguitreeviewctrl, parentId, sbobj, OKToEdit);
}
/// <summary>
/// Check whether the given item is currently selected in the tree.
///    @param id Item/object ID.
///    @return True if the given item/object is currently selected in the tree. )
/// 
/// </summary>

public bool fnGuiTreeViewCtrl_isItemSelected (string guitreeviewctrl, int id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_isItemSelected'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,id));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTreeViewCtrl_isItemSelected(sbguitreeviewctrl, id)>=1;
}
/// <summary>
/// Set whether the current selection can be changed by the user or not.
///    @param lock If true, the current selection is frozen and cannot be changed.  If false, 
///       the selection may be modified. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_lockSelection (string guitreeviewctrl, bool lockx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_lockSelection'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,lockx));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_lockSelection(sbguitreeviewctrl, lockx);
}
/// <summary>
/// Set the pattern by which to filter items in the tree.  Only items in the tree whose text 
///    matches this pattern are displayed.
///    @param pattern New pattern based on which visible items in the tree should be filtered.  If empty, all items become visible.
///    @see getFilterText
///    @see clearFilterText )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_setFilterText (string guitreeviewctrl, string pattern)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_setFilterText'" + string.Format("\"{0}\" \"{1}\" ",guitreeviewctrl,pattern));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);
StringBuilder sbpattern = null;
if (pattern != null)
     sbpattern = new StringBuilder(pattern, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_setFilterText(sbguitreeviewctrl, sbpattern);
}
/// <summary>
/// Toggle the hidden state of all objects in the current selection. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_toggleHideSelection (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_toggleHideSelection'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_toggleHideSelection(sbguitreeviewctrl);
}
/// <summary>
/// Toggle the locked state of all objects in the current selection. )
/// 
/// </summary>

public void fnGuiTreeViewCtrl_toggleLockSelection (string guitreeviewctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTreeViewCtrl_toggleLockSelection'" + string.Format("\"{0}\" ",guitreeviewctrl));
StringBuilder sbguitreeviewctrl = null;
if (guitreeviewctrl != null)
     sbguitreeviewctrl = new StringBuilder(guitreeviewctrl, 1024);

SafeNativeMethods.mwle_fnGuiTreeViewCtrl_toggleLockSelection(sbguitreeviewctrl);
}
/// <summary>
/// Given the camera's current FOV, get the distance from the camera's viewpoint at which the given radius will fit in the render area.
///    @param radius Radius in world-space units which should fit in the view.
///    @return The distance from the viewpoint at which the given radius would be fully visible. )
/// 
/// </summary>

public float fnGuiTSCtrl_calculateViewDistance (string guitsctrl, float radius)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_calculateViewDistance'" + string.Format("\"{0}\" \"{1}\" ",guitsctrl,radius));
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiTSCtrl_calculateViewDistance(sbguitsctrl, radius);
}
/// <summary>
/// )
/// 
/// </summary>

public string fnGuiTSCtrl_getClickVector (string guitsctrl, string mousePoint)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_getClickVector'" + string.Format("\"{0}\" \"{1}\" ",guitsctrl,mousePoint));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);
StringBuilder sbmousePoint = null;
if (mousePoint != null)
     sbmousePoint = new StringBuilder(mousePoint, 1024);

SafeNativeMethods.mwle_fnGuiTSCtrl_getClickVector(sbguitsctrl, sbmousePoint, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// )
/// 
/// </summary>

public string fnGuiTSCtrl_getWorldPosition (string guitsctrl, string mousePoint)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_getWorldPosition'" + string.Format("\"{0}\" \"{1}\" ",guitsctrl,mousePoint));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);
StringBuilder sbmousePoint = null;
if (mousePoint != null)
     sbmousePoint = new StringBuilder(mousePoint, 1024);

SafeNativeMethods.mwle_fnGuiTSCtrl_getWorldPosition(sbguitsctrl, sbmousePoint, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the ratio between world-space units and pixels.
///    @return The amount of world-space units covered by the extent of a single pixel. )
/// 
/// </summary>

public string fnGuiTSCtrl_getWorldToScreenScale (string guitsctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_getWorldToScreenScale'" + string.Format("\"{0}\" ",guitsctrl));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);

SafeNativeMethods.mwle_fnGuiTSCtrl_getWorldToScreenScale(sbguitsctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Transform world-space coordinates to screen-space (x, y, depth) coordinates.
///    @param worldPosition The world-space position to transform to screen-space.
///    @return The  )
/// 
/// </summary>

public string fnGuiTSCtrl_project (string guitsctrl, string worldPosition)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_project'" + string.Format("\"{0}\" \"{1}\" ",guitsctrl,worldPosition));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);
StringBuilder sbworldPosition = null;
if (worldPosition != null)
     sbworldPosition = new StringBuilder(worldPosition, 1024);

SafeNativeMethods.mwle_fnGuiTSCtrl_project(sbguitsctrl, sbworldPosition, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Transform 3D screen-space coordinates (x, y, depth) to world space.
///    This method can be, for example, used to find the world-space position relating to the current mouse cursor position.
///    @param screenPosition The x/y position on the screen plus the depth from the screen-plane outwards.
///    @return The world-space position corresponding to the given screen-space coordinates. )
/// 
/// </summary>

public string fnGuiTSCtrl_unproject (string guitsctrl, string screenPosition)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiTSCtrl_unproject'" + string.Format("\"{0}\" \"{1}\" ",guitsctrl,screenPosition));
var returnbuff = new StringBuilder(1024);
StringBuilder sbguitsctrl = null;
if (guitsctrl != null)
     sbguitsctrl = new StringBuilder(guitsctrl, 1024);
StringBuilder sbscreenPosition = null;
if (screenPosition != null)
     sbscreenPosition = new StringBuilder(screenPosition, 1024);

SafeNativeMethods.mwle_fnGuiTSCtrl_unproject(sbguitsctrl, sbscreenPosition, returnbuff);
return returnbuff.ToString();

}
/// <summary>
///  )
/// 
/// </summary>

public void fnGuiWindowCtrl_attachTo (string guiwindowctrl, string window)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_attachTo'" + string.Format("\"{0}\" \"{1}\" ",guiwindowctrl,window));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);
StringBuilder sbwindow = null;
if (window != null)
     sbwindow = new StringBuilder(window, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_attachTo(sbguiwindowctrl, sbwindow);
}
/// <summary>
/// Puts the guiwindow back on the main canvas. )
/// 
/// </summary>

public void fnGuiWindowCtrl_ClosePopOut (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_ClosePopOut'" + string.Format("\"{0}\" ",guiwindowctrl));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_ClosePopOut(sbguiwindowctrl);
}
/// <summary>
/// Returns the title of the window. )
/// 
/// </summary>

public string fnGuiWindowCtrl_getWindowTitle (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_getWindowTitle'" + string.Format("\"{0}\" ",guiwindowctrl));
var returnbuff = new StringBuilder(16384);
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_getWindowTitle(sbguiwindowctrl, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns if the title can be set or not. )
/// 
/// </summary>

public bool fnGuiWindowCtrl_isTitleSet (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_isTitleSet'" + string.Format("\"{0}\" ",guiwindowctrl));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

return  SafeNativeMethods.mwle_fnGuiWindowCtrl_isTitleSet(sbguiwindowctrl)>=1;
}
/// <summary>
/// Puts the guiwindow on a new canvas. )
/// 
/// </summary>

public void fnGuiWindowCtrl_OpenPopOut (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_OpenPopOut'" + string.Format("\"{0}\" ",guiwindowctrl));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_OpenPopOut(sbguiwindowctrl);
}
/// <summary>
/// Bring the window to the front. )
/// 
/// </summary>

public void fnGuiWindowCtrl_selectWindow (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_selectWindow'" + string.Format("\"{0}\" ",guiwindowctrl));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_selectWindow(sbguiwindowctrl);
}
/// <summary>
/// Set the window's collapsing state. )
/// 
/// </summary>

public void fnGuiWindowCtrl_setCollapseGroup (string guiwindowctrl, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_setCollapseGroup'" + string.Format("\"{0}\" \"{1}\" ",guiwindowctrl,state));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_setCollapseGroup(sbguiwindowctrl, state);
}
/// <summary>
/// Displays the option to set the title of the window. )
/// 
/// </summary>

public void fnGuiWindowCtrl_setContextTitle (string guiwindowctrl, bool title)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_setContextTitle'" + string.Format("\"{0}\" \"{1}\" ",guiwindowctrl,title));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_setContextTitle(sbguiwindowctrl, title);
}
/// <summary>
/// Sets the title of the window. )
/// 
/// </summary>

public void fnGuiWindowCtrl_setWindowTitle (string guiwindowctrl, string title)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_setWindowTitle'" + string.Format("\"{0}\" \"{1}\" ",guiwindowctrl,title));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);
StringBuilder sbtitle = null;
if (title != null)
     sbtitle = new StringBuilder(title, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_setWindowTitle(sbguiwindowctrl, sbtitle);
}
/// <summary>
/// Toggle the window collapsing. )
/// 
/// </summary>

public void fnGuiWindowCtrl_toggleCollapseGroup (string guiwindowctrl)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnGuiWindowCtrl_toggleCollapseGroup'" + string.Format("\"{0}\" ",guiwindowctrl));
StringBuilder sbguiwindowctrl = null;
if (guiwindowctrl != null)
     sbguiwindowctrl = new StringBuilder(guiwindowctrl, 1024);

SafeNativeMethods.mwle_fnGuiWindowCtrl_toggleCollapseGroup(sbguiwindowctrl);
}
/// <summary>
///  ),
///    @brief Send a GET command to a server to send or retrieve data.
/// 
///    @param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: \"www.garagegames.com:80\").
///    @param requirstURI Specific location on the server to access (IE: \"index.php\".)
///    @param query Optional. Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. 
///    If you were building the URL manually, this is the text that follows the question mark.  For example: http://www.google.com/ig/api?b>weather=Las-Vegas,US/b>
///    
///    @tsexample
/// 	   // Create an HTTP object for communications
/// 	   %httpObj = new HTTPObject();
/// 	   // Specify a URL to transmit to
///       %url = \"www.garagegames.com:80\";
/// 	   // Specify a URI to communicate with
/// 	   %URI = \"/index.php\";
/// 	   // Specify a query to send.
/// 	   %query = \"\";
/// 	   // Send the GET command to the server
/// 	   %httpObj.get(%url,%URI,%query);
///    @endtsexample
///    )
/// 
/// </summary>

public void fnHTTPObject_get (string httpobject, string Address, string requirstURI, string query)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnHTTPObject_get'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",httpobject,Address,requirstURI,query));
StringBuilder sbhttpobject = null;
if (httpobject != null)
     sbhttpobject = new StringBuilder(httpobject, 1024);
StringBuilder sbAddress = null;
if (Address != null)
     sbAddress = new StringBuilder(Address, 1024);
StringBuilder sbrequirstURI = null;
if (requirstURI != null)
     sbrequirstURI = new StringBuilder(requirstURI, 1024);
StringBuilder sbquery = null;
if (query != null)
     sbquery = new StringBuilder(query, 1024);

SafeNativeMethods.mwle_fnHTTPObject_get(sbhttpobject, sbAddress, sbrequirstURI, sbquery);
}
/// <summary>
/// @brief Send POST command to a server to send or retrieve data.
/// 
///    @param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: \"www.garagegames.com:80\").
///    @param requirstURI Specific location on the server to access (IE: \"index.php\".)
///    @param query Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. 
///    @param post Submission data to be processed.
///    
///    @note The post() method is currently non-functional.
/// 
///    @tsexample
/// 	   // Create an HTTP object for communications
/// 	   %httpObj = new HTTPObject();
/// 	   // Specify a URL to transmit to
///       %url = \"www.garagegames.com:80\";
/// 	   // Specify a URI to communicate with
/// 	   %URI = \"/index.php\";
/// 	   // Specify a query to send.
/// 	   %query = \"\";
/// 	   // Specify the submission data.
/// 	   %post = \"\";
/// 	   // Send the POST command to the server
/// 	   %httpObj.POST(%url,%URI,%query,%post);
///    @endtsexample
///    )
/// 
/// </summary>

public void fnHTTPObject_post (string httpobject, string Address, string requirstURI, string query, string post)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnHTTPObject_post'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",httpobject,Address,requirstURI,query,post));
StringBuilder sbhttpobject = null;
if (httpobject != null)
     sbhttpobject = new StringBuilder(httpobject, 1024);
StringBuilder sbAddress = null;
if (Address != null)
     sbAddress = new StringBuilder(Address, 1024);
StringBuilder sbrequirstURI = null;
if (requirstURI != null)
     sbrequirstURI = new StringBuilder(requirstURI, 1024);
StringBuilder sbquery = null;
if (query != null)
     sbquery = new StringBuilder(query, 1024);
StringBuilder sbpost = null;
if (post != null)
     sbpost = new StringBuilder(post, 1024);

SafeNativeMethods.mwle_fnHTTPObject_post(sbhttpobject, sbAddress, sbrequirstURI, sbquery, sbpost);
}
/// <summary>
/// @brief Get the normal of the surface on which the object is stuck.   
///    @return Returns The XYZ normal from where this Item is stuck.
///    @tsexample
/// 	   // Acquire the position where this Item is currently stuck
/// 	   %stuckPosition = %item.getLastStickPos();
///    @endtsexample
///    @note Server side only.
///    )
/// 
/// </summary>

public string fnItem_getLastStickyNormal (string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_getLastStickyNormal'" + string.Format("\"{0}\" ",item));
var returnbuff = new StringBuilder(16384);
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

SafeNativeMethods.mwle_fnItem_getLastStickyNormal(sbitem, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the position on the surface on which this Item is stuck.   
///    @return Returns The XYZ position of where this Item is stuck.
///    @tsexample
/// 	   // Acquire the position where this Item is currently stuck
/// 	   %stuckPosition = %item.getLastStickPos();
///    @endtsexample
///    @note Server side only.
///    )
/// 
/// </summary>

public string fnItem_getLastStickyPos (string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_getLastStickyPos'" + string.Format("\"{0}\" ",item));
var returnbuff = new StringBuilder(16384);
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

SafeNativeMethods.mwle_fnItem_getLastStickyPos(sbitem, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Is the object at rest (ie, no longer moving)?   
///    @return True if the object is at rest, false if it is not.
///    @tsexample
/// 	   // Query the item on if it is or is not at rest.
/// 	   %isAtRest = %item.isAtRest();
///    @endtsexample
///    )
/// 
/// </summary>

public bool fnItem_isAtRest (string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_isAtRest'" + string.Format("\"{0}\" ",item));
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

return  SafeNativeMethods.mwle_fnItem_isAtRest(sbitem)>=1;
}
/// <summary>
/// @brief Is the object still rotating?   
///    @return True if the object is still rotating, false if it is not.
///    @tsexample
/// 	   // Query the item on if it is or is not rotating.
/// 	   %isRotating = %itemData.isRotating();
///    @endtsexample
///    @see rotate
///    )
/// 
/// </summary>

public bool fnItem_isRotating (string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_isRotating'" + string.Format("\"{0}\" ",item));
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

return  SafeNativeMethods.mwle_fnItem_isRotating(sbitem)>=1;
}
/// <summary>
/// @brief Is the object static (ie, non-movable)?   
///    @return True if the object is static, false if it is not.
///    @tsexample
/// 	   // Query the item on if it is or is not static.
/// 	   %isStatic = %itemData.isStatic();
///    @endtsexample
///    @see static
///    )
/// 
/// </summary>

public bool fnItem_isStatic (string item)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_isStatic'" + string.Format("\"{0}\" ",item));
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

return  SafeNativeMethods.mwle_fnItem_isStatic(sbitem)>=1;
}
/// <summary>
/// @brief Temporarily disable collisions against a specific ShapeBase object.
/// 
///    This is useful to prevent a player from immediately picking up an Item they have 
///    just thrown.  Only one object may be on the timeout list at a time.  The timeout is 
///    defined as 15 ticks.
/// 
///    @param objectID ShapeBase object ID to disable collisions against.
///    @return Returns true if the ShapeBase object requested could be found, false if it could not.
/// 
///    @tsexample
/// 	   // Set the ShapeBase Object ID to disable collisions against
/// 	   %ignoreColObj = %player.getID();
/// 	   // Inform this Item object to ignore collisions temproarily against the %ignoreColObj.
/// 	   %item.setCollisionTimeout(%ignoreColObj);
///    @endtsexample
///    )
/// 
/// </summary>

public bool fnItem_setCollisionTimeout (string item, int ignoreColObj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnItem_setCollisionTimeout'" + string.Format("\"{0}\" \"{1}\" ",item,ignoreColObj));
StringBuilder sbitem = null;
if (item != null)
     sbitem = new StringBuilder(item, 1024);

return  SafeNativeMethods.mwle_fnItem_setCollisionTimeout(sbitem, ignoreColObj)>=1;
}
/// <summary>
/// ( LevelInfo, setNearClip, void, 3, 3, ( F32 nearClip ))
/// 
/// </summary>

public void fnLevelInfo_setNearClip (string levelinfo, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLevelInfo_setNearClip'" + string.Format("\"{0}\" \"{1}\" ",levelinfo,a2));
StringBuilder sblevelinfo = null;
if (levelinfo != null)
     sblevelinfo = new StringBuilder(levelinfo, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnLevelInfo_setNearClip(sblevelinfo, sba2);
}
/// <summary>
/// @brief Toggles the light on and off
///    
///    @param state Turns the light on (true) or off (false)
/// 
///    @tsexample
///    // Disable the light
///    CrystalLight.setLightEnabled(false);
///    // Renable the light
///    CrystalLight.setLightEnabled(true);
///    
///    @endtsexample
/// )
/// 
/// </summary>

public void fnLightBase_setLightEnabled (string lightbase, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightBase_setLightEnabled'" + string.Format("\"{0}\" \"{1}\" ",lightbase,state));
StringBuilder sblightbase = null;
if (lightbase != null)
     sblightbase = new StringBuilder(lightbase, 1024);

SafeNativeMethods.mwle_fnLightBase_setLightEnabled(sblightbase, state);
}
/// <summary>
/// @brief Force an inspectPostApply call for the benefit of tweaking via the console
///    
///    Normally this functionality is only exposed to objects via the World Editor, once changes have been made. 
///    Exposing apply to script allows you to make changes to it on the fly without the World Editor.
/// 
///    @note This is intended for debugging and tweaking, not for game play
/// 
///    @tsexample
///    // Change a property of the light description
///    RocketLauncherLightDesc.brightness = 10;
///    // Make it so
///    RocketLauncherLightDesc.apply();
///    
///    @endtsexample
/// )
/// 
/// </summary>

public void fnLightDescription_apply (string lightdescription)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightDescription_apply'" + string.Format("\"{0}\" ",lightdescription));
StringBuilder sblightdescription = null;
if (lightdescription != null)
     sblightdescription = new StringBuilder(lightdescription, 1024);

SafeNativeMethods.mwle_fnLightDescription_apply(sblightdescription);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force trigger an inspectPostApply
///                    )
/// 
/// </summary>

public void fnLightFlareData_apply (string lightflaredata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightFlareData_apply'" + string.Format("\"{0}\" ",lightflaredata));
StringBuilder sblightflaredata = null;
if (lightflaredata != null)
     sblightflaredata = new StringBuilder(lightflaredata, 1024);

SafeNativeMethods.mwle_fnLightFlareData_apply(sblightflaredata);
}
/// <summary>
/// Creates a LightningStrikeEvent which strikes a specific object.
///    @note This method is currently unimplemented. )
/// 
/// </summary>

public void fnLightning_strikeObject (string lightning, string pSB)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightning_strikeObject'" + string.Format("\"{0}\" \"{1}\" ",lightning,pSB));
StringBuilder sblightning = null;
if (lightning != null)
     sblightning = new StringBuilder(lightning, 1024);
StringBuilder sbpSB = null;
if (pSB != null)
     sbpSB = new StringBuilder(pSB, 1024);

SafeNativeMethods.mwle_fnLightning_strikeObject(sblightning, sbpSB);
}
/// <summary>
/// Creates a LightningStrikeEvent which attempts to strike and damage a random 
///    object in range of the Lightning object.
///    @tsexample
///    // Generate a damaging lightning strike effect on all clients
///    %lightning.strikeRandomPoint();
///    @endtsexample )
/// 
/// </summary>

public void fnLightning_strikeRandomPoint (string lightning)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightning_strikeRandomPoint'" + string.Format("\"{0}\" ",lightning));
StringBuilder sblightning = null;
if (lightning != null)
     sblightning = new StringBuilder(lightning, 1024);

SafeNativeMethods.mwle_fnLightning_strikeRandomPoint(sblightning);
}
/// <summary>
/// @brief Creates a LightningStrikeEvent that triggers harmless lightning 
///    bolts on all clients.
///    No objects will be damaged by these bolts.
///    @tsexample
///    // Generate a harmless lightning strike effect on all clients
///    %lightning.warningFlashes();
///    @endtsexample )
/// 
/// </summary>

public void fnLightning_warningFlashes (string lightning)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnLightning_warningFlashes'" + string.Format("\"{0}\" ",lightning));
StringBuilder sblightning = null;
if (lightning != null)
     sblightning = new StringBuilder(lightning, 1024);

SafeNativeMethods.mwle_fnLightning_warningFlashes(sblightning);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force trigger an inspectPostApply. This will transmit 
///                    material and other fields ( not including nodes ) to client objects.
///                    )
/// 
/// </summary>

public void fnMeshRoad_postApply (string meshroad)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMeshRoad_postApply'" + string.Format("\"{0}\" ",meshroad));
StringBuilder sbmeshroad = null;
if (meshroad != null)
     sbmeshroad = new StringBuilder(meshroad, 1024);

SafeNativeMethods.mwle_fnMeshRoad_postApply(sbmeshroad);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force MeshRoad to recreate its geometry.
///                    )
/// 
/// </summary>

public void fnMeshRoad_regenerate (string meshroad)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMeshRoad_regenerate'" + string.Format("\"{0}\" ",meshroad));
StringBuilder sbmeshroad = null;
if (meshroad != null)
     sbmeshroad = new StringBuilder(meshroad, 1024);

SafeNativeMethods.mwle_fnMeshRoad_regenerate(sbmeshroad);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Sets the depth in meters of a particular node.
///                    )
/// 
/// </summary>

public void fnMeshRoad_setNodeDepth (string meshroad, int idx, float meters)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMeshRoad_setNodeDepth'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",meshroad,idx,meters));
StringBuilder sbmeshroad = null;
if (meshroad != null)
     sbmeshroad = new StringBuilder(meshroad, 1024);

SafeNativeMethods.mwle_fnMeshRoad_setNodeDepth(sbmeshroad, idx, meters);
}
/// <summary>
/// Clear all messages in the vector
///    @tsexample
///    HudMessageVector.clear();
///    @endtsexample)
/// 
/// </summary>

public void fnMessageVector_clear (string messagevector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_clear'" + string.Format("\"{0}\" ",messagevector));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

SafeNativeMethods.mwle_fnMessageVector_clear(sbmessagevector);
}
/// <summary>
/// Delete the line at the specified position.
///    @param deletePos Position in the vector containing the line to be deleted
///    @tsexample
///    // Delete the first line (index 0) in the vector...
///    HudMessageVector.deleteLine(0);
///    @endtsexample
///    @return False if deletePos is greater than the number of lines in the current vector)
/// 
/// </summary>

public bool fnMessageVector_deleteLine (string messagevector, int deletePos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_deleteLine'" + string.Format("\"{0}\" \"{1}\" ",messagevector,deletePos));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_deleteLine(sbmessagevector, deletePos)>=1;
}
/// <summary>
/// Scan through the vector, returning the line number of the first line that matches the specified tag; else returns -1 if no match was found.
///    @param tag Numerical value assigned to a message when it was added or inserted
///    @tsexample
///    // Locate a line of text tagged with the value \"1\", then delete it.
///    %taggedLine = HudMessageVector.getLineIndexByTag(1);
///    HudMessageVector.deleteLine(%taggedLine);
///    @endtsexample
///    @return Line with matching tag, other wise -1)
/// 
/// </summary>

public int fnMessageVector_getLineIndexByTag (string messagevector, int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_getLineIndexByTag'" + string.Format("\"{0}\" \"{1}\" ",messagevector,tag));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_getLineIndexByTag(sbmessagevector, tag);
}
/// <summary>
/// Get the tag of a specified line.
///    @param pos Position in vector to grab tag from
///    @tsexample
///    // Remove all lines that do not have a tag value of 1.
///    while( HudMessageVector.getNumLines())
///    {
///       %tag = HudMessageVector.getLineTag(1);
///       if(%tag != 1)
///          %tag.delete();
///       HudMessageVector.popFrontLine();
///    }
///    @endtsexample
///    @return Tag value of a given line, if the position is greater than the number of lines return 0)
/// 
/// </summary>

public int fnMessageVector_getLineTag (string messagevector, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_getLineTag'" + string.Format("\"{0}\" \"{1}\" ",messagevector,pos));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_getLineTag(sbmessagevector, pos);
}
/// <summary>
/// Get the text at a specified line.
///    @param pos Position in vector to grab text from
///    @tsexample
///    // Print a line of text at position 1.
///    %text = HudMessageVector.getLineText(1);
///    echo(%text);
///    @endtsexample
///    @return Text at specified line, if the position is greater than the number of lines return \"\")
/// 
/// </summary>

public string fnMessageVector_getLineText (string messagevector, int pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_getLineText'" + string.Format("\"{0}\" \"{1}\" ",messagevector,pos));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

SafeNativeMethods.mwle_fnMessageVector_getLineText(sbmessagevector, pos, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Scan through the lines in the vector, returning the first line that has a matching tag.
///    @param tag Numerical value assigned to a message when it was added or inserted
///    @tsexample
///    // Locate text in the vector tagged with the value \"1\", then print it
///    %taggedText = HudMessageVector.getLineTextByTag(1);
///    echo(%taggedText);
///    @endtsexample
///    @return Text from a line with matching tag, other wise \"\")
/// 
/// </summary>

public string fnMessageVector_getLineTextByTag (string messagevector, int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_getLineTextByTag'" + string.Format("\"{0}\" \"{1}\" ",messagevector,tag));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

SafeNativeMethods.mwle_fnMessageVector_getLineTextByTag(sbmessagevector, tag, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of lines in the vector.
///    @tsexample
///    // Find out how many lines have been stored in HudMessageVector
///    %chatLines = HudMessageVector.getNumLines();
///    echo(%chatLines);
///    @endtsexample)
/// 
/// </summary>

public int fnMessageVector_getNumLines (string messagevector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_getNumLines'" + string.Format("\"{0}\" ",messagevector));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_getNumLines(sbmessagevector);
}
/// <summary>
/// Push a line onto the back of the list.
///    @param msg Text that makes up the message
///    @param tag Numerical value associated with this message, useful for searching.
///    @tsexample
///    // Add the message...
///    HudMessageVector.insertLine(1, \"Hello World\", 0);
///    @endtsexample
///    @return False if insertPos is greater than the number of lines in the current vector)
/// 
/// </summary>

public bool fnMessageVector_insertLine (string messagevector, int insertPos, string msg, int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_insertLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",messagevector,insertPos,msg,tag));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);
StringBuilder sbmsg = null;
if (msg != null)
     sbmsg = new StringBuilder(msg, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_insertLine(sbmessagevector, insertPos, sbmsg, tag)>=1;
}
/// <summary>
/// Pop a line from the back of the list; destroys the line.
///    @tsexample
///    HudMessageVector.popBackLine();
///    @endtsexample
///    @return False if there are no lines to pop (underflow), true otherwise)
/// 
/// </summary>

public bool fnMessageVector_popBackLine (string messagevector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_popBackLine'" + string.Format("\"{0}\" ",messagevector));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_popBackLine(sbmessagevector)>=1;
}
/// <summary>
/// Pop a line from the front of the vector, destroying the line.
///    @tsexample
///    HudMessageVector.popFrontLine();
///    @endtsexample
///    @return False if there are no lines to pop (underflow), true otherwise)
/// 
/// </summary>

public bool fnMessageVector_popFrontLine (string messagevector)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_popFrontLine'" + string.Format("\"{0}\" ",messagevector));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);

return  SafeNativeMethods.mwle_fnMessageVector_popFrontLine(sbmessagevector)>=1;
}
/// <summary>
/// Push a line onto the back of the list.
///    @param msg Text that makes up the message
///    @param tag Numerical value associated with this message, useful for searching.
///    @tsexample
///    // Add the message...
///    HudMessageVector.pushBackLine(\"Hello World\", 0);
///    @endtsexample)
/// 
/// </summary>

public void fnMessageVector_pushBackLine (string messagevector, string msg, int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_pushBackLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",messagevector,msg,tag));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);
StringBuilder sbmsg = null;
if (msg != null)
     sbmsg = new StringBuilder(msg, 1024);

SafeNativeMethods.mwle_fnMessageVector_pushBackLine(sbmessagevector, sbmsg, tag);
}
/// <summary>
/// Push a line onto the front of the vector.
///    @param msg Text that makes up the message
///    @param tag Numerical value associated with this message, useful for searching.
///    @tsexample
///    // Add the message...
///    HudMessageVector.pushFrontLine(\"Hello World\", 0);
///    @endtsexample)
/// 
/// </summary>

public void fnMessageVector_pushFrontLine (string messagevector, string msg, int tag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMessageVector_pushFrontLine'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",messagevector,msg,tag));
StringBuilder sbmessagevector = null;
if (messagevector != null)
     sbmessagevector = new StringBuilder(messagevector, 1024);
StringBuilder sbmsg = null;
if (msg != null)
     sbmsg = new StringBuilder(msg, 1024);

SafeNativeMethods.mwle_fnMessageVector_pushFrontLine(sbmessagevector, sbmsg, tag);
}
/// <summary>
/// Returns 4 fields: starting x, starting y, extents x, extents y.)
/// 
/// </summary>

public string fnMissionArea_getArea (string missionarea)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMissionArea_getArea'" + string.Format("\"{0}\" ",missionarea));
var returnbuff = new StringBuilder(16384);
StringBuilder sbmissionarea = null;
if (missionarea != null)
     sbmissionarea = new StringBuilder(missionarea, 1024);

SafeNativeMethods.mwle_fnMissionArea_getArea(sbmissionarea, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force trigger an inspectPostApply. This will transmit 
///                    material and other fields ( not including nodes ) to client objects.
///                    )
/// 
/// </summary>

public void fnMissionArea_postApply (string missionarea)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMissionArea_postApply'" + string.Format("\"{0}\" ",missionarea));
StringBuilder sbmissionarea = null;
if (missionarea != null)
     sbmissionarea = new StringBuilder(missionarea, 1024);

SafeNativeMethods.mwle_fnMissionArea_postApply(sbmissionarea);
}
/// <summary>
/// @brief - Defines the size of the MissionArea
/// 			  param x Starting X coordinate position for MissionArea
/// 			  param y Starting Y coordinate position for MissionArea
/// 			  param width New width of the MissionArea
/// 			  param height New height of the MissionArea
///            @note Only the server object may be set.
/// 			  )
/// 
/// </summary>

public void fnMissionArea_setArea (string missionarea, int x, int y, int width, int height)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnMissionArea_setArea'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",missionarea,x,y,width,height));
StringBuilder sbmissionarea = null;
if (missionarea != null)
     sbmissionarea = new StringBuilder(missionarea, 1024);

SafeNativeMethods.mwle_fnMissionArea_setArea(sbmissionarea, x, y, width, height);
}
/// <summary>
/// Add a link to this NavMesh between two points.
///    )
/// 
/// </summary>

public int fnNavMesh_addLink (string navmesh, string from, string to, uint flags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_addLink'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",navmesh,from,to,flags));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);
StringBuilder sbfrom = null;
if (from != null)
     sbfrom = new StringBuilder(from, 1024);
StringBuilder sbto = null;
if (to != null)
     sbto = new StringBuilder(to, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_addLink(sbnavmesh, sbfrom, sbto, flags);
}
/// <summary>
/// @brief Create a Recast nav mesh.)
/// 
/// </summary>

public bool fnNavMesh_build (string navmesh, bool background, bool save)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_build'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",navmesh,background,save));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_build(sbnavmesh, background, save)>=1;
}
/// <summary>
/// @brief Build tiles of this mesh where there are unsynchronised links.)
/// 
/// </summary>

public void fnNavMesh_buildLinks (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_buildLinks'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_buildLinks(sbnavmesh);
}
/// <summary>
/// @brief Rebuild the tiles overlapped by the input box.)
/// 
/// </summary>

public void fnNavMesh_buildTiles (string navmesh, string box)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_buildTiles'" + string.Format("\"{0}\" \"{1}\" ",navmesh,box));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);
StringBuilder sbbox = null;
if (box != null)
     sbbox = new StringBuilder(box, 1024);

SafeNativeMethods.mwle_fnNavMesh_buildTiles(sbnavmesh, sbbox);
}
/// <summary>
/// @brief Cancel the current NavMesh build.)
/// 
/// </summary>

public void fnNavMesh_cancelBuild (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_cancelBuild'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_cancelBuild(sbnavmesh);
}
/// <summary>
/// @brief Create cover points for this NavMesh.)
/// 
/// </summary>

public bool fnNavMesh_createCoverPoints (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_createCoverPoints'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_createCoverPoints(sbnavmesh)>=1;
}
/// <summary>
/// @brief Remove all cover points for this NavMesh.)
/// 
/// </summary>

public void fnNavMesh_deleteCoverPoints (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_deleteCoverPoints'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_deleteCoverPoints(sbnavmesh);
}
/// <summary>
/// Delete a given off-mesh link.)
/// 
/// </summary>

public void fnNavMesh_deleteLink (string navmesh, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_deleteLink'" + string.Format("\"{0}\" \"{1}\" ",navmesh,id));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_deleteLink(sbnavmesh, id);
}
/// <summary>
/// Deletes all off-mesh links on this NavMesh.)
/// 
/// </summary>

public void fnNavMesh_deleteLinks (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_deleteLinks'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_deleteLinks(sbnavmesh);
}
/// <summary>
/// Get the off-mesh link closest to a given world point.)
/// 
/// </summary>

public int fnNavMesh_getLink (string navmesh, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_getLink'" + string.Format("\"{0}\" \"{1}\" ",navmesh,pos));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_getLink(sbnavmesh, sbpos);
}
/// <summary>
/// Return the number of links this mesh has.)
/// 
/// </summary>

public int fnNavMesh_getLinkCount (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_getLinkCount'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_getLinkCount(sbnavmesh);
}
/// <summary>
/// Get the ending point of an off-mesh link.)
/// 
/// </summary>

public string fnNavMesh_getLinkEnd (string navmesh, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_getLinkEnd'" + string.Format("\"{0}\" \"{1}\" ",navmesh,id));
var returnbuff = new StringBuilder(1024);
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_getLinkEnd(sbnavmesh, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the flags set for a particular off-mesh link.)
/// 
/// </summary>

public int fnNavMesh_getLinkFlags (string navmesh, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_getLinkFlags'" + string.Format("\"{0}\" \"{1}\" ",navmesh,id));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_getLinkFlags(sbnavmesh, id);
}
/// <summary>
/// Get the starting point of an off-mesh link.)
/// 
/// </summary>

public string fnNavMesh_getLinkStart (string navmesh, uint id)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_getLinkStart'" + string.Format("\"{0}\" \"{1}\" ",navmesh,id));
var returnbuff = new StringBuilder(1024);
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_getLinkStart(sbnavmesh, id, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Load this NavMesh from its file.)
/// 
/// </summary>

public bool fnNavMesh_load (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_load'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

return  SafeNativeMethods.mwle_fnNavMesh_load(sbnavmesh)>=1;
}
/// <summary>
/// @brief Save this NavMesh to its file.)
/// 
/// </summary>

public void fnNavMesh_save (string navmesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_save'" + string.Format("\"{0}\" ",navmesh));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_save(sbnavmesh);
}
/// <summary>
/// Set the flags of a particular off-mesh link.)
/// 
/// </summary>

public void fnNavMesh_setLinkFlags (string navmesh, uint id, uint flags)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavMesh_setLinkFlags'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",navmesh,id,flags));
StringBuilder sbnavmesh = null;
if (navmesh != null)
     sbnavmesh = new StringBuilder(navmesh, 1024);

SafeNativeMethods.mwle_fnNavMesh_setLinkFlags(sbnavmesh, id, flags);
}
/// <summary>
/// @brief Get a specified node along the path.)
/// 
/// </summary>

public int fnNavPath_getFlags (string navpath, int idx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_getFlags'" + string.Format("\"{0}\" \"{1}\" ",navpath,idx));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);

return  SafeNativeMethods.mwle_fnNavPath_getFlags(sbnavpath, idx);
}
/// <summary>
/// @brief Get the length of this path.)
/// 
/// </summary>

public float fnNavPath_getLength (string navpath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_getLength'" + string.Format("\"{0}\" ",navpath));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);

return  SafeNativeMethods.mwle_fnNavPath_getLength(sbnavpath);
}
/// <summary>
/// @brief Get a specified node along the path.)
/// 
/// </summary>

public string fnNavPath_getNode (string navpath, int idx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_getNode'" + string.Format("\"{0}\" \"{1}\" ",navpath,idx));
var returnbuff = new StringBuilder(1024);
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);

SafeNativeMethods.mwle_fnNavPath_getNode(sbnavpath, idx, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Callback when this path's NavMesh is loaded or rebuilt.)
/// 
/// </summary>

public void fnNavPath_onNavMeshUpdate (string navpath, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_onNavMeshUpdate'" + string.Format("\"{0}\" \"{1}\" ",navpath,data));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

SafeNativeMethods.mwle_fnNavPath_onNavMeshUpdate(sbnavpath, sbdata);
}
/// <summary>
/// @brief Callback when a particular area in this path's NavMesh is rebuilt.)
/// 
/// </summary>

public void fnNavPath_onNavMeshUpdateBox (string navpath, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_onNavMeshUpdateBox'" + string.Format("\"{0}\" \"{1}\" ",navpath,data));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

SafeNativeMethods.mwle_fnNavPath_onNavMeshUpdateBox(sbnavpath, sbdata);
}
/// <summary>
/// @brief Find a path using the already-specified path properties.)
/// 
/// </summary>

public bool fnNavPath_plan (string navpath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_plan'" + string.Format("\"{0}\" ",navpath));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);

return  SafeNativeMethods.mwle_fnNavPath_plan(sbnavpath)>=1;
}
/// <summary>
/// @brief Return the number of nodes in this path.)
/// 
/// </summary>

public int fnNavPath_size (string navpath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNavPath_size'" + string.Format("\"{0}\" ",navpath));
StringBuilder sbnavpath = null;
if (navpath != null)
     sbnavpath = new StringBuilder(navpath, 1024);

return  SafeNativeMethods.mwle_fnNavPath_size(sbnavpath);
}
/// <summary>
/// @brief Ensures that all configured packet rates and sizes meet minimum requirements.
/// 
///    This method is normally only called when a NetConnection class is first constructed.  It need 
///    only be manually called if the global variables that set the packet rate or size have changed.
/// 
///    @note If @$pref::Net::PacketRateToServer, @$pref::Net::PacketRateToClient or @$pref::Net::PacketSize 
///    have been changed since a NetConnection has been created, this method must be called on 
///    all connections for them to follow the new rates or size.)
/// 
/// </summary>

public void fnNetConnection_checkMaxRate (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_checkMaxRate'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_checkMaxRate(sbnetconnection);
}
/// <summary>
/// @brief On the server, resets the connection to indicate that motion spline paths have not been transmitted.
/// 
///    Typically when a mission has ended on the server, all connected clients are informed of this change 
///    and their connections are reset back to a starting state.  This method resets a connection on the 
///    server to indicate that motion spline paths have not been transmitted.
/// 
///    @tsexample
///       // Inform the clients
///       for (%clientIndex = 0; %clientIndex  ClientGroup.getCount(); %clientIndex++)
///       {
///          // clear ghosts and paths from all clients
///          %cl = ClientGroup.getObject(%clientIndex);
///          %cl.endMission();
///          %cl.resetGhosting();
///          %cl.clearPaths();
///       }
///    @endtsexample
///    
///    @see transmitPaths()
///    @see Path)
/// 
/// </summary>

public void fnNetConnection_clearPaths (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_clearPaths'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_clearPaths(sbnetconnection);
}
/// <summary>
/// @brief Connects to the remote address.
/// 
///    Attempts to connect with another NetConnection on the given address.  Typically once 
///    connected, a game's information is passed along from the server to the client, followed 
///    by the player entering the game world.  The actual procedure is dependent on 
///    the NetConnection subclass that is used.  i.e. GameConnection.
/// 
///    @param remoteAddress The address to connect to in the form of IP:address>:port 
///    although the i>IP:/i> portion is optional.  The i>address/i> portion may be in the form 
///    of w.x.y.z or as a host name, in which case a DNS lookup will be performed.  You may also 
///    substitue the word i>broadcast/i> for the address to broadcast the connect request over 
///    the local subnet.
/// 
///    @see NetConnection::connectLocal() to connect to a server running within the same process 
///    as the client.
///    )
/// 
/// </summary>

public void fnNetConnection_connect (string netconnection, string remoteAddress)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_connect'" + string.Format("\"{0}\" \"{1}\" ",netconnection,remoteAddress));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);
StringBuilder sbremoteAddress = null;
if (remoteAddress != null)
     sbremoteAddress = new StringBuilder(remoteAddress, 1024);

SafeNativeMethods.mwle_fnNetConnection_connect(sbnetconnection, sbremoteAddress);
}
/// <summary>
/// @brief Connects with the server that is running within the same process as the client.
/// 
///    @returns An error text message upon failure, or an empty string when successful.
/// 
///    @see See @ref local_connections for a description of local connections and their use.  See 
///    NetConnection::connect() to connect to a server running in another process (on the same machine or not).)
/// 
/// </summary>

public string fnNetConnection_connectLocal (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_connectLocal'" + string.Format("\"{0}\" ",netconnection));
var returnbuff = new StringBuilder(16384);
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_connectLocal(sbnetconnection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the far end network address for the connection.
/// 
///    The address will be in one of the following forms:
///    - b>IP:Broadcast:port>/b> for broadcast type addresses
///    - b>IP:address>:port>/b> for IP addresses
///    - b>local/b> when connected locally (server and client running in same process)
/// 
/// </summary>

public string fnNetConnection_getAddress (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_getAddress'" + string.Format("\"{0}\" ",netconnection));
var returnbuff = new StringBuilder(16384);
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_getAddress(sbnetconnection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief On server or client, convert a real id to the ghost id for this connection.
/// 
///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
///    this method on the server or client to discover an object's ghost ID based on its real SimObject ID.
/// 
///    @param realID The real SimObject ID of the object.
///    @returns The ghost ID of the object for this connection, or -1 if it could not be resolved.
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public int fnNetConnection_getGhostID (string netconnection, int realID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_getGhostID'" + string.Format("\"{0}\" \"{1}\" ",netconnection,realID));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_getGhostID(sbnetconnection, realID);
}
/// <summary>
/// Returns the ghost-index for an object.
/// 	@ingroup AFX)
/// 
/// </summary>

public int fnNetConnection_GetGhostIndex (string netconnection, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_GetGhostIndex'" + string.Format("\"{0}\" \"{1}\" ",netconnection,obj));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_GetGhostIndex(sbnetconnection, sbobj);
}
/// <summary>
/// @brief Provides the number of active ghosts on the connection.
///    @returns The number of active ghosts.
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public int fnNetConnection_getGhostsActive (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_getGhostsActive'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_getGhostsActive(sbnetconnection);
}
/// <summary>
/// @brief Returns the percentage of packets lost per tick.
/// 
///    @note This method is not yet hooked up.)
/// 
/// </summary>

public int fnNetConnection_getPacketLoss (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_getPacketLoss'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_getPacketLoss(sbnetconnection);
}
/// <summary>
/// @brief Returns the average round trip time (in ms) for the connection.
/// 
///    The round trip time is recalculated every time a notify packet is received.  Notify 
///    packets are used to information the connection that the far end successfully received 
///    the sent packet.)
/// 
/// </summary>

public int fnNetConnection_getPing (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_getPing'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_getPing(sbnetconnection);
}
/// <summary>
/// Resolves a ghost-index into an object ID.
/// 	@ingroup AFX)
/// 
/// </summary>

public int fnNetConnection_ResolveGhost (string netconnection, int ghostIndex)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_ResolveGhost'" + string.Format("\"{0}\" \"{1}\" ",netconnection,ghostIndex));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_ResolveGhost(sbnetconnection, ghostIndex);
}
/// <summary>
/// @brief On the client, convert a ghost ID from this connection to a real SimObject ID.
/// 
///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
///    this method on the client to discover an object's local SimObject ID when you only have a 
///    ghost ID.
/// 
///    @param ghostID The ghost ID of the object as sent by the server.
///    @returns The SimObject ID of the object, or 0 if it could not be resolved.
/// 
///    @tsexample
///       %object = ServerConnection.resolveGhostID( %ghostId );
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public int fnNetConnection_resolveGhostID (string netconnection, int ghostID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_resolveGhostID'" + string.Format("\"{0}\" \"{1}\" ",netconnection,ghostID));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_resolveGhostID(sbnetconnection, ghostID);
}
/// <summary>
/// @brief On the server, convert a ghost ID from this connection to a real SimObject ID.
/// 
///    Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use 
///    this method on the server to discover an object's local SimObject ID when you only have a 
///    ghost ID.
/// 
///    @param ghostID The ghost ID of the object as sent by the server.
///    @returns The SimObject ID of the object, or 0 if it could not be resolved.
/// 
///    @tsexample
///       %object = %client.resolveObjectFromGhostIndex( %ghostId );
///    @endtsexample
/// 
///    @see @ref ghosting_scoping for a description of the ghosting system.)
/// 
/// </summary>

public int fnNetConnection_resolveObjectFromGhostIndex (string netconnection, int ghostID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_resolveObjectFromGhostIndex'" + string.Format("\"{0}\" \"{1}\" ",netconnection,ghostID));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

return  SafeNativeMethods.mwle_fnNetConnection_resolveObjectFromGhostIndex(sbnetconnection, ghostID);
}
/// <summary>
/// @brief Simulate network issues on the connection for testing.
/// 
///    @param packetLoss The fraction of packets that will be lost.  Ranges from 0.0 (no loss) to 1.0 (complete loss)
///    @param delay Delays packets being transmitted by simulating a particular ping.  This is an absolute 
///    integer, measured in ms.)
/// 
/// </summary>

public void fnNetConnection_setSimulatedNetParams (string netconnection, float packetLoss, int delay)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_setSimulatedNetParams'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",netconnection,packetLoss,delay));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_setSimulatedNetParams(sbnetconnection, packetLoss, delay);
}
/// <summary>
/// @brief Sent by the server during phase 2 of the mission download to update motion spline paths.
/// 
///    The server transmits all spline motion paths that are within the mission (Path) separate from 
///    other objects.  This is due to the potentially large number of nodes within each path, which may 
///    saturate a packet sent to the client.  By managing this step separately, Torque has finer control 
///    over how packets are organised vs. doing it during the ghosting stage.
/// 
///    Internally a PathManager is used to track all paths defined within a mission on the server, and each 
///    one is transmitted using a PathManagerEvent.  The client side collects these events and builds the 
///    given paths within its own PathManager.  This is typically done during the standard mission start 
///    phase 2 when following Torque's example mission startup sequence.
/// 
///    When a mission is ended, all paths need to be cleared from their respective path managers.
/// 
///    @tsexample
///    function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
///    {
///       // Make sure to ignore calls from a previous mission load
///       if (%seq != $missionSequence || !$MissionRunning)
///          return;
///       if (%client.currentPhase != 1.5)
///          return;
///       %client.currentPhase = 2;
///    
///       // Set the player datablock choice
///       %client.playerDB = %playerDB;
///    
///       // Update mission paths (SimPath), this needs to get there before the objects.
///       %client.transmitPaths();
///    
///       // Start ghosting objects to the client
///       %client.activateGhosting();
///    }
///    @endtsexample
///    
///    @see clearPaths()
///    @see Path)
/// 
/// </summary>

public void fnNetConnection_transmitPaths (string netconnection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetConnection_transmitPaths'" + string.Format("\"{0}\" ",netconnection));
StringBuilder sbnetconnection = null;
if (netconnection != null)
     sbnetconnection = new StringBuilder(netconnection, 1024);

SafeNativeMethods.mwle_fnNetConnection_transmitPaths(sbnetconnection);
}
/// <summary>
/// @brief Undo the effects of a scopeToClient() call.
/// 
///    @param client The connection to remove this object's scoping from 
///    
///    @see scopeToClient())
/// 
/// </summary>

public void fnNetObject_clearScopeToClient (string netobject, string client)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_clearScopeToClient'" + string.Format("\"{0}\" \"{1}\" ",netobject,client));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);
StringBuilder sbclient = null;
if (client != null)
     sbclient = new StringBuilder(client, 1024);

SafeNativeMethods.mwle_fnNetObject_clearScopeToClient(sbnetobject, sbclient);
}
/// <summary>
/// @brief Returns a pointer to the client object when on a local connection.
/// 
///    Short-Circuit-Networking: this is only valid for a local-client / singleplayer situation.
/// 
///    @returns the SimObject ID of the client object.
/// 
///    @tsexample
///       // Psuedo-code, some values left out for this example
///       %node = new ParticleEmitterNode(){};
///       %clientObject = %node.getClientObject();
///       if(isObject(%clientObject)
///       	%clientObject.setTransform(\"0 0 0\");
///    @endtsexample
///    
///    @see @ref local_connections)
/// 
/// </summary>

public int fnNetObject_getClientObject (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_getClientObject'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

return  SafeNativeMethods.mwle_fnNetObject_getClientObject(sbnetobject);
}
/// <summary>
/// @brief Get the ghost index of this object from the server.
/// 
///    @returns The ghost ID of this NetObject on the server
/// 
///    @tsexample
///       %ghostID = LocalClientConnection.getGhostId( %serverObject );
///    @endtsexample)
/// 
/// </summary>

public int fnNetObject_getGhostID (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_getGhostID'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

return  SafeNativeMethods.mwle_fnNetObject_getGhostID(sbnetobject);
}
/// <summary>
/// @brief Returns a pointer to the client object when on a local connection.
/// 
///    Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.
///    
///    @returns The SimObject ID of the server object.
///    @tsexample
///       // Psuedo-code, some values left out for this example
///       %node = new ParticleEmitterNode(){};
///       %serverObject = %node.getServerObject();
///       if(isObject(%serverObject)
///       	%serverObject.setTransform(\"0 0 0\");
///    @endtsexample
///    
///    @see @ref local_connections)
/// 
/// </summary>

public int fnNetObject_getServerObject (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_getServerObject'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

return  SafeNativeMethods.mwle_fnNetObject_getServerObject(sbnetobject);
}
/// <summary>
/// @brief Called to check if an object resides on the clientside.
///    @return True if the object resides on the client, false otherwise.)
/// 
/// </summary>

public bool fnNetObject_isClientObject (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_isClientObject'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

return  SafeNativeMethods.mwle_fnNetObject_isClientObject(sbnetobject)>=1;
}
/// <summary>
/// @brief Checks if an object resides on the server.
///    @return True if the object resides on the server, false otherwise.)
/// 
/// </summary>

public bool fnNetObject_isServerObject (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_isServerObject'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

return  SafeNativeMethods.mwle_fnNetObject_isServerObject(sbnetobject)>=1;
}
/// <summary>
/// @brief Cause the NetObject to be forced as scoped on the specified NetConnection.
/// 
///    @param client The connection this object will always be scoped to
/// 
///    @tsexample
///       // Called to create new cameras in TorqueScript
///       // %this - The active GameConnection
///       // %spawnPoint - The spawn point location where we creat the camera
///       function GameConnection::spawnCamera(%this, %spawnPoint)
///       {
///       	// If this connection's camera exists
///       	if(isObject(%this.camera))
///       	{
///       		// Add it to the mission group to be cleaned up later
///       		MissionCleanup.add( %this.camera );
///       		// Force it to scope to the client side
///       		%this.camera.scopeToClient(%this);
///       	}
///       }
///    @endtsexample
///    
///    @see clearScopeToClient())
/// 
/// </summary>

public void fnNetObject_scopeToClient (string netobject, string client)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_scopeToClient'" + string.Format("\"{0}\" \"{1}\" ",netobject,client));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);
StringBuilder sbclient = null;
if (client != null)
     sbclient = new StringBuilder(client, 1024);

SafeNativeMethods.mwle_fnNetObject_scopeToClient(sbnetobject, sbclient);
}
/// <summary>
/// @brief Always scope this object on all connections.
/// 
///    The object is marked as ScopeAlways and is immediately ghosted to 
///    all active connections.  This function has no effect if the object 
///    is not marked as Ghostable.)
/// 
/// </summary>

public void fnNetObject_setScopeAlways (string netobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnNetObject_setScopeAlways'" + string.Format("\"{0}\" ",netobject));
StringBuilder sbnetobject = null;
if (netobject != null)
     sbnetobject = new StringBuilder(netobject, 1024);

SafeNativeMethods.mwle_fnNetObject_setScopeAlways(sbnetobject);
}
/// <summary>
/// Reloads this particle.
///    @tsexample
///    // Get the editor's current particle
///    %particle = PE_ParticleEditor.currParticle
///    // Change a particle value
///    %particle.setFieldValue( %propertyField, %value );
///    // Reload it
///    %particle.reload();
///    @endtsexample )
/// 
/// </summary>

public void fnParticleData_reload (string particledata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnParticleData_reload'" + string.Format("\"{0}\" ",particledata));
StringBuilder sbparticledata = null;
if (particledata != null)
     sbparticledata = new StringBuilder(particledata, 1024);

SafeNativeMethods.mwle_fnParticleData_reload(sbparticledata);
}
/// <summary>
/// Reloads the ParticleData datablocks and other fields used by this emitter.
///    @tsexample
///    // Get the editor's current particle emitter
///    %emitter = PE_EmitterEditor.currEmitter
///    // Change a field value
///    %emitter.setFieldValue( %propertyField, %value );
///    // Reload this emitter
///    %emitter.reload();
///    @endtsexample)
/// 
/// </summary>

public void fnParticleEmitterData_reload (string particleemitterdata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnParticleEmitterData_reload'" + string.Format("\"{0}\" ",particleemitterdata));
StringBuilder sbparticleemitterdata = null;
if (particleemitterdata != null)
     sbparticleemitterdata = new StringBuilder(particleemitterdata, 1024);

SafeNativeMethods.mwle_fnParticleEmitterData_reload(sbparticleemitterdata);
}
/// <summary>
/// Turns the emitter on or off.
///    @param active New emitter state )
/// 
/// </summary>

public void fnParticleEmitterNode_setActive (string particleemitternode, bool active)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnParticleEmitterNode_setActive'" + string.Format("\"{0}\" \"{1}\" ",particleemitternode,active));
StringBuilder sbparticleemitternode = null;
if (particleemitternode != null)
     sbparticleemitternode = new StringBuilder(particleemitternode, 1024);

SafeNativeMethods.mwle_fnParticleEmitterNode_setActive(sbparticleemitternode, active);
}
/// <summary>
/// Assigns the datablock for this emitter node.
///    @param emitterDatablock ParticleEmitterData datablock to assign
///    @tsexample
///    // Assign a new emitter datablock
///    %emitter.setEmitterDatablock( %emitterDatablock );
///    @endtsexample )
/// 
/// </summary>

public void fnParticleEmitterNode_setEmitterDataBlock (string particleemitternode, string emitterDatablock)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnParticleEmitterNode_setEmitterDataBlock'" + string.Format("\"{0}\" \"{1}\" ",particleemitternode,emitterDatablock));
StringBuilder sbparticleemitternode = null;
if (particleemitternode != null)
     sbparticleemitternode = new StringBuilder(particleemitternode, 1024);
StringBuilder sbemitterDatablock = null;
if (emitterDatablock != null)
     sbemitterDatablock = new StringBuilder(emitterDatablock, 1024);

SafeNativeMethods.mwle_fnParticleEmitterNode_setEmitterDataBlock(sbparticleemitternode, sbemitterDatablock);
}
/// <summary>
/// Removes the knot at the front of the camera's path.
/// 													@tsexample
/// 														// Remove the first knot in the camera's path.
/// 														%pathCamera.popFront();
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_popFront (string pathcamera)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_popFront'" + string.Format("\"{0}\" ",pathcamera));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);

SafeNativeMethods.mwle_fnPathCamera_popFront(sbpathcamera);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the back of a path camera's path.
/// 													@param transform Transform for the new knot.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\"
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the path camera to add a new knot to the back of its path
/// 														%pathCamera.pushBack(%transform,%speed,%type,%path);
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_pushBack (string pathcamera, string transform, float speed, string type, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_pushBack'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",pathcamera,transform,speed,type,path));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnPathCamera_pushBack(sbpathcamera, sbtransform, speed, sbtype, sbpath);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the front of a path camera's path.
/// 													@param transform Transform for the new knot. In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\";
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the path camera to add a new knot to the front of its path
/// 														%pathCamera.pushFront(%transform, %speed, %type, %path);
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_pushFront (string pathcamera, string transform, float speed, string type, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_pushFront'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",pathcamera,transform,speed,type,path));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnPathCamera_pushFront(sbpathcamera, sbtransform, speed, sbtype, sbpath);
}
/// <summary>
/// @brief Clear the camera's path and set the camera's current transform as the start of the new path.
///                                        What specifically occurs is a new knot is created from the camera's current transform.  Then the current path 
///                                        is cleared and the new knot is pushed onto the path.  Any previous target is cleared and the camera's movement 
///                                        state is set to Forward.  The camera is now ready for a new path to be defined.
/// 													@param speed Speed for the camera to move along its path after being reset.
/// 													@tsexample
/// 														//Determine the new movement speed of this camera. If not set, the speed will default to 1.0.
/// 														%speed = \"0.50\";
/// 														// Inform the path camera to start a new path at
///                                           // the camera's current position, and set the new 
///                                           // path's speed value.
/// 														%pathCamera.reset(%speed);
///                                        @endtsexample)
/// 
/// </summary>

public void fnPathCamera_reset (string pathcamera, float speed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_reset'" + string.Format("\"{0}\" \"{1}\" ",pathcamera,speed));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);

SafeNativeMethods.mwle_fnPathCamera_reset(sbpathcamera, speed);
}
/// <summary>
/// Set the current position of the camera along the path.
/// 													@param position Position along the path, from 0.0 (path start) - 1.0 (path end), to place the camera.
/// 													@tsexample
///                                           // Set the camera on a position along its path from 0.0 - 1.0.
/// 														%position = \"0.35\";
/// 														// Force the pathCamera to its new position along the path.
/// 														%pathCamera.setPosition(%position);
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_setPosition (string pathcamera, float position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_setPosition'" + string.Format("\"{0}\" \"{1}\" ",pathcamera,position));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);

SafeNativeMethods.mwle_fnPathCamera_setPosition(sbpathcamera, position);
}
/// <summary>
/// forward), Set the movement state for this path camera.
/// 													@param newState New movement state type for this camera. Forward, Backward or Stop.
/// 													@tsexample
/// 														// Set the state type (forward, backward, stop).
///                                           // In this example, the camera will travel from the first node
///                                           // to the last node (or target if given with setTarget())
/// 														%state = \"forward\";
/// 														// Inform the pathCamera to change its movement state to the defined value.
/// 														%pathCamera.setState(%state);
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_setState (string pathcamera, string newState)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_setState'" + string.Format("\"{0}\" \"{1}\" ",pathcamera,newState));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);
StringBuilder sbnewState = null;
if (newState != null)
     sbnewState = new StringBuilder(newState, 1024);

SafeNativeMethods.mwle_fnPathCamera_setState(sbpathcamera, sbnewState);
}
/// <summary>
/// @brief Set the movement target for this camera along its path.
///                                        The camera will attempt to move along the path to the given target in the direction provided 
///                                        by setState() (the default is forwards).  Once the camera moves past this target it will come 
///                                        to a stop, and the target state will be cleared.
/// 													@param position Target position, between 0.0 (path start) and 1.0 (path end), for the camera to move to along its path.
/// 													@tsexample
///                                           // Set the position target, between 0.0 (path start) and 1.0 (path end), for this camera to move to.
/// 														%position = \"0.50\";
/// 														// Inform the pathCamera of the new target position it will move to.
/// 														%pathCamera.setTarget(%position);
/// 													@endtsexample)
/// 
/// </summary>

public void fnPathCamera_setTarget (string pathcamera, float position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPathCamera_setTarget'" + string.Format("\"{0}\" \"{1}\" ",pathcamera,position));
StringBuilder sbpathcamera = null;
if (pathcamera != null)
     sbpathcamera = new StringBuilder(pathcamera, 1024);

SafeNativeMethods.mwle_fnPathCamera_setTarget(sbpathcamera, position);
}
/// <summary>
/// Activate the physical zone's effects.
/// 													@tsexample
/// 														// Activate effects for a specific physical zone.
/// 														%thisPhysicalZone.activate();
/// 													@endtsexample
/// 													@ingroup Datablocks
/// 				  )
/// 
/// </summary>

public void fnPhysicalZone_activate (string physicalzone)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicalZone_activate'" + string.Format("\"{0}\" ",physicalzone));
StringBuilder sbphysicalzone = null;
if (physicalzone != null)
     sbphysicalzone = new StringBuilder(physicalzone, 1024);

SafeNativeMethods.mwle_fnPhysicalZone_activate(sbphysicalzone);
}
/// <summary>
/// Deactivate the physical zone's effects.
/// 													@tsexample
/// 														// Deactivate effects for a specific physical zone.
/// 														%thisPhysicalZone.deactivate();
/// 													@endtsexample
/// 													@ingroup Datablocks
/// 				  )
/// 
/// </summary>

public void fnPhysicalZone_deactivate (string physicalzone)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicalZone_deactivate'" + string.Format("\"{0}\" ",physicalzone));
StringBuilder sbphysicalzone = null;
if (physicalzone != null)
     sbphysicalzone = new StringBuilder(physicalzone, 1024);

SafeNativeMethods.mwle_fnPhysicalZone_deactivate(sbphysicalzone);
}
/// <summary>
/// @brief Attempts to associate the PhysicsForce with a PhysicsBody.
///    Performs a physics ray cast of the provided length and direction. The %PhysicsForce  
///    will attach itself to the first dynamic PhysicsBody the ray collides with. 
///    On every tick, the attached body will be attracted towards the position of the %PhysicsForce.
///    A %PhysicsForce can only be attached to one body at a time.
///    @note To determine if an %attach was successful, check isAttached() immediately after 
///    calling this function.n)
/// 
/// </summary>

public void fnPhysicsForce_attach (string physicsforce, string start, string direction, float maxDist)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsForce_attach'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",physicsforce,start,direction,maxDist));
StringBuilder sbphysicsforce = null;
if (physicsforce != null)
     sbphysicsforce = new StringBuilder(physicsforce, 1024);
StringBuilder sbstart = null;
if (start != null)
     sbstart = new StringBuilder(start, 1024);
StringBuilder sbdirection = null;
if (direction != null)
     sbdirection = new StringBuilder(direction, 1024);

SafeNativeMethods.mwle_fnPhysicsForce_attach(sbphysicsforce, sbstart, sbdirection, maxDist);
}
/// <summary>
/// @brief Disassociates the PhysicsForce from any attached PhysicsBody.
///    @param force Optional force to apply to the attached PhysicsBody 
///    before detaching.
///    @note Has no effect if the %PhysicsForce is not attached to anything.)
/// 
/// </summary>

public void fnPhysicsForce_detach (string physicsforce, string force)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsForce_detach'" + string.Format("\"{0}\" \"{1}\" ",physicsforce,force));
StringBuilder sbphysicsforce = null;
if (physicsforce != null)
     sbphysicsforce = new StringBuilder(physicsforce, 1024);
StringBuilder sbforce = null;
if (force != null)
     sbforce = new StringBuilder(force, 1024);

SafeNativeMethods.mwle_fnPhysicsForce_detach(sbphysicsforce, sbforce);
}
/// <summary>
/// @brief Returns true if the %PhysicsForce is currently attached to an object.
///    @see PhysicsForce::attach())
/// 
/// </summary>

public bool fnPhysicsForce_isAttached (string physicsforce)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsForce_isAttached'" + string.Format("\"{0}\" ",physicsforce));
StringBuilder sbphysicsforce = null;
if (physicsforce != null)
     sbphysicsforce = new StringBuilder(physicsforce, 1024);

return  SafeNativeMethods.mwle_fnPhysicsForce_isAttached(sbphysicsforce)>=1;
}
/// <summary>
/// @brief Disables rendering and physical simulation.
///    Calling destroy() will also spawn any explosions, debris, and/or destroyedShape 
///    defined for it, as well as remove it from the scene graph.
///    Destroyed objects are only created on the server. Ghosting will later update the client.
///    @note This does not actually delete the PhysicsShape. )
/// 
/// </summary>

public void fnPhysicsShape_destroy (string physicsshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsShape_destroy'" + string.Format("\"{0}\" ",physicsshape));
StringBuilder sbphysicsshape = null;
if (physicsshape != null)
     sbphysicsshape = new StringBuilder(physicsshape, 1024);

SafeNativeMethods.mwle_fnPhysicsShape_destroy(sbphysicsshape);
}
/// <summary>
/// @brief Returns if a PhysicsShape has been destroyed or not. )
/// 
/// </summary>

public bool fnPhysicsShape_isDestroyed (string physicsshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsShape_isDestroyed'" + string.Format("\"{0}\" ",physicsshape));
StringBuilder sbphysicsshape = null;
if (physicsshape != null)
     sbphysicsshape = new StringBuilder(physicsshape, 1024);

return  SafeNativeMethods.mwle_fnPhysicsShape_isDestroyed(sbphysicsshape)>=1;
}
/// <summary>
/// @brief Restores the shape to its state before being destroyed.
///    Re-enables rendering and physical simulation on the object and 
///    adds it to the client's scene graph. 
///    Has no effect if the shape is not destroyed.)
/// 
/// </summary>

public void fnPhysicsShape_restore (string physicsshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPhysicsShape_restore'" + string.Format("\"{0}\" ",physicsshape));
StringBuilder sbphysicsshape = null;
if (physicsshape != null)
     sbphysicsshape = new StringBuilder(physicsshape, 1024);

SafeNativeMethods.mwle_fnPhysicsShape_restore(sbphysicsshape);
}
/// <summary>
/// @brief Allow all poses a chance to occur.
///    This method resets any poses that have manually been blocked from occuring.  
///    This includes the regular pose states such as sprinting, crouch, being prone 
///    and swimming.  It also includes being able to jump and jet jump.  While this 
///    is allowing these poses to occur it doesn't mean that they all can due to other 
///    conditions.  We're just not manually blocking them from being allowed.
///    @see allowJumping()
///    @see allowJetJumping()
///    @see allowSprinting()
///    @see allowCrouching()
///    @see allowProne()
///    @see allowSwimming() )
/// 
/// </summary>

public void fnPlayer_allowAllPoses (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowAllPoses'" + string.Format("\"{0}\" ",player));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowAllPoses(sbplayer);
}
/// <summary>
/// @brief Set if the Player is allowed to crouch.
///    The default is to allow crouching unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow crouching 
///    at any time.
///    @param state Set to true to allow crouching, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowCrouching (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowCrouching'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowCrouching(sbplayer, state);
}
/// <summary>
/// @brief Set if the Player is allowed to jet jump.
///    The default is to allow jet jumping unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow jet jumping 
///    at any time.
///    @param state Set to true to allow jet jumping, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowJetJumping (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowJetJumping'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowJetJumping(sbplayer, state);
}
/// <summary>
/// @brief Set if the Player is allowed to jump.
///    The default is to allow jumping unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow jumping 
///    at any time.
///    @param state Set to true to allow jumping, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowJumping (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowJumping'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowJumping(sbplayer, state);
}
/// <summary>
/// @brief Set if the Player is allowed to go prone.
///    The default is to allow being prone unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow going prone 
///    at any time.
///    @param state Set to true to allow being prone, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowProne (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowProne'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowProne(sbplayer, state);
}
/// <summary>
/// @brief Set if the Player is allowed to sprint.
///    The default is to allow sprinting unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow sprinting 
///    at any time.
///    @param state Set to true to allow sprinting, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowSprinting (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowSprinting'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowSprinting(sbplayer, state);
}
/// <summary>
/// @brief Set if the Player is allowed to swim.
///    The default is to allow swimming unless there are other environmental concerns 
///    that prevent it.  This method is mainly used to explicitly disallow swimming 
///    at any time.
///    @param state Set to true to allow swimming, false to disable it.
///    @see allowAllPoses() )
/// 
/// </summary>

public void fnPlayer_allowSwimming (string player, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_allowSwimming'" + string.Format("\"{0}\" \"{1}\" ",player,state));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_allowSwimming(sbplayer, state);
}
/// <summary>
/// @brief Check if it is safe to dismount at this position.
/// 
///    Internally this method casts a ray from oldPos to pos to determine if it hits the 
///    terrain, an interior object, a water object, another player, a static shape, 
///    a vehicle (exluding the one currently mounted), or physical zone.  If this ray 
///    is in the clear, then the player's bounding box is also checked for a collision at 
///    the pos position.  If this displaced bounding box is also in the clear, then 
///    checkDismountPoint() returns true.
/// 
///    @param oldPos The player's current position
///    @param pos The dismount position to check
///    @return True if the dismount position is clear, false if not
///    
///    @note The player must be already mounted for this method to not assert.)
/// 
/// </summary>

public bool fnPlayer_checkDismountPoint (string player, string oldPos, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_checkDismountPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",player,oldPos,pos));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);
StringBuilder sboldPos = null;
if (oldPos != null)
     sboldPos = new StringBuilder(oldPos, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

return  SafeNativeMethods.mwle_fnPlayer_checkDismountPoint(sbplayer, sboldPos, sbpos)>=1;
}
/// <summary>
/// @brief Clears the player's current control object.
///    Returns control to the player. This internally calls 
///    Player::setControlObject(0).
///    @tsexample
/// 		%player.clearControlObject();
///       echo(%player.getControlObject()); //-- Returns 0, player assumes control
///       %player.setControlObject(%vehicle);
///       echo(%player.getControlObject()); //-- Returns %vehicle, player controls the vehicle now.
/// 	@endtsexample
///    @note If the player does not have a control object, the player will receive all moves 
///    from its GameConnection.  If you're looking to remove control from the player itself 
///    (i.e. stop sending moves to the player) use GameConnection::setControlObject() to transfer 
///    control to another object, such as a camera.
///    @see setControlObject()
///    @see getControlObject()
///    @see GameConnection::setControlObject())
/// 
/// </summary>

public void fnPlayer_clearControlObject (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_clearControlObject'" + string.Format("\"{0}\" ",player));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_clearControlObject(sbplayer);
}
/// <summary>
/// @brief Get the current object we are controlling.
///    @return ID of the ShapeBase object we control, or 0 if not controlling an 
///    object.
///    @see setControlObject()
///    @see clearControlObject())
/// 
/// </summary>

public int fnPlayer_getControlObject (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_getControlObject'" + string.Format("\"{0}\" ",player));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

return  SafeNativeMethods.mwle_fnPlayer_getControlObject(sbplayer);
}
/// <summary>
/// @brief Get the named damage location and modifier for a given world position.
/// 
///    the Player object can simulate different hit locations based on a pre-defined set 
///    of PlayerData defined percentages.  These hit percentages divide up the Player's 
///    bounding box into different regions.  The diagram below demonstrates how the various 
///    PlayerData properties split up the bounding volume:
/// 
///    img src=\"images/player_damageloc.png\">
/// 
///    While you may pass in any world position and getDamageLocation() will provide a best-fit 
///    location, you should be aware that this can produce some interesting results.  For example, 
///    any position that is above PlayerData::boxHeadPercentage will be considered a 'head' hit, even 
///    if the world position is high in the sky.  Therefore it may be wise to keep the passed in point 
///    to somewhere on the surface of, or within, the Player's bounding volume.
/// 
///    @note This method will not return an accurate location when the player is 
///    prone or swimming.
/// 
///    @param pos A world position for which to retrieve a body region on this player.
/// 
///    @return a string containing two words (space separated strings), where the 
///    first is a location and the second is a modifier.
/// 
///    Posible locations:ul>
///    li>head/li>
///    li>torso/li>
///    li>legs/li>/ul>
/// 
///    Head modifiers:ul>
///    li>left_back/li>
///    li>middle_back/li>
///    li>right_back/li>
///    li>left_middle/li>
///    li>middle_middle/li>
///    li>right_middle/li>
///    li>left_front/li>
///    li>middle_front/li>
///    li>right_front/li>/ul>
/// 
///    Legs/Torso modifiers:ul>
///    li>front_left/li>
///    li>front_right/li>
///    li>back_left/li>
///    li>back_right/li>/ul>
/// 
///    @see PlayerData::boxHeadPercentage
///    @see PlayerData::boxHeadFrontPercentage
///    @see PlayerData::boxHeadBackPercentage
///    @see PlayerData::boxHeadLeftPercentage
///    @see PlayerData::boxHeadRightPercentage
///    @see PlayerData::boxTorsoPercentage
///    )
/// 
/// </summary>

public string fnPlayer_getDamageLocation (string player, string pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_getDamageLocation'" + string.Format("\"{0}\" \"{1}\" ",player,pos));
var returnbuff = new StringBuilder(16384);
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);

SafeNativeMethods.mwle_fnPlayer_getDamageLocation(sbplayer, sbpos, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the number of death animations available to this player.
///    Death animations are assumed to be named death1-N using consecutive indices. )
/// 
/// </summary>

public int fnPlayer_getNumDeathAnimations (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_getNumDeathAnimations'" + string.Format("\"{0}\" ",player));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

return  SafeNativeMethods.mwle_fnPlayer_getNumDeathAnimations(sbplayer);
}
/// <summary>
/// @brief Get the name of the player's current pose.
/// 
///    The pose is one of the following:ul>
///    li>Stand - Standard movement pose./li>
///    li>Sprint - Sprinting pose./li>
///    li>Crouch - Crouch pose./li>
///    li>Prone - Prone pose./li>
///    li>Swim - Swimming pose./li>/ul>
/// 
///    @return The current pose; one of: \"Stand\", \"Sprint\", \"Crouch\", \"Prone\", \"Swim\" )
/// 
/// </summary>

public string fnPlayer_getPose (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_getPose'" + string.Format("\"{0}\" ",player));
var returnbuff = new StringBuilder(16384);
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_getPose(sbplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the name of the player's current state.
/// 
///    The state is one of the following:ul>
///    li>Dead - The Player is dead./li>
///    li>Mounted - The Player is mounted to an object such as a vehicle./li>
///    li>Move - The Player is free to move.  The usual state./li>
///    li>Recover - The Player is recovering from a fall.  See PlayerData::recoverDelay./li>/ul>
/// 
///    @return The current state; one of: \"Dead\", \"Mounted\", \"Move\", \"Recover\" )
/// 
/// </summary>

public string fnPlayer_getState (string player)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_getState'" + string.Format("\"{0}\" ",player));
var returnbuff = new StringBuilder(16384);
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);

SafeNativeMethods.mwle_fnPlayer_getState(sbplayer, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Set the main action sequence to play for this player.
///    @param name Name of the action sequence to set
///    @param hold Set to false to get a callback on the datablock when the sequence ends (PlayerData::animationDone()).  
///    When set to true no callback is made.
///    @param fsp True if first person and none of the spine nodes in the shape should animate.  False will allow the shape's 
///    spine nodes to animate.
///    @return True if succesful, false if failed
///    
///    @note The spine nodes for the Player's shape are named as follows:ul>
///    li>Bip01 Pelvis/li>
///    li>Bip01 Spine/li>
///    li>Bip01 Spine1/li>
///    li>Bip01 Spine2/li>
///    li>Bip01 Neck/li>
///    li>Bip01 Head/li>/ul>
///    
///    You cannot use setActionThread() to have the Player play one of the motion 
///    determined action animation sequences.  These sequences are chosen based on how 
///    the Player moves and the Player's current pose.  The names of these sequences are:ul>
///    li>root/li>
///    li>run/li>
///    li>side/li>
///    li>side_right/li>
///    li>crouch_root/li>
///    li>crouch_forward/li>
///    li>crouch_backward/li>
///    li>crouch_side/li>
///    li>crouch_right/li>
///    li>prone_root/li>
///    li>prone_forward/li>
///    li>prone_backward/li>
///    li>swim_root/li>
///    li>swim_forward/li>
///    li>swim_backward/li>
///    li>swim_left/li>
///    li>swim_right/li>
///    li>fall/li>
///    li>jump/li>
///    li>standjump/li>
///    li>land/li>
///    li>jet/li>/ul>
///    
///    If the player moves in any direction then the animation sequence set using this 
///    method will be cancelled and the chosen mation-based sequence will take over.  This makes 
///    great for times when the Player cannot move, such as when mounted, or when it doesn't matter 
///    if the action sequence changes, such as waving and saluting.
///    
///    @tsexample
///       // Place the player in a sitting position after being mounted
///       %player.setActionThread( \"sitting\", true, true );
/// 	@endtsexample)
/// 
/// </summary>

public bool fnPlayer_setActionThread (string player, string name, bool hold, bool fsp)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_setActionThread'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",player,name,hold,fsp));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnPlayer_setActionThread(sbplayer, sbname, hold, fsp)>=1;
}
/// <summary>
/// @brief Set the sequence that controls the player's arms (dynamically adjusted 
///    to match look direction).
///    @param name Name of the sequence to play on the player's arms.
///    @return true if successful, false if failed.
///    @note By default the 'look' sequence is used, if available.)
/// 
/// </summary>

public bool fnPlayer_setArmThread (string player, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_setArmThread'" + string.Format("\"{0}\" \"{1}\" ",player,name));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnPlayer_setArmThread(sbplayer, sbname)>=1;
}
/// <summary>
/// @brief Set the object to be controlled by this player
/// 
///    It is possible to have the moves sent to the Player object from the 
///    GameConnection to be passed along to another object.  This happens, for example 
///    when a player is mounted to a vehicle.  The move commands pass through the Player 
///    and on to the vehicle (while the player remains stationary within the vehicle).  
///    With setControlObject() you can have the Player pass along its moves to any object.  
///    One possible use is for a player to move a remote controlled vehicle.  In this case 
///    the player does not mount the vehicle directly, but still wants to be able to control it.
/// 
///    @param obj Object to control with this player
///    @return True if the object is valid, false if not
/// 
///    @see getControlObject()
///    @see clearControlObject()
///    @see GameConnection::setControlObject())
/// 
/// </summary>

public bool fnPlayer_setControlObject (string player, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPlayer_setControlObject'" + string.Format("\"{0}\" \"{1}\" ",player,obj));
StringBuilder sbplayer = null;
if (player != null)
     sbplayer = new StringBuilder(player, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnPlayer_setControlObject(sbplayer, sbobj)>=1;
}
/// <summary>
/// Test whether the portal connects interior zones to the outdoor zone.
///    @return True if the portal is an exterior portal. )
/// 
/// </summary>

public bool fnPortal_isExteriorPortal (string portal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPortal_isExteriorPortal'" + string.Format("\"{0}\" ",portal));
StringBuilder sbportal = null;
if (portal != null)
     sbportal = new StringBuilder(portal, 1024);

return  SafeNativeMethods.mwle_fnPortal_isExteriorPortal(sbportal)>=1;
}
/// <summary>
/// Test whether the portal connects interior zones only.
///    @return True if the portal is an interior portal. )
/// 
/// </summary>

public bool fnPortal_isInteriorPortal (string portal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPortal_isInteriorPortal'" + string.Format("\"{0}\" ",portal));
StringBuilder sbportal = null;
if (portal != null)
     sbportal = new StringBuilder(portal, 1024);

return  SafeNativeMethods.mwle_fnPortal_isInteriorPortal(sbportal)>=1;
}
/// <summary>
/// Remove all shader macros. )
/// 
/// </summary>

public void fnPostEffect_clearShaderMacros (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_clearShaderMacros'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

SafeNativeMethods.mwle_fnPostEffect_clearShaderMacros(sbposteffect);
}
/// <summary>
/// Disables the effect. )
/// 
/// </summary>

public void fnPostEffect_disable (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_disable'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

SafeNativeMethods.mwle_fnPostEffect_disable(sbposteffect);
}
/// <summary>
/// Dumps this PostEffect shader's disassembly to a temporary text file.
///    @return Full path to the dumped file or an empty string if failed. )
/// 
/// </summary>

public string fnPostEffect_dumpShaderDisassembly (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_dumpShaderDisassembly'" + string.Format("\"{0}\" ",posteffect));
var returnbuff = new StringBuilder(1024);
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

SafeNativeMethods.mwle_fnPostEffect_dumpShaderDisassembly(sbposteffect, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Enables the effect. )
/// 
/// </summary>

public void fnPostEffect_enable (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_enable'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

SafeNativeMethods.mwle_fnPostEffect_enable(sbposteffect);
}
/// <summary>
/// @return Width over height of the backbuffer. )
/// 
/// </summary>

public float fnPostEffect_getAspectRatio (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_getAspectRatio'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

return  SafeNativeMethods.mwle_fnPostEffect_getAspectRatio(sbposteffect);
}
/// <summary>
/// @return True if the effect is enabled. )
/// 
/// </summary>

public bool fnPostEffect_isEnabled (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_isEnabled'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

return  SafeNativeMethods.mwle_fnPostEffect_isEnabled(sbposteffect)>=1;
}
/// <summary>
/// Reloads the effect shader and textures. )
/// 
/// </summary>

public void fnPostEffect_reload (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_reload'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

SafeNativeMethods.mwle_fnPostEffect_reload(sbposteffect);
}
/// <summary>
/// Remove a shader macro. This will usually be called within the preProcess callback.
///    @param key Macro to remove. )
/// 
/// </summary>

public void fnPostEffect_removeShaderMacro (string posteffect, string key)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_removeShaderMacro'" + string.Format("\"{0}\" \"{1}\" ",posteffect,key));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);

SafeNativeMethods.mwle_fnPostEffect_removeShaderMacro(sbposteffect, sbkey);
}
/// <summary>
/// Sets the value of a uniform defined in the shader. This will usually 
///    be called within the setShaderConsts callback. Array type constants are 
///    not supported.    
///    @param name Name of the constanst, prefixed with '$'. 
///    @param value Value to set, space seperate values with more than one element.
///    @tsexample
///    function MyPfx::setShaderConsts( %this )
///    {
///       // example float4 uniform
///       %this.setShaderConst( \"$colorMod\", \"1.0 0.9 1.0 1.0\" );
///       // example float1 uniform
///       %this.setShaderConst( \"$strength\", \"3.0\" );
///       // example integer uniform
///       %this.setShaderConst( \"$loops\", \"5\" );
///    }
///    @endtsexample )   
/// 
/// </summary>

public void fnPostEffect_setShaderConst (string posteffect, string name, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_setShaderConst'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",posteffect,name,value));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnPostEffect_setShaderConst(sbposteffect, sbname, sbvalue);
}
/// <summary>
///  ),
///    Adds a macro to the effect's shader or sets an existing one's value. 
///    This will usually be called within the onAdd or preProcess callback.
///    @param key lval of the macro.
///    @param value rval of the macro, or may be empty.
///    @tsexample
///    function MyPfx::onAdd( %this )
///    {
///       %this.setShaderMacro( \"NUM_SAMPLES\", \"10\" );
///       %this.setShaderMacro( \"HIGH_QUALITY_MODE\" );
///       
///       // In the shader looks like... 
///       // #define NUM_SAMPLES 10
///       // #define HIGH_QUALITY_MODE
///    }
///    @endtsexample )
/// 
/// </summary>

public void fnPostEffect_setShaderMacro (string posteffect, string key, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_setShaderMacro'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",posteffect,key,value));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);
StringBuilder sbkey = null;
if (key != null)
     sbkey = new StringBuilder(key, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnPostEffect_setShaderMacro(sbposteffect, sbkey, sbvalue);
}
/// <summary>
/// This is used to set the texture file and load the texture on a running effect. 
///    If the texture file is not different from the current file nothing is changed.  If 
///    the texture cannot be found a null texture is assigned.    
///    @param index The texture stage index. 
///    @param filePath The file name of the texture to set. )
/// 
/// </summary>

public void fnPostEffect_setTexture (string posteffect, int index, string filePath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_setTexture'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",posteffect,index,filePath));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);
StringBuilder sbfilePath = null;
if (filePath != null)
     sbfilePath = new StringBuilder(filePath, 1024);

SafeNativeMethods.mwle_fnPostEffect_setTexture(sbposteffect, index, sbfilePath);
}
/// <summary>
/// Toggles the effect between enabled / disabled.
///    @return True if effect is enabled. )
/// 
/// </summary>

public bool fnPostEffect_toggle (string posteffect)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPostEffect_toggle'" + string.Format("\"{0}\" ",posteffect));
StringBuilder sbposteffect = null;
if (posteffect != null)
     sbposteffect = new StringBuilder(posteffect, 1024);

return  SafeNativeMethods.mwle_fnPostEffect_toggle(sbposteffect)>=1;
}
/// <summary>
/// Smoothly change the maximum number of drops in the effect (from current 
///    value to #numDrops * @a percentage).
///    This method can be used to simulate a storm building or fading in intensity 
///    as the number of drops in the Precipitation box changes.
///    @param percentage New maximum number of drops value (as a percentage of 
///    #numDrops). Valid range is 0-1.
///    @param seconds Length of time (in seconds) over which to increase the drops 
///    percentage value. Set to 0 to change instantly.
///    @tsexample
///    %percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
///    %seconds = 5.0;     // The length of time over which to make the change.
///    %precipitation.modifyStorm( %percentage, %seconds );
///    @endtsexample )
/// 
/// </summary>

public void fnPrecipitation_modifyStorm (string precipitation, float percentage, float seconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPrecipitation_modifyStorm'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",precipitation,percentage,seconds));
StringBuilder sbprecipitation = null;
if (precipitation != null)
     sbprecipitation = new StringBuilder(precipitation, 1024);

SafeNativeMethods.mwle_fnPrecipitation_modifyStorm(sbprecipitation, percentage, seconds);
}
/// <summary>
/// Sets the maximum number of drops in the effect, as a percentage of #numDrops.
///    The change occurs instantly (use modifyStorm() to change the number of drops 
///    over a period of time.
///    @param percentage New maximum number of drops value (as a percentage of 
///    #numDrops). Valid range is 0-1.
///    @tsexample
///    %percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
///    %precipitation.setPercentage( %percentage );
///    @endtsexample
///    @see modifyStorm )
/// 
/// </summary>

public void fnPrecipitation_setPercentage (string precipitation, float percentage)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPrecipitation_setPercentage'" + string.Format("\"{0}\" \"{1}\" ",precipitation,percentage));
StringBuilder sbprecipitation = null;
if (precipitation != null)
     sbprecipitation = new StringBuilder(precipitation, 1024);

SafeNativeMethods.mwle_fnPrecipitation_setPercentage(sbprecipitation, percentage);
}
/// <summary>
/// Smoothly change the turbulence parameters over a period of time.
///    @param max New #maxTurbulence value. Set to 0 to disable turbulence.
///    @param speed New #turbulenceSpeed value.
///    @param seconds Length of time (in seconds) over which to interpolate the 
///    turbulence settings. Set to 0 to change instantly.
///    @tsexample
///    %turbulence = 0.5;     // Set the new turbulence value. Set to 0 to disable turbulence.
///    %speed = 5.0;          // The new speed of the turbulance effect.
///    %seconds = 5.0;        // The length of time over which to make the change.
///    %precipitation.setTurbulence( %turbulence, %speed, %seconds );
///    @endtsexample )
/// 
/// </summary>

public void fnPrecipitation_setTurbulence (string precipitation, float max, float speed, float seconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnPrecipitation_setTurbulence'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",precipitation,max,speed,seconds));
StringBuilder sbprecipitation = null;
if (precipitation != null)
     sbprecipitation = new StringBuilder(precipitation, 1024);

SafeNativeMethods.mwle_fnPrecipitation_setTurbulence(sbprecipitation, max, speed, seconds);
}
/// <summary>
/// @brief Updates the projectile's positional and collision information.
///                                        This function will first delete the projectile if it is a server object and is outside it's ProjectileData::lifetime. 
///                                        Also responsible for applying gravity, determining collisions, triggering explosions, 
///                                        emitting trail particles, and calculating bounces if necessary.
/// 									            @param seconds Amount of time, in seconds since the simulation's start, to advance.
/// 									            @tsexample
/// 									               // Tell the projectile to process a simulation event, and provide the amount of time
/// 										            // that has passed since the simulation began.
/// 										            %seconds = 2.0;
/// 										            %projectile.presimulate(%seconds);
/// 									            @endtsexample
///                                        @note This function is not called if the SimObject::hidden is true.)
/// 
/// </summary>

public void fnProjectile_presimulate (string projectile, float seconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnProjectile_presimulate'" + string.Format("\"{0}\" \"{1}\" ",projectile,seconds));
StringBuilder sbprojectile = null;
if (projectile != null)
     sbprojectile = new StringBuilder(projectile, 1024);

SafeNativeMethods.mwle_fnProjectile_presimulate(sbprojectile, seconds);
}
/// <summary>
/// @brief Manually cause the mine to explode.)
/// 
/// </summary>

public void fnProximityMine_explode (string proximitymine)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnProximityMine_explode'" + string.Format("\"{0}\" ",proximitymine));
StringBuilder sbproximitymine = null;
if (proximitymine != null)
     sbproximitymine = new StringBuilder(proximitymine, 1024);

SafeNativeMethods.mwle_fnProximityMine_explode(sbproximitymine);
}
/// <summary>
/// Returns the bin type string. )
/// 
/// </summary>

public string fnRenderBinManager_getBinType (string renderbinmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderBinManager_getBinType'" + string.Format("\"{0}\" ",renderbinmanager));
var returnbuff = new StringBuilder(16384);
StringBuilder sbrenderbinmanager = null;
if (renderbinmanager != null)
     sbrenderbinmanager = new StringBuilder(renderbinmanager, 1024);

SafeNativeMethods.mwle_fnRenderBinManager_getBinType(sbrenderbinmanager, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// A utility method for forcing a network update.)
/// 
/// </summary>

public void fnRenderMeshExample_postApply (string rendermeshexample)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderMeshExample_postApply'" + string.Format("\"{0}\" ",rendermeshexample));
StringBuilder sbrendermeshexample = null;
if (rendermeshexample != null)
     sbrendermeshexample = new StringBuilder(rendermeshexample, 1024);

SafeNativeMethods.mwle_fnRenderMeshExample_postApply(sbrendermeshexample);
}
/// <summary>
/// Add as a render bin manager to the pass. )
/// 
/// </summary>

public void fnRenderPassManager_addManager (string renderpassmanager, string renderBin)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassManager_addManager'" + string.Format("\"{0}\" \"{1}\" ",renderpassmanager,renderBin));
StringBuilder sbrenderpassmanager = null;
if (renderpassmanager != null)
     sbrenderpassmanager = new StringBuilder(renderpassmanager, 1024);
StringBuilder sbrenderBin = null;
if (renderBin != null)
     sbrenderBin = new StringBuilder(renderBin, 1024);

SafeNativeMethods.mwle_fnRenderPassManager_addManager(sbrenderpassmanager, sbrenderBin);
}
/// <summary>
/// Returns the render bin manager at the index or null if the index is out of range. )
/// 
/// </summary>

public string fnRenderPassManager_getManager (string renderpassmanager, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassManager_getManager'" + string.Format("\"{0}\" \"{1}\" ",renderpassmanager,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbrenderpassmanager = null;
if (renderpassmanager != null)
     sbrenderpassmanager = new StringBuilder(renderpassmanager, 1024);

SafeNativeMethods.mwle_fnRenderPassManager_getManager(sbrenderpassmanager, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the total number of bin managers. )
/// 
/// </summary>

public int fnRenderPassManager_getManagerCount (string renderpassmanager)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassManager_getManagerCount'" + string.Format("\"{0}\" ",renderpassmanager));
StringBuilder sbrenderpassmanager = null;
if (renderpassmanager != null)
     sbrenderpassmanager = new StringBuilder(renderpassmanager, 1024);

return  SafeNativeMethods.mwle_fnRenderPassManager_getManagerCount(sbrenderpassmanager);
}
/// <summary>
/// Removes a render bin manager. )
/// 
/// </summary>

public void fnRenderPassManager_removeManager (string renderpassmanager, string renderBin)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassManager_removeManager'" + string.Format("\"{0}\" \"{1}\" ",renderpassmanager,renderBin));
StringBuilder sbrenderpassmanager = null;
if (renderpassmanager != null)
     sbrenderpassmanager = new StringBuilder(renderpassmanager, 1024);
StringBuilder sbrenderBin = null;
if (renderBin != null)
     sbrenderBin = new StringBuilder(renderBin, 1024);

SafeNativeMethods.mwle_fnRenderPassManager_removeManager(sbrenderpassmanager, sbrenderBin);
}
/// <summary>
/// @brief Disables the token.)
/// 
/// </summary>

public void fnRenderPassStateToken_disable (string renderpassstatetoken)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassStateToken_disable'" + string.Format("\"{0}\" ",renderpassstatetoken));
StringBuilder sbrenderpassstatetoken = null;
if (renderpassstatetoken != null)
     sbrenderpassstatetoken = new StringBuilder(renderpassstatetoken, 1024);

SafeNativeMethods.mwle_fnRenderPassStateToken_disable(sbrenderpassstatetoken);
}
/// <summary>
/// @brief Enables the token. )
/// 
/// </summary>

public void fnRenderPassStateToken_enable (string renderpassstatetoken)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassStateToken_enable'" + string.Format("\"{0}\" ",renderpassstatetoken));
StringBuilder sbrenderpassstatetoken = null;
if (renderpassstatetoken != null)
     sbrenderpassstatetoken = new StringBuilder(renderpassstatetoken, 1024);

SafeNativeMethods.mwle_fnRenderPassStateToken_enable(sbrenderpassstatetoken);
}
/// <summary>
/// @brief Toggles the token from enabled to disabled or vice versa. )
/// 
/// </summary>

public void fnRenderPassStateToken_toggle (string renderpassstatetoken)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRenderPassStateToken_toggle'" + string.Format("\"{0}\" ",renderpassstatetoken));
StringBuilder sbrenderpassstatetoken = null;
if (renderpassstatetoken != null)
     sbrenderpassstatetoken = new StringBuilder(renderpassstatetoken, 1024);

SafeNativeMethods.mwle_fnRenderPassStateToken_toggle(sbrenderpassstatetoken);
}
/// <summary>
/// @brief Forces the client to jump to the RigidShape's transform rather then warp to it.)
/// 
/// </summary>

public void fnRigidShape_forceClientTransform (string rigidshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRigidShape_forceClientTransform'" + string.Format("\"{0}\" ",rigidshape));
StringBuilder sbrigidshape = null;
if (rigidshape != null)
     sbrigidshape = new StringBuilder(rigidshape, 1024);

SafeNativeMethods.mwle_fnRigidShape_forceClientTransform(sbrigidshape);
}
/// <summary>
/// @brief Enables or disables the physics simulation on the RigidShape object.
///    @param isFrozen Boolean frozen state to set the object.
///    @tsexample
///    // Define the frozen state.
///    %isFrozen = \"true\";
///    // Inform the object of the defined frozen state
///    %thisRigidShape.freezeSim(%isFrozen);
///    @endtsexample
///    @see ShapeBaseData)
/// 
/// </summary>

public void fnRigidShape_freezeSim (string rigidshape, bool isFrozen)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRigidShape_freezeSim'" + string.Format("\"{0}\" \"{1}\" ",rigidshape,isFrozen));
StringBuilder sbrigidshape = null;
if (rigidshape != null)
     sbrigidshape = new StringBuilder(rigidshape, 1024);

SafeNativeMethods.mwle_fnRigidShape_freezeSim(sbrigidshape, isFrozen);
}
/// <summary>
/// @brief Clears physic forces from the shape and sets it at rest.
///    @tsexample
///    // Inform the RigidShape object to reset.
///    %thisRigidShape.reset();
///    @endtsexample
///    @see ShapeBaseData)
/// 
/// </summary>

public void fnRigidShape_reset (string rigidshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRigidShape_reset'" + string.Format("\"{0}\" ",rigidshape));
StringBuilder sbrigidshape = null;
if (rigidshape != null)
     sbrigidshape = new StringBuilder(rigidshape, 1024);

SafeNativeMethods.mwle_fnRigidShape_reset(sbrigidshape);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Force River to recreate its geometry.
///                    )
/// 
/// </summary>

public void fnRiver_regenerate (string river)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRiver_regenerate'" + string.Format("\"{0}\" ",river));
StringBuilder sbriver = null;
if (river != null)
     sbriver = new StringBuilder(river, 1024);

SafeNativeMethods.mwle_fnRiver_regenerate(sbriver);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    BatchSize is not currently used.
///                    )
/// 
/// </summary>

public void fnRiver_setBatchSize (string river, float meters)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRiver_setBatchSize'" + string.Format("\"{0}\" \"{1}\" ",river,meters));
StringBuilder sbriver = null;
if (river != null)
     sbriver = new StringBuilder(river, 1024);

SafeNativeMethods.mwle_fnRiver_setBatchSize(sbriver, meters);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    @see SubdivideLength field.
///                    )
/// 
/// </summary>

public void fnRiver_setMaxDivisionSize (string river, float meters)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRiver_setMaxDivisionSize'" + string.Format("\"{0}\" \"{1}\" ",river,meters));
StringBuilder sbriver = null;
if (river != null)
     sbriver = new StringBuilder(river, 1024);

SafeNativeMethods.mwle_fnRiver_setMaxDivisionSize(sbriver, meters);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    @see SegmentLength field.
///                    )
/// 
/// </summary>

public void fnRiver_setMetersPerSegment (string river, float meters)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRiver_setMetersPerSegment'" + string.Format("\"{0}\" \"{1}\" ",river,meters));
StringBuilder sbriver = null;
if (river != null)
     sbriver = new StringBuilder(river, 1024);

SafeNativeMethods.mwle_fnRiver_setMetersPerSegment(sbriver, meters);
}
/// <summary>
/// Intended as a helper to developers and editor scripts.
///                    Sets the depth in meters of a particular node.
///                    )
/// 
/// </summary>

public void fnRiver_setNodeDepth (string river, int idx, float meters)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnRiver_setNodeDepth'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",river,idx,meters));
StringBuilder sbriver = null;
if (river != null)
     sbriver = new StringBuilder(river, 1024);

SafeNativeMethods.mwle_fnRiver_setNodeDepth(sbriver, idx, meters);
}
/// <summary>
/// Apply a full network update of all fields to all clients.
///                   )
/// 
/// </summary>

public void fnScatterSky_applyChanges (string scattersky)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnScatterSky_applyChanges'" + string.Format("\"{0}\" ",scattersky));
StringBuilder sbscattersky = null;
if (scattersky != null)
     sbscattersky = new StringBuilder(scattersky, 1024);

SafeNativeMethods.mwle_fnScatterSky_applyChanges(sbscattersky);
}
/// <summary>
/// Get Euler rotation of this object.
///    @return the orientation of the object in the form of rotations around the 
///    X, Y and Z axes in degrees. )
/// 
/// </summary>

public string fnSceneObject_getEulerRotation (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getEulerRotation'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getEulerRotation(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the direction this object is facing.
///    @return a vector indicating the direction this object is facing.
///    @note This is the object's y axis. )
/// 
/// </summary>

public string fnSceneObject_getForwardVector (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getForwardVector'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getForwardVector(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object's inverse transform.
///    @return the inverse transform of the object )
/// 
/// </summary>

public string fnSceneObject_getInverseTransform (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getInverseTransform'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getInverseTransform(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object mounted at a particular slot.
///    @param slot mount slot index to query
///    @return ID of the object mounted in the slot, or 0 if no object. )
/// 
/// </summary>

public int fnSceneObject_getMountedObject (string sceneobject, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getMountedObject'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,slot));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getMountedObject(sbsceneobject, slot);
}
/// <summary>
/// Get the number of objects mounted to us.
///    @return the number of mounted objects. )
/// 
/// </summary>

public int fnSceneObject_getMountedObjectCount (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getMountedObjectCount'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getMountedObjectCount(sbsceneobject);
}
/// <summary>
/// @brief Get the mount node index of the object mounted at our given slot.
///    @param slot mount slot index to query
///    @return index of the mount node used by the object mounted in this slot. )
/// 
/// </summary>

public int fnSceneObject_getMountedObjectNode (string sceneobject, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getMountedObjectNode'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,slot));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getMountedObjectNode(sbsceneobject, slot);
}
/// <summary>
/// @brief Get the object mounted at our given node index.
///    @param node mount node index to query
///    @return ID of the first object mounted at the node, or 0 if none found. )
/// 
/// </summary>

public int fnSceneObject_getMountNodeObject (string sceneobject, int node)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getMountNodeObject'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,node));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getMountNodeObject(sbsceneobject, node);
}
/// <summary>
/// Get the object's bounding box (relative to the object's origin).
///    @return six fields, two Point3Fs, containing the min and max points of the 
///    objectbox. )
/// 
/// </summary>

public string fnSceneObject_getObjectBox (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getObjectBox'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getObjectBox(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the object we are mounted to.
///    @return the SimObjectID of the object we're mounted to, or 0 if not mounted. )
/// 
/// </summary>

public int fnSceneObject_getObjectMount (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getObjectMount'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getObjectMount(sbsceneobject);
}
/// <summary>
/// Get the object's world position.
///    @return the current world position of the object )
/// 
/// </summary>

public string fnSceneObject_getPosition (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getPosition'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getPosition(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the right vector of the object.
///    @return a vector indicating the right direction of this object.
///    @note This is the object's x axis. )
/// 
/// </summary>

public string fnSceneObject_getRightVector (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getRightVector'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getRightVector(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object's scale.
///    @return object scale as a Point3F )
/// 
/// </summary>

public string fnSceneObject_getScale (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getScale'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getScale(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object's transform.
///    @return the current transform of the object )
/// 
/// </summary>

public string fnSceneObject_getTransform (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getTransform'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getTransform(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the type mask for this object.
///    @return The numeric type mask for the object. )
/// 
/// </summary>

public int fnSceneObject_getType (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getType'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_getType(sbsceneobject);
}
/// <summary>
/// Get the up vector of the object.
///    @return a vector indicating the up direction of this object.
///    @note This is the object's z axis. )
/// 
/// </summary>

public string fnSceneObject_getUpVector (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getUpVector'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getUpVector(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object's world bounding box.
///    @return six fields, two Point3Fs, containing the min and max points of the 
///    worldbox. )
/// 
/// </summary>

public string fnSceneObject_getWorldBox (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getWorldBox'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getWorldBox(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the center of the object's world bounding box.
///    @return the center of the world bounding box for this object. )
/// 
/// </summary>

public string fnSceneObject_getWorldBoxCenter (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_getWorldBoxCenter'" + string.Format("\"{0}\" ",sceneobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_getWorldBoxCenter(sbsceneobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Check if this object has a global bounds set.
///    If global bounds are set to be true, then the object is assumed to have an 
///    infinitely large bounding box for collision and rendering purposes.
///    @return true if the object has a global bounds. )
/// 
/// </summary>

public bool fnSceneObject_isGlobalBounds (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_isGlobalBounds'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_isGlobalBounds(sbsceneobject)>=1;
}
/// <summary>
/// @brief Check if we are mounted to another object.
///    @return true if mounted to another object, false if not mounted. )
/// 
/// </summary>

public bool fnSceneObject_isMounted (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_isMounted'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_isMounted(sbsceneobject)>=1;
}
/// <summary>
/// @brief Mount objB to this object at the desired slot with optional transform.
/// 
///    @param objB  Object to mount onto us
///    @param slot  Mount slot ID
///    @param txfm (optional) mount offset transform
///    @return true if successful, false if failed (objB is not valid) )
/// 
/// </summary>

public bool fnSceneObject_mountObject (string sceneobject, string objB, int slot, string txfm)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_mountObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",sceneobject,objB,slot,txfm));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbobjB = null;
if (objB != null)
     sbobjB = new StringBuilder(objB, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_mountObject(sbsceneobject, sbobjB, slot, sbtxfm)>=1;
}
/// <summary>
/// Set the object's scale.
///    @param scale object scale to set )
/// 
/// </summary>

public void fnSceneObject_setScale (string sceneobject, string scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_setScale'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,scale));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbscale = null;
if (scale != null)
     sbscale = new StringBuilder(scale, 1024);

SafeNativeMethods.mwle_fnSceneObject_setScale(sbsceneobject, sbscale);
}
/// <summary>
/// Set the object's transform (orientation and position).
///    @param txfm object transform to set )
/// 
/// </summary>

public void fnSceneObject_setTransform (string sceneobject, string txfm)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_setTransform'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,txfm));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);

SafeNativeMethods.mwle_fnSceneObject_setTransform(sbsceneobject, sbtxfm);
}
/// <summary>
/// @brief Adds a new counter or updates an existing counter to be tracked via ticks.
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnSceneObject_TickCounterAdd (string sceneobject, string countername, uint interval)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterAdd'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",sceneobject,countername,interval));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_TickCounterAdd(sbsceneobject, sbcountername, interval)>=1;
}
/// <summary>
/// @brief returns the interval for a counter.
///    @return true if successful, false if failed )
/// 
/// </summary>

public uint fnSceneObject_TickCounterGetInterval (string sceneobject, string countername)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterGetInterval'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,countername));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_TickCounterGetInterval(sbsceneobject, sbcountername);
}
/// <summary>
/// @brief Checks to see if the counter exists.
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnSceneObject_TickCounterHas (string sceneobject, string countername)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterHas'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,countername));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_TickCounterHas(sbsceneobject, sbcountername)>=1;
}
/// <summary>
/// @brief Removes a counter to be tracked via ticks.
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnSceneObject_TickCounterRemove (string sceneobject, string countername)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterRemove'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,countername));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_TickCounterRemove(sbsceneobject, sbcountername)>=1;
}
/// <summary>
/// @brief resets the current count for a counter.
///    @return true if successful, false if failed )
/// 
/// </summary>

public void fnSceneObject_TickCounterReset (string sceneobject, string countername)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterReset'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,countername));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

SafeNativeMethods.mwle_fnSceneObject_TickCounterReset(sbsceneobject, sbcountername);
}
/// <summary>
/// @brief Clears all counters from the object.)
///    
/// </summary>

public void fnSceneObject_TickCountersClear (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCountersClear'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_TickCountersClear(sbsceneobject);
}
/// <summary>
/// @brief Adds a new counter to be tracked via ticks.
///     )
/// 
/// </summary>

public void fnSceneObject_TickCounterSuspend (string sceneobject, string countername, bool suspend)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_TickCounterSuspend'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",sceneobject,countername,suspend));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbcountername = null;
if (countername != null)
     sbcountername = new StringBuilder(countername, 1024);

SafeNativeMethods.mwle_fnSceneObject_TickCounterSuspend(sbsceneobject, sbcountername, suspend);
}
/// <summary>
/// Unmount us from the currently mounted object if any. )
/// 
/// </summary>

public void fnSceneObject_unmount (string sceneobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_unmount'" + string.Format("\"{0}\" ",sceneobject));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);

SafeNativeMethods.mwle_fnSceneObject_unmount(sbsceneobject);
}
/// <summary>
/// @brief Unmount an object from ourselves.
/// 
///    @param target object to unmount
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnSceneObject_unmountObject (string sceneobject, string target)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSceneObject_unmountObject'" + string.Format("\"{0}\" \"{1}\" ",sceneobject,target));
StringBuilder sbsceneobject = null;
if (sceneobject != null)
     sbsceneobject = new StringBuilder(sceneobject, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

return  SafeNativeMethods.mwle_fnSceneObject_unmountObject(sbsceneobject, sbtarget)>=1;
}
/// <summary>
/// @brief Is this object wanting to receive tick notifications.
/// 
///    If this object is set to receive tick notifications then its onInterpolateTick() and 
///    onProcessTick() callbacks are called.
///    @return True if object wants tick notifications )
/// 
/// </summary>

public bool fnScriptTickObject_isProcessingTicks (string scripttickobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnScriptTickObject_isProcessingTicks'" + string.Format("\"{0}\" ",scripttickobject));
StringBuilder sbscripttickobject = null;
if (scripttickobject != null)
     sbscripttickobject = new StringBuilder(scripttickobject, 1024);

return  SafeNativeMethods.mwle_fnScriptTickObject_isProcessingTicks(sbscripttickobject)>=1;
}
/// <summary>
/// @brief Sets this object as either tick processing or not.
/// 
///    @param tick This object's onInterpolateTick() and onProcessTick() callbacks are called if set to true.)
/// 
/// </summary>

public void fnScriptTickObject_setProcessTicks (string scripttickobject, bool tick)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnScriptTickObject_setProcessTicks'" + string.Format("\"{0}\" \"{1}\" ",scripttickobject,tick));
StringBuilder sbscripttickobject = null;
if (scripttickobject != null)
     sbscripttickobject = new StringBuilder(scripttickobject, 1024);

SafeNativeMethods.mwle_fnScriptTickObject_setProcessTicks(sbscripttickobject, tick);
}
/// <summary>
/// (Settings, write, bool, 2, 2, %success = settingObj.write();)
/// 
/// </summary>

public bool fnSettings_write (string settings)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSettings_write'" + string.Format("\"{0}\" ",settings));
StringBuilder sbsettings = null;
if (settings != null)
     sbsettings = new StringBuilder(settings, 1024);

return  SafeNativeMethods.mwle_fnSettings_write(sbsettings)>=1;
}
/// <summary>
/// Get the index of the playlist slot currently processed by the controller.
///    @return The slot index currently being played.
///    @see SFXPlayList )
/// 
/// </summary>

public int fnSFXController_getCurrentSlot (string sfxcontroller)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXController_getCurrentSlot'" + string.Format("\"{0}\" ",sfxcontroller));
StringBuilder sbsfxcontroller = null;
if (sfxcontroller != null)
     sbsfxcontroller = new StringBuilder(sfxcontroller, 1024);

return  SafeNativeMethods.mwle_fnSFXController_getCurrentSlot(sbsfxcontroller);
}
/// <summary>
/// Set the index of the playlist slot to play by the controller.  This can be used to seek in the playlist.
///    @param index Index of the playlist slot. )
/// 
/// </summary>

public void fnSFXController_setCurrentSlot (string sfxcontroller, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXController_setCurrentSlot'" + string.Format("\"{0}\" \"{1}\" ",sfxcontroller,index));
StringBuilder sbsfxcontroller = null;
if (sfxcontroller != null)
     sbsfxcontroller = new StringBuilder(sfxcontroller, 1024);

SafeNativeMethods.mwle_fnSFXController_setCurrentSlot(sbsfxcontroller, index);
}
/// <summary>
/// Get the sound source object from the emitter.
///    @return The sound source used by the emitter or null.
///    @note This method will return null when called on the server-side SFXEmitter object.  Only client-side ghosts 
///       actually hold on to %SFXSources. )
/// 
/// </summary>

public string fnSFXEmitter_getSource (string sfxemitter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXEmitter_getSource'" + string.Format("\"{0}\" ",sfxemitter));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsfxemitter = null;
if (sfxemitter != null)
     sbsfxemitter = new StringBuilder(sfxemitter, 1024);

SafeNativeMethods.mwle_fnSFXEmitter_getSource(sbsfxemitter, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Manually start playback of the emitter's sound.
///    If this is called on the server-side object, the play command will be related to all client-side ghosts. )
/// 
/// </summary>

public void fnSFXEmitter_play (string sfxemitter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXEmitter_play'" + string.Format("\"{0}\" ",sfxemitter));
StringBuilder sbsfxemitter = null;
if (sfxemitter != null)
     sbsfxemitter = new StringBuilder(sfxemitter, 1024);

SafeNativeMethods.mwle_fnSFXEmitter_play(sbsfxemitter);
}
/// <summary>
/// Manually stop playback of the emitter's sound.
///    If this is called on the server-side object, the stop command will be related to all client-side ghosts. )
/// 
/// </summary>

public void fnSFXEmitter_stop (string sfxemitter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXEmitter_stop'" + string.Format("\"{0}\" ",sfxemitter));
StringBuilder sbsfxemitter = null;
if (sfxemitter != null)
     sbsfxemitter = new StringBuilder(sfxemitter, 1024);

SafeNativeMethods.mwle_fnSFXEmitter_stop(sbsfxemitter);
}
/// <summary>
/// Get the name of the parameter.
///    @return The paramete name. )
/// 
/// </summary>

public string fnSFXParameter_getParameterName (string sfxparameter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXParameter_getParameterName'" + string.Format("\"{0}\" ",sfxparameter));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsfxparameter = null;
if (sfxparameter != null)
     sbsfxparameter = new StringBuilder(sfxparameter, 1024);

SafeNativeMethods.mwle_fnSFXParameter_getParameterName(sbsfxparameter, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Reset the parameter's value to its default.
///    @see SFXParameter::defaultValue )
/// 
/// </summary>

public void fnSFXParameter_reset (string sfxparameter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXParameter_reset'" + string.Format("\"{0}\" ",sfxparameter));
StringBuilder sbsfxparameter = null;
if (sfxparameter != null)
     sbsfxparameter = new StringBuilder(sfxparameter, 1024);

SafeNativeMethods.mwle_fnSFXParameter_reset(sbsfxparameter);
}
/// <summary>
/// Return the length of the sound data in seconds.
///    @return The length of the sound data in seconds or 0 if the sound referenced by the profile could not be found. )
/// 
/// </summary>

public float fnSFXProfile_getSoundDuration (string sfxprofile)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXProfile_getSoundDuration'" + string.Format("\"{0}\" ",sfxprofile));
StringBuilder sbsfxprofile = null;
if (sfxprofile != null)
     sbsfxprofile = new StringBuilder(sfxprofile, 1024);

return  SafeNativeMethods.mwle_fnSFXProfile_getSoundDuration(sbsfxprofile);
}
/// <summary>
/// Get the total play time (in seconds) of the sound data attached to the sound.
///    @return 
///    @note Be aware that for looped sounds, this will not return the total playback time of the sound. )
/// 
/// </summary>

public float fnSFXSound_getDuration (string sfxsound)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSound_getDuration'" + string.Format("\"{0}\" ",sfxsound));
StringBuilder sbsfxsound = null;
if (sfxsound != null)
     sbsfxsound = new StringBuilder(sfxsound, 1024);

return  SafeNativeMethods.mwle_fnSFXSound_getDuration(sbsfxsound);
}
/// <summary>
/// Get the current playback position in seconds.
///    @return The current play cursor offset. )
/// 
/// </summary>

public float fnSFXSound_getPosition (string sfxsound)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSound_getPosition'" + string.Format("\"{0}\" ",sfxsound));
StringBuilder sbsfxsound = null;
if (sfxsound != null)
     sbsfxsound = new StringBuilder(sfxsound, 1024);

return  SafeNativeMethods.mwle_fnSFXSound_getPosition(sbsfxsound);
}
/// <summary>
/// Test whether the sound data associated with the sound has been fully loaded and is ready for playback.
///    For streamed sounds, this will be false during playback when the stream queue for the sound is starved and 
///    waiting for data.  For buffered sounds, only an initial loading phase will potentially cause isReady to 
///    return false.
///    @return True if the sound is ready for playback. )
/// 
/// </summary>

public bool fnSFXSound_isReady (string sfxsound)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSound_isReady'" + string.Format("\"{0}\" ",sfxsound));
StringBuilder sbsfxsound = null;
if (sfxsound != null)
     sbsfxsound = new StringBuilder(sfxsound, 1024);

return  SafeNativeMethods.mwle_fnSFXSound_isReady(sbsfxsound)>=1;
}
/// <summary>
/// Set the current playback position in seconds.
///    If the source is currently playing, playback will jump to the new position.  If playback is stopped or paused, 
///    playback will resume at the given position when play() is called.
///    @param position The new position of the play cursor (in seconds). )
/// 
/// </summary>

public void fnSFXSound_setPosition (string sfxsound, float position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSound_setPosition'" + string.Format("\"{0}\" \"{1}\" ",sfxsound,position));
StringBuilder sbsfxsound = null;
if (sfxsound != null)
     sbsfxsound = new StringBuilder(sfxsound, 1024);

SafeNativeMethods.mwle_fnSFXSound_setPosition(sbsfxsound, position);
}
/// <summary>
/// Add a notification marker called @a name at @a pos seconds of playback.
///    @param name Symbolic name for the marker that will be passed to the onMarkerPassed() callback.
///    @param pos Playback position in seconds when the notification should trigger.  Note that this is a soft limit and there 
///       may be a delay between the play cursor actually passing the position and the callback being triggered.
///    @note For looped sounds, the marker will trigger on each iteration.
///    @tsexample
///    // Create a new source.
///    $source = sfxCreateSource( AudioMusicLoop2D, \"art/sound/backgroundMusic\" );
///    
///    // Assign a class to the source.
///    $source.class = \"BackgroundMusic\";
///    
///    // Add a playback marker at one minute into playback.
///    $source.addMarker( \"first\", 60 );
///    
///    // Define the callback function.  This function will be called when the playback position passes the one minute mark.
///    function BackgroundMusic::onMarkerPassed( %this, %markerName )
///    {
///       if( %markerName $= \"first\" )
///          echo( \"Playback has passed the 60 seconds mark.\" );
///    }
///    
///    // Play the sound.
///    $source.play();
///    @endtsexample )
/// 
/// </summary>

public void fnSFXSource_addMarker (string sfxsource, string name, float pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_addMarker'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",sfxsource,name,pos));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnSFXSource_addMarker(sbsfxsource, sbname, pos);
}
/// <summary>
/// Attach @a parameter to the source,
///    Once attached, the source will react to value changes of the given @a parameter.  Attaching a parameter 
///    will also trigger an initial read-out of the parameter's current value.
///    @param parameter The parameter to attach to the source. )
/// 
/// </summary>

public void fnSFXSource_addParameter (string sfxsource, string parameter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_addParameter'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,parameter));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);
StringBuilder sbparameter = null;
if (parameter != null)
     sbparameter = new StringBuilder(parameter, 1024);

SafeNativeMethods.mwle_fnSFXSource_addParameter(sbsfxsource, sbparameter);
}
/// <summary>
/// Get the final effective volume level of the source.
///    This method returns the volume level as it is after source group volume modulation, fades, and distance-based 
///    volume attenuation have been applied to the base volume level.
///    @return The effective volume of the source.
///    @ref SFXSource_volume )
/// 
/// </summary>

public float fnSFXSource_getAttenuatedVolume (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getAttenuatedVolume'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getAttenuatedVolume(sbsfxsource);
}
/// <summary>
/// Get the fade-in time set on the source.
///    This will initially be SFXDescription::fadeInTime.
///    @return The fade-in time set on the source in seconds.
///    @see SFXDescription::fadeInTime
///    @ref SFXSource_fades )
/// 
/// </summary>

public float fnSFXSource_getFadeInTime (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getFadeInTime'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getFadeInTime(sbsfxsource);
}
/// <summary>
/// Get the fade-out time set on the source.
///    This will initially be SFXDescription::fadeOutTime.
///    @return The fade-out time set on the source in seconds.
///    @see SFXDescription::fadeOutTime
///    @ref SFXSource_fades )
/// 
/// </summary>

public float fnSFXSource_getFadeOutTime (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getFadeOutTime'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getFadeOutTime(sbsfxsource);
}
/// <summary>
/// Get the parameter at the given index.
///    @param index Index of the parameter to fetch.  Must be 0=index=getParameterCount().
///    @return The parameter at the given @a index or null if @a index is out of range.
///    @tsexample
///       // Print the name ofo each parameter attached to %source.
///       %numParams = %source.getParameterCount();
///       for( %i = 0; %i  %numParams; %i ++ )
///          echo( %source.getParameter( %i ).getParameterName() );
///    @endtsexample
///    @see getParameterCount )
/// 
/// </summary>

public string fnSFXSource_getParameter (string sfxsource, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getParameter'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_getParameter(sbsfxsource, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of SFXParameters that are attached to the source.
///    @return The number of parameters attached to the source.
///    @tsexample
///       // Print the name ofo each parameter attached to %source.
///       %numParams = %source.getParameterCount();
///       for( %i = 0; %i  %numParams; %i ++ )
///          echo( %source.getParameter( %i ).getParameterName() );
///    @endtsexample
///    @see getParameter
///    @see addParameter )
/// 
/// </summary>

public int fnSFXSource_getParameterCount (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getParameterCount'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getParameterCount(sbsfxsource);
}
/// <summary>
/// Get the pitch scale of the source.
///    Pitch determines the playback speed of the source (default: 1).
///    @return The current pitch scale factor of the source.
///    @see setPitch
///    @see SFXDescription::pitch )
/// 
/// </summary>

public float fnSFXSource_getPitch (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getPitch'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getPitch(sbsfxsource);
}
/// <summary>
/// Get the current playback status.
///    @return Te current playback status )
/// 
/// </summary>

public int fnSFXSource_getStatus (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getStatus'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getStatus(sbsfxsource);
}
/// <summary>
/// Get the current base volume level of the source.
///    This is not the final effective volume that the source is playing at but rather the starting 
///    volume level before source group modulation, fades, or distance-based volume attenuation are applied.
///    @return The current base volume level.
///    @see setVolume
///    @see SFXDescription::volume
///    @ref SFXSource_volume )
/// 
/// </summary>

public float fnSFXSource_getVolume (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_getVolume'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_getVolume(sbsfxsource);
}
/// <summary>
/// Test whether the source is currently paused.
///    @return True if the source is in paused state, false otherwise.
///    @see pause
///    @see getStatus
///    @see SFXStatus )
/// 
/// </summary>

public bool fnSFXSource_isPaused (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_isPaused'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_isPaused(sbsfxsource)>=1;
}
/// <summary>
/// Test whether the source is currently playing.
///    @return True if the source is in playing state, false otherwise.
///    @see play
///    @see getStatus
///    @see SFXStatus )
/// 
/// </summary>

public bool fnSFXSource_isPlaying (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_isPlaying'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_isPlaying(sbsfxsource)>=1;
}
/// <summary>
/// Test whether the source is currently stopped.
///    @return True if the source is in stopped state, false otherwise.
///    @see stop
///    @see getStatus
///    @see SFXStatus )
/// 
/// </summary>

public bool fnSFXSource_isStopped (string sfxsource)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_isStopped'" + string.Format("\"{0}\" ",sfxsource));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

return  SafeNativeMethods.mwle_fnSFXSource_isStopped(sbsfxsource)>=1;
}
/// <summary>
/// Pause playback of the source.
///    @param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime 
///       set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be 
///       configured on the description.
///       Be aware that if a fade-out effect is used, the source will not immediately to paused state but will 
///       rather remain in playing state until the fade-out time has expired.. )
/// 
/// </summary>

public void fnSFXSource_pause (string sfxsource, float fadeOutTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_pause'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,fadeOutTime));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_pause(sbsfxsource, fadeOutTime);
}
/// <summary>
/// Start playback of the source.
///    If the sound data for the source has not yet been fully loaded, there will be a delay after calling 
///    play and playback will start after the data has become available.
///    @param fadeInTime Seconds for the sound to reach full volume.  If -1, the SFXDescription::fadeInTime 
///       set in the source's associated description is used.  Pass 0 to disable a fade-in effect that may 
///       be configured on the description. )
/// 
/// </summary>

public void fnSFXSource_play (string sfxsource, float fadeInTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_play'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,fadeInTime));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_play(sbsfxsource, fadeInTime);
}
/// <summary>
/// Detach @a parameter from the source.
///    Once detached, the source will no longer react to value changes of the given @a parameter.
///    If the parameter is not attached to the source, the method will do nothing.
///    @param parameter The parameter to detach from the source. )
/// 
/// </summary>

public void fnSFXSource_removeParameter (string sfxsource, string parameter)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_removeParameter'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,parameter));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);
StringBuilder sbparameter = null;
if (parameter != null)
     sbparameter = new StringBuilder(parameter, 1024);

SafeNativeMethods.mwle_fnSFXSource_removeParameter(sbsfxsource, sbparameter);
}
/// <summary>
/// Set up the 3D volume cone for the source.
///    @param innerAngle Angle of the inner sound cone in degrees (@ref SFXDescription::coneInsideAngle).  Must be 0=innerAngle=360.
///    @param outerAngle Angle of the outer sound cone in degrees (@ref SFXDescription::coneOutsideAngle).  Must be 0=outerAngle=360.
///    @param outsideVolume Volume scale factor outside of outer cone (@ref SFXDescription::coneOutsideVolume).  Must be 0=outsideVolume=1.
///    @note This method has no effect on the source if the source is not 3D. )
/// 
/// </summary>

public void fnSFXSource_setCone (string sfxsource, float innerAngle, float outerAngle, float outsideVolume)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_setCone'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",sfxsource,innerAngle,outerAngle,outsideVolume));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_setCone(sbsfxsource, innerAngle, outerAngle, outsideVolume);
}
/// <summary>
/// Set the fade time parameters of the source.
///    @param fadeInTime The new fade-in time in seconds.
///    @param fadeOutTime The new fade-out time in seconds.
///    @see SFXDescription::fadeInTime
///    @see SFXDescription::fadeOutTime
///    @ref SFXSource_fades )
/// 
/// </summary>

public void fnSFXSource_setFadeTimes (string sfxsource, float fadeInTime, float fadeOutTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_setFadeTimes'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",sfxsource,fadeInTime,fadeOutTime));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_setFadeTimes(sbsfxsource, fadeInTime, fadeOutTime);
}
/// <summary>
/// Set the pitch scale of the source.
///    Pitch determines the playback speed of the source (default: 1).
///    @param pitch The new pitch scale factor.
///    @see getPitch
///    @see SFXDescription::pitch )
/// 
/// </summary>

public void fnSFXSource_setPitch (string sfxsource, float pitch)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_setPitch'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,pitch));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_setPitch(sbsfxsource, pitch);
}
/// <summary>
/// Set the base volume level for the source.
///    This volume will be the starting point for source group volume modulation, fades, and distance-based 
///    volume attenuation.
///    @param volume The new base volume level for the source.  Must be 0>=volume=1.
///    @see getVolume
///    @ref SFXSource_volume )
/// 
/// </summary>

public void fnSFXSource_setVolume (string sfxsource, float volume)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_setVolume'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,volume));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_setVolume(sbsfxsource, volume);
}
/// <summary>
/// Stop playback of the source.
///    @param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime 
///       set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be 
///       configured on the description.
///       Be aware that if a fade-out effect is used, the source will not immediately transtion to stopped state but 
///       will rather remain in playing state until the fade-out time has expired. )
/// 
/// </summary>

public void fnSFXSource_stop (string sfxsource, float fadeOutTime)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXSource_stop'" + string.Format("\"{0}\" \"{1}\" ",sfxsource,fadeOutTime));
StringBuilder sbsfxsource = null;
if (sfxsource != null)
     sbsfxsource = new StringBuilder(sfxsource, 1024);

SafeNativeMethods.mwle_fnSFXSource_stop(sbsfxsource, fadeOutTime);
}
/// <summary>
/// Increase the activation count on the state.
///    If the state isn't already active and it is not disabled, the state will be activated.
///    @see isActive
///    @see deactivate )
/// 
/// </summary>

public void fnSFXState_activate (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_activate'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

SafeNativeMethods.mwle_fnSFXState_activate(sbsfxstate);
}
/// <summary>
/// Decrease the activation count on the state.
///    If the count reaches zero and the state was not disabled, the state will be deactivated.
///    @see isActive
///    @see activate )
/// 
/// </summary>

public void fnSFXState_deactivate (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_deactivate'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

SafeNativeMethods.mwle_fnSFXState_deactivate(sbsfxstate);
}
/// <summary>
/// Increase the disabling count of the state.
///    If the state is currently active, it will be deactivated.
///    @see isDisabled )
/// 
/// </summary>

public void fnSFXState_disable (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_disable'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

SafeNativeMethods.mwle_fnSFXState_disable(sbsfxstate);
}
/// <summary>
/// Decrease the disabling count of the state.
///    If the disabling count reaches zero while the activation count is still non-zero, 
///       the state will be reactivated again.
///    @see isDisabled )
/// 
/// </summary>

public void fnSFXState_enable (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_enable'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

SafeNativeMethods.mwle_fnSFXState_enable(sbsfxstate);
}
/// <summary>
/// Test whether the state is currently active.
///    This is true when the activation count is >0 and the disabling count is =0.
///    @return True if the state is currently active.
///    @see activate )
/// 
/// </summary>

public bool fnSFXState_isActive (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_isActive'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

return  SafeNativeMethods.mwle_fnSFXState_isActive(sbsfxstate)>=1;
}
/// <summary>
/// Test whether the state is currently disabled.
///    This is true when the disabling count of the state is non-zero.
///    @return True if the state is disabled.
///    @see disable )
/// 
/// </summary>

public bool fnSFXState_isDisabled (string sfxstate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSFXState_isDisabled'" + string.Format("\"{0}\" ",sfxstate));
StringBuilder sbsfxstate = null;
if (sfxstate != null)
     sbsfxstate = new StringBuilder(sfxstate, 1024);

return  SafeNativeMethods.mwle_fnSFXState_isDisabled(sbsfxstate)>=1;
}
/// <summary>
/// @brief Rebuilds all the vertex and pixel shader instances created from this ShaderData.
/// 
/// 				   @tsexample
/// 				   // Rebuild the shader instances from ShaderData CloudLayerShader
/// 				   CloudLayerShader.reload();
/// 				   @endtsexample)
/// 
/// </summary>

public void fnShaderData_reload (string shaderdata)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShaderData_reload'" + string.Format("\"{0}\" ",shaderdata));
StringBuilder sbshaderdata = null;
if (shaderdata != null)
     sbshaderdata = new StringBuilder(shaderdata, 1024);

SafeNativeMethods.mwle_fnShaderData_reload(sbshaderdata);
}
/// <summary>
/// @brief Increment the current damage level by the specified amount.
/// 
///    @param amount value to add to current damage level )
/// 
/// </summary>

public void fnShapeBase_applyDamage (string shapebase, float amount)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_applyDamage'" + string.Format("\"{0}\" \"{1}\" ",shapebase,amount));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_applyDamage(sbshapebase, amount);
}
/// <summary>
/// @brief Apply an impulse to the object.
/// 
///    @param pos world position of the impulse
///    @param vec impulse momentum (velocity * mass)
///    @return true )
/// 
/// </summary>

public bool fnShapeBase_applyImpulse (string shapebase, string pos, string vec)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_applyImpulse'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,pos,vec));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbvec = null;
if (vec != null)
     sbvec = new StringBuilder(vec, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_applyImpulse(sbshapebase, sbpos, sbvec)>=1;
}
/// <summary>
/// @brief Repair damage by the specified amount.
/// 
///    Note that the damage level is only reduced by repairRate per tick, so it may 
///    take several ticks for the total repair to complete.
/// 
///    @param amount total repair value (subtracted from damage level over time) )
/// 
/// </summary>

public void fnShapeBase_applyRepair (string shapebase, float amount)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_applyRepair'" + string.Format("\"{0}\" \"{1}\" ",shapebase,amount));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_applyRepair(sbshapebase, amount);
}
/// <summary>
/// @brief Explodes an object into pieces.)
/// 
/// </summary>

public void fnShapeBase_blowUp (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_blowUp'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_blowUp(sbshapebase);
}
/// <summary>
/// @brief Check if this object can cloak.
///    @return true
///    
///    @note Not implemented as it always returns true.)
/// 
/// </summary>

public bool fnShapeBase_canCloak (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_canCloak'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_canCloak(sbshapebase)>=1;
}
/// <summary>
/// @brief Change one of the materials on the shape.
/// 
///    This method changes materials per mapTo with others. The material that 
///    is being replaced is mapped to unmapped_mat as a part of this transition.
/// 
///    @note Warning, right now this only sort of works. It doesn't do a live 
///    update like it should.
/// 
///    @param mapTo the name of the material target to remap (from getTargetName)
///    @param oldMat the old Material that was mapped 
///    @param newMat the new Material to map
/// 
///    @tsexample
///    // remap the first material in the shape
///    %mapTo = %obj.getTargetName( 0 );
///    %obj.changeMaterial( %mapTo, 0, MyMaterial );
///    @endtsexample )
/// 
/// </summary>

public void fnShapeBase_changeMaterial (string shapebase, string mapTo, string oldMat, string newMat)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_changeMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",shapebase,mapTo,oldMat,newMat));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbmapTo = null;
if (mapTo != null)
     sbmapTo = new StringBuilder(mapTo, 1024);
StringBuilder sboldMat = null;
if (oldMat != null)
     sboldMat = new StringBuilder(oldMat, 1024);
StringBuilder sbnewMat = null;
if (newMat != null)
     sbnewMat = new StringBuilder(newMat, 1024);

SafeNativeMethods.mwle_fnShapeBase_changeMaterial(sbshapebase, sbmapTo, sboldMat, sbnewMat);
}
/// <summary>
/// @brief Destroy an animation thread, which prevents it from playing.
/// 
///    @param slot thread slot to destroy
///    @return true if successful, false if failed
///    
///    @see playThread )
/// 
/// </summary>

public bool fnShapeBase_destroyThread (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_destroyThread'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_destroyThread(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Print a list of visible and hidden meshes in the shape to the console 
///    for debugging purposes.
///    @note Only in a SHIPPING build.)
/// 
/// </summary>

public void fnShapeBase_dumpMeshVisibility (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_dumpMeshVisibility'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_dumpMeshVisibility(sbshapebase);
}
/// <summary>
/// @brief Get the position at which the AI should stand to repair things.
/// 
///    If the shape defines a node called \"AIRepairNode\", this method will 
///    return the current world position of that node, otherwise \"0 0 0\".
///    @return the AI repair position )
/// 
/// </summary>

public string fnShapeBase_getAIRepairPoint (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getAIRepairPoint'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getAIRepairPoint(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the vertical field of view in degrees for this object if used as a camera.
/// 
///    @return current FOV as defined in ShapeBaseData::cameraDefaultFov )
/// 
/// </summary>

public float fnShapeBase_getCameraFov (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getCameraFov'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getCameraFov(sbshapebase);
}
/// <summary>
/// @brief Get the client (if any) that controls this object.
/// 
///    The controlling client is the one that will send moves to us to act on.
/// 
///    @return the ID of the controlling GameConnection, or 0 if this object is not 
///    controlled by any client.
///    
///    @see GameConnection)
/// 
/// </summary>

public int fnShapeBase_getControllingClient (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getControllingClient'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getControllingClient(sbshapebase);
}
/// <summary>
/// @brief Get the object (if any) that controls this object.
/// 
///    @return the ID of the controlling ShapeBase object, or 0 if this object is 
///    not controlled by another object. )
/// 
/// </summary>

public int fnShapeBase_getControllingObject (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getControllingObject'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getControllingObject(sbshapebase);
}
/// <summary>
/// @brief Get the damage flash level.
/// 
///    @return flash level
/// 
///    @see setDamageFlash )
/// 
/// </summary>

public float fnShapeBase_getDamageFlash (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getDamageFlash'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getDamageFlash(sbshapebase);
}
/// <summary>
/// @brief Get the object's current damage level.
/// 
///    @return damage level
///    
///    @see setDamageLevel())
/// 
/// </summary>

public float fnShapeBase_getDamageLevel (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getDamageLevel'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getDamageLevel(sbshapebase);
}
/// <summary>
/// @brief Get the object's current damage level as a percentage of maxDamage.
/// 
///    @return damageLevel / datablock.maxDamage
///    
///    @see setDamageLevel())
/// 
/// </summary>

public float fnShapeBase_getDamagePercent (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getDamagePercent'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getDamagePercent(sbshapebase);
}
/// <summary>
/// @brief Get the object's damage state.
/// 
///    @return the damage state; one of \"Enabled\", \"Disabled\", \"Destroyed\"
///    
///    @see setDamageState())
/// 
/// </summary>

public string fnShapeBase_getDamageState (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getDamageState'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getDamageState(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Returns the default vertical field of view in degrees for this object if used as a camera.
/// 
///    @return Default FOV )
/// 
/// </summary>

public float fnShapeBase_getDefaultCameraFov (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getDefaultCameraFov'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getDefaultCameraFov(sbshapebase);
}
/// <summary>
/// @brief Get the object's current energy level.
/// 
///    @return energy level
///    
///    @see setEnergyLevel())
/// 
/// </summary>

public float fnShapeBase_getEnergyLevel (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getEnergyLevel'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getEnergyLevel(sbshapebase);
}
/// <summary>
/// @brief Get the object's current energy level as a percentage of maxEnergy.
///    @return energyLevel / datablock.maxEnergy
/// 
///    @see setEnergyLevel())
/// 
/// </summary>

public float fnShapeBase_getEnergyPercent (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getEnergyPercent'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getEnergyPercent(sbshapebase);
}
/// <summary>
/// @brief Get the position of the 'eye' for this object.
/// 
///    If the object model has a node called 'eye', this method will return that 
///    node's current world position, otherwise it will return the object's current 
///    world position.
/// 
///    @return the eye position for this object
/// 
///    @see getEyeVector
///    @see getEyeTransform )
/// 
/// </summary>

public string fnShapeBase_getEyePoint (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getEyePoint'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getEyePoint(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the 'eye' transform for this object.
/// 
///    If the object model has a node called 'eye', this method will return that 
///    node's current transform, otherwise it will return the object's current 
///    transform.
/// 
///    @return the eye transform for this object
/// 
///    @see getEyeVector
///    @see getEyePoint )
/// 
/// </summary>

public string fnShapeBase_getEyeTransform (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getEyeTransform'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getEyeTransform(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the forward direction of the 'eye' for this object.
/// 
///    If the object model has a node called 'eye', this method will return that 
///    node's current forward direction vector, otherwise it will return the 
///    object's current forward direction vector.
/// 
///    @return the eye vector for this object
/// 
///    @see getEyePoint
///    @see getEyeTransform )
/// 
/// </summary>

public string fnShapeBase_getEyeVector (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getEyeVector'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getEyeVector(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the alt trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current alt trigger state )
/// 
/// </summary>

public bool fnShapeBase_getImageAltTrigger (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageAltTrigger'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageAltTrigger(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Get the ammo state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current ammo state )
/// 
/// </summary>

public bool fnShapeBase_getImageAmmo (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageAmmo'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageAmmo(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Get the generic trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @param trigger Generic trigger number
///    @return the Image's current generic trigger state )
/// 
/// </summary>

public bool fnShapeBase_getImageGenericTrigger (string shapebase, int slot, int trigger)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageGenericTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,trigger));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageGenericTrigger(sbshapebase, slot, trigger)>=1;
}
/// <summary>
/// @brief Get the loaded state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current loaded state )
/// 
/// </summary>

public bool fnShapeBase_getImageLoaded (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageLoaded'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageLoaded(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Get the script animation prefix of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current script animation prefix )
/// 
/// </summary>

public string fnShapeBase_getImageScriptAnimPrefix (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageScriptAnimPrefix'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getImageScriptAnimPrefix(sbshapebase, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the skin tag ID for the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the skinTag value passed to mountImage when the image was 
///    mounted )
/// 
/// </summary>

public int fnShapeBase_getImageSkinTag (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageSkinTag'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageSkinTag(sbshapebase, slot);
}
/// <summary>
/// @brief Get the name of the current state of the Image in the specified slot.
/// 
///    @param slot Image slot to query
///    @return name of the current Image state, or \"Error\" if slot is invalid )
/// 
/// </summary>

public string fnShapeBase_getImageState (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageState'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getImageState(sbshapebase, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the target state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current target state )
/// 
/// </summary>

public bool fnShapeBase_getImageTarget (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageTarget'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageTarget(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Get the trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return the Image's current trigger state )
/// 
/// </summary>

public bool fnShapeBase_getImageTrigger (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getImageTrigger'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getImageTrigger(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Get the world position this object is looking at.
/// 
///    Casts a ray from the eye and returns information about what the ray hits.
/// 
///    @param distance maximum distance of the raycast
///    @param typeMask typeMask of objects to include for raycast collision testing
///    @return look-at information as \"Object HitX HitY HitZ [Material]\" or empty string for no hit
/// 
///    @tsexample
///    %lookat = %obj.getLookAtPoint();
///    echo( \"Looking at: \" @ getWords( %lookat, 1, 3 ) );
///    @endtsexample )
/// 
/// </summary>

public string fnShapeBase_getLookAtPoint (string shapebase, float distance, uint typeMask)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getLookAtPoint'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,distance,typeMask));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getLookAtPoint(sbshapebase, distance, typeMask, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the object's maxDamage level.  
///    @return datablock.maxDamage)    
/// 
/// </summary>

public float fnShapeBase_getMaxDamage (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getMaxDamage'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getMaxDamage(sbshapebase);
}
/// <summary>
/// @brief Get the model filename used by this shape.
/// 
///    @return the shape filename )
/// 
/// </summary>

public string fnShapeBase_getModelFile (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getModelFile'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getModelFile(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the Image mounted in the specified slot.
/// 
///    @param slot Image slot to query
///    @return ID of the ShapeBaseImageData datablock mounted in the slot, or 0 
///    if no Image is mounted there. )
/// 
/// </summary>

public int fnShapeBase_getMountedImage (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getMountedImage'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getMountedImage(sbshapebase, slot);
}
/// <summary>
/// @brief Get the first slot the given datablock is mounted to on this object.
/// 
///    @param image ShapeBaseImageData datablock to query
///    @return index of the first slot the Image is mounted in, or -1 if the Image 
///    is not mounted in any slot on this object. )
/// 
/// 
/// </summary>

public int fnShapeBase_getMountSlot (string shapebase, string image)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getMountSlot'" + string.Format("\"{0}\" \"{1}\" ",shapebase,image));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbimage = null;
if (image != null)
     sbimage = new StringBuilder(image, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getMountSlot(sbshapebase, sbimage);
}
/// <summary>
/// @brief Get the muzzle position of the Image mounted in the specified slot.
/// 
///    If the Image shape contains a node called 'muzzlePoint', then the muzzle 
///    position is the position of that node in world space. If no such node 
///    is specified, the slot's mount node is used instead.
/// 
///    @param slot Image slot to query
///    @return the muzzle position, or \"0 0 0\" if the slot is invalid )
/// 
/// </summary>

public string fnShapeBase_getMuzzlePoint (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getMuzzlePoint'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getMuzzlePoint(sbshapebase, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the muzzle vector of the Image mounted in the specified slot.
/// 
///    If the Image shape contains a node called 'muzzlePoint', then the muzzle 
///    vector is the forward direction vector of that node's transform in world 
///    space. If no such node is specified, the slot's mount node is used 
///    instead.
/// 
///    If the correctMuzzleVector flag (correctMuzzleVectorTP in 3rd person) 
///    is set in the Image, the muzzle vector is computed to point at whatever 
///    object is right in front of the object's 'eye' node.
/// 
///    @param slot Image slot to query
///    @return the muzzle vector, or \"0 1 0\" if the slot is invalid )
/// 
/// </summary>

public string fnShapeBase_getMuzzleVector (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getMuzzleVector'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getMuzzleVector(sbshapebase, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the Image that will be mounted next in the specified slot.
/// 
///    Calling mountImage when an Image is already mounted does one of two things: 
///    ol>li>Mount the new Image immediately, the old Image is discarded and 
///    whatever state it was in is ignored./li>
///    li>If the current Image state does not allow Image changes, the new 
///    Image is marked as pending, and will not be mounted until the current 
///    state completes. eg. if the user changes weapons, you may wish to ensure 
///    that the current weapon firing state plays to completion first./li>/ol>
///    This command retrieves the ID of the pending Image (2nd case above).
///    
///    @param slot Image slot to query
///    @return ID of the pending ShapeBaseImageData datablock, or 0 if none. )
/// 
/// </summary>

public int fnShapeBase_getPendingImage (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getPendingImage'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getPendingImage(sbshapebase, slot);
}
/// <summary>
/// @brief Get the current recharge rate.
/// 
///    @return the recharge rate (per tick)
///    
///    @see setRechargeRate())
/// 
/// </summary>

public float fnShapeBase_getRechargeRate (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getRechargeRate'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getRechargeRate(sbshapebase);
}
/// <summary>
/// @brief Get the per-tick repair amount.
/// 
///    @return the current value to be subtracted from damage level each tick
/// 
///    @see setRepairRate )
/// 
/// </summary>

public float fnShapeBase_getRepairRate (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getRepairRate'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getRepairRate(sbshapebase);
}
/// <summary>
/// @brief Get the name of the shape.
/// 
///    @note This is the name of the shape object that is sent to the client, 
///    not the DTS or DAE model filename.
/// 
///    @return the name of the shape 
///    
///    @see setShapeName())
/// 
/// </summary>

public string fnShapeBase_getShapeName (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getShapeName'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getShapeName(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the name of the skin applied to this shape.
/// 
///    @return the name of the skin 
/// 
///    @see skin
///    @see setSkinName())
/// 
/// </summary>

public string fnShapeBase_getSkinName (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getSkinName'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getSkinName(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the world transform of the specified mount slot.
/// 
///    @param slot Image slot to query
///    @return the mount transform )
/// 
/// </summary>

public string fnShapeBase_getSlotTransform (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getSlotTransform'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getSlotTransform(sbshapebase, slot, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the number of materials in the shape.
/// 
///    @return the number of materials in the shape. 
///    
///    @see getTargetName())
/// 
/// </summary>

public int fnShapeBase_getTargetCount (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getTargetCount'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getTargetCount(sbshapebase);
}
/// <summary>
/// @brief Get the name of the indexed shape material.
/// 
///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
///    @return the name of the indexed material.
///    
///    @see getTargetCount())
/// 
/// </summary>

public string fnShapeBase_getTargetName (string shapebase, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getTargetName'" + string.Format("\"{0}\" \"{1}\" ",shapebase,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getTargetName(sbshapebase, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the object's current velocity.
/// 
///    @return the current velocity )
/// 
/// </summary>

public string fnShapeBase_getVelocity (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getVelocity'" + string.Format("\"{0}\" ",shapebase));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_getVelocity(sbshapebase, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the white-out level.
/// 
///    @return white-out level
/// 
///    @see setWhiteOut )
/// 
/// </summary>

public float fnShapeBase_getWhiteOut (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_getWhiteOut'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_getWhiteOut(sbshapebase);
}
/// <summary>
/// @brief Check if the given state exists on the mounted Image.
/// 
///    @param slot Image slot to query
///    @param state Image state to check for
///    @return true if the Image has the requested state defined. )
/// 
/// </summary>

public bool fnShapeBase_hasImageState (string shapebase, int slot, string state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_hasImageState'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbstate = null;
if (state != null)
     sbstate = new StringBuilder(state, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_hasImageState(sbshapebase, slot, sbstate)>=1;
}
/// <summary>
/// @brief Check if this object is cloaked.
/// 
///    @return true if cloaked, false if not 
///    
///    @see setCloaked())
/// 
/// </summary>

public bool fnShapeBase_isCloaked (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isCloaked'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isCloaked(sbshapebase)>=1;
}
/// <summary>
/// @brief Check if the object is in the Destroyed damage state.
/// 
///    @return true if damage state is \"Destroyed\", false if not 
///    
///    @see isDisabled()
///    @see isEnabled())
/// 
/// </summary>

public bool fnShapeBase_isDestroyed (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isDestroyed'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isDestroyed(sbshapebase)>=1;
}
/// <summary>
/// @brief Check if the object is in the Disabled or Destroyed damage state.
/// 
///    @return true if damage state is not \"Enabled\", false if it is
///    
///    @see isDestroyed()
///    @see isEnabled())
/// 
/// </summary>

public bool fnShapeBase_isDisabled (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isDisabled'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isDisabled(sbshapebase)>=1;
}
/// <summary>
/// @brief Check if the object is in the Enabled damage state.
/// 
///    @return true if damage state is \"Enabled\", false if not
///    
///    @see isDestroyed()
///    @see isDisabled())
/// 
/// </summary>

public bool fnShapeBase_isEnabled (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isEnabled'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isEnabled(sbshapebase)>=1;
}
/// <summary>
/// Check if the object is hidden.
///    @return true if the object is hidden, false if visible. )
/// 
/// </summary>

public bool fnShapeBase_isHidden (string shapebase)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isHidden'" + string.Format("\"{0}\" ",shapebase));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isHidden(sbshapebase)>=1;
}
/// <summary>
/// @brief Check if the current Image state is firing.
/// 
///    @param slot Image slot to query
///    @return true if the current Image state in this slot has the 'stateFire' flag set. )
/// 
/// </summary>

public bool fnShapeBase_isImageFiring (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isImageFiring'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isImageFiring(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Check if the given datablock is mounted to any slot on this object.
/// 
///    @param image ShapeBaseImageData datablock to query
///    @return true if the Image is mounted to any slot, false otherwise. )
/// 
/// </summary>

public bool fnShapeBase_isImageMounted (string shapebase, string image)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_isImageMounted'" + string.Format("\"{0}\" \"{1}\" ",shapebase,image));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbimage = null;
if (image != null)
     sbimage = new StringBuilder(image, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_isImageMounted(sbshapebase, sbimage)>=1;
}
/// <summary>
///  ),
///    @brief Mount a new Image.
/// 
///    @param image the Image to mount
///    @param slot Image slot to mount into (valid range is 0 - 3)
///    @param loaded initial loaded state for the Image
///    @param skinTag tagged string to reskin the mounted Image
///    @return true if successful, false if failed
/// 
///    @tsexample
///    %player.mountImage( PistolImage, 1 );
///    %player.mountImage( CrossbowImage, 0, false );
///    %player.mountImage( RocketLauncherImage, 0, true, 'blue' );
///    @endtsexample
///    
///    @see unmountImage()
///    @see getMountedImage()
///    @see getPendingImage()
///    @see isImageMounted())
/// 
/// </summary>

public bool fnShapeBase_mountImage (string shapebase, string image, int slot, bool loaded, string skinTag)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_mountImage'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",shapebase,image,slot,loaded,skinTag));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbimage = null;
if (image != null)
     sbimage = new StringBuilder(image, 1024);
StringBuilder sbskinTag = null;
if (skinTag != null)
     sbskinTag = new StringBuilder(skinTag, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_mountImage(sbshapebase, sbimage, slot, loaded, sbskinTag)>=1;
}
/// <summary>
/// @brief Pause an animation thread.
///    
///    If restarted using playThread, the animation 
///    will resume from the paused position.
///    @param slot thread slot to stop
///    @return true if successful, false if failed
///    
///    @see playThread )
/// 
/// </summary>

public bool fnShapeBase_pauseThread (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_pauseThread'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_pauseThread(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Attach a sound to this shape and start playing it.
/// 
///    @param slot Audio slot index for the sound (valid range is 0 - 3)    @param track SFXTrack to play
///    @return true if the sound was attached successfully, false if failed
///    
///    @see stopAudio())
/// 
/// </summary>

public bool fnShapeBase_playAudio (string shapebase, int slot, string track)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_playAudio'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,track));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbtrack = null;
if (track != null)
     sbtrack = new StringBuilder(track, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_playAudio(sbshapebase, slot, sbtrack)>=1;
}
/// <summary>
///  ),
///    @brief Start a new animation thread, or restart one that has been paused or 
///    stopped.
/// 
///    @param slot thread slot to play. Valid range is 0 - 3)     @param name name of the animation sequence to play in this slot. If not 
///    specified, the paused or stopped thread in this slot will be resumed.
///    @return true if successful, false if failed
/// 
///    @tsexample
///    %obj.playThread( 0, \"ambient\" );      // Play the ambient sequence in slot 0
///    %obj.setThreadTimeScale( 0, 0.5 );    // Play at half-speed
///    %obj.pauseThread( 0 );                // Pause the sequence
///    %obj.playThread( 0 );                 // Resume playback
///    %obj.playThread( 0, \"spin\" );         // Replace the sequence in slot 0
///    @endtsexample
///    
///    @see pauseThread()
///    @see stopThread()
///    @see setThreadDir()
///    @see setThreadTimeScale()
///    @see destroyThread())
/// 
/// </summary>

public bool fnShapeBase_playThread (string shapebase, int slot, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_playThread'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,name));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_playThread(sbshapebase, slot, sbname)>=1;
}
/// <summary>
/// @brief Set the hidden state on all the shape meshes.
/// 
///    This allows you to hide all meshes in the shape, for example, and then only 
///    enable a few.
/// 
///    @param hide new hidden state for all meshes )
/// 
/// </summary>

public void fnShapeBase_setAllMeshesHidden (string shapebase, bool hide)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setAllMeshesHidden'" + string.Format("\"{0}\" \"{1}\" ",shapebase,hide));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setAllMeshesHidden(sbshapebase, hide);
}
/// <summary>
/// @brief Set the vertical field of view in degrees for this object if used as a camera.
/// 
///    @param fov new FOV value )
/// 
/// </summary>

public void fnShapeBase_setCameraFov (string shapebase, float fov)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setCameraFov'" + string.Format("\"{0}\" \"{1}\" ",shapebase,fov));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setCameraFov(sbshapebase, fov);
}
/// <summary>
/// @brief Set the cloaked state of this object.
/// 
///    When an object is cloaked it is not rendered.
/// 
///    @param cloak true to cloak the object, false to uncloak
///    
///    @see isCloaked())
/// 
/// </summary>

public void fnShapeBase_setCloaked (string shapebase, bool cloak)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setCloaked'" + string.Format("\"{0}\" \"{1}\" ",shapebase,cloak));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setCloaked(sbshapebase, cloak);
}
/// <summary>
/// @brief Set the damage flash level.
/// 
///    Damage flash may be used as a postfx effect to flash the screen when the 
///    client is damaged.
/// 
///    @note Relies on the flash postFx.
/// 
///    @param level flash level (0-1)
///    
///    @see getDamageFlash())
/// 
/// </summary>

public void fnShapeBase_setDamageFlash (string shapebase, float level)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setDamageFlash'" + string.Format("\"{0}\" \"{1}\" ",shapebase,level));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setDamageFlash(sbshapebase, level);
}
/// <summary>
/// @brief Set the object's current damage level.
/// 
///    @param level new damage level
///    
///    @see getDamageLevel()
///    @see getDamagePercent())
/// 
/// </summary>

public void fnShapeBase_setDamageLevel (string shapebase, float level)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setDamageLevel'" + string.Format("\"{0}\" \"{1}\" ",shapebase,level));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setDamageLevel(sbshapebase, level);
}
/// <summary>
/// @brief Set the object's damage state.
/// 
///    @param state should be one of \"Enabled\", \"Disabled\", \"Destroyed\"
///    @return true if successful, false if failed
///    
///    @see getDamageState())
/// 
/// </summary>

public bool fnShapeBase_setDamageState (string shapebase, string state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setDamageState'" + string.Format("\"{0}\" \"{1}\" ",shapebase,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbstate = null;
if (state != null)
     sbstate = new StringBuilder(state, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setDamageState(sbshapebase, sbstate)>=1;
}
/// <summary>
/// @brief Set the damage direction vector.
/// 
///    Currently this is only used to initialise the explosion if this object 
///    is blown up.
/// 
///    @param vec damage direction vector
/// 
///    @tsexample
///    %obj.setDamageVector( \"0 0 1\" );
///    @endtsexample )
/// 
/// </summary>

public void fnShapeBase_setDamageVector (string shapebase, string vec)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setDamageVector'" + string.Format("\"{0}\" \"{1}\" ",shapebase,vec));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbvec = null;
if (vec != null)
     sbvec = new StringBuilder(vec, 1024);

SafeNativeMethods.mwle_fnShapeBase_setDamageVector(sbshapebase, sbvec);
}
/// <summary>
/// @brief Set this object's current energy level.
/// 
///    @param level new energy level
///    
///    @see getEnergyLevel()
///    @see getEnergyPercent())
/// 
/// </summary>

public void fnShapeBase_setEnergyLevel (string shapebase, float level)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setEnergyLevel'" + string.Format("\"{0}\" \"{1}\" ",shapebase,level));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setEnergyLevel(sbshapebase, level);
}
/// <summary>
/// @brief Add or remove this object from the scene.
///    When removed from the scene, the object will not be processed or rendered.
///    @param show False to hide the object, true to re-show it )
/// 
/// </summary>

public void fnShapeBase_setHidden (string shapebase, bool show)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setHidden'" + string.Format("\"{0}\" \"{1}\" ",shapebase,show));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setHidden(sbshapebase, show);
}
/// <summary>
/// @brief Set the alt trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param state new alt trigger state for the Image
///    @return the Image's new alt trigger state )
/// 
/// </summary>

public bool fnShapeBase_setImageAltTrigger (string shapebase, int slot, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageAltTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageAltTrigger(sbshapebase, slot, state)>=1;
}
/// <summary>
/// @brief Set the ammo state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param state new ammo state for the Image
///    @return the Image's new ammo state )
/// 
/// </summary>

public bool fnShapeBase_setImageAmmo (string shapebase, int slot, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageAmmo'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageAmmo(sbshapebase, slot, state)>=1;
}
/// <summary>
/// @brief Set the generic trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param trigger Generic trigger number
///    @param state new generic trigger state for the Image
///    @return the Image's new generic trigger state or -1 if there was a problem. )
/// 
/// </summary>

public int fnShapeBase_setImageGenericTrigger (string shapebase, int slot, int trigger, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageGenericTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",shapebase,slot,trigger,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageGenericTrigger(sbshapebase, slot, trigger, state);
}
/// <summary>
/// @brief Set the loaded state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param state new loaded state for the Image
///    @return the Image's new loaded state )
/// 
/// </summary>

public bool fnShapeBase_setImageLoaded (string shapebase, int slot, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageLoaded'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageLoaded(sbshapebase, slot, state)>=1;
}
/// <summary>
/// @brief Set the script animation prefix for the Image mounted in the specified slot.
///    This is used to further modify the prefix used when deciding which animation sequence to 
///    play while this image is mounted.
/// 
///    @param slot Image slot to modify
///    @param prefix The prefix applied to the image )
/// 
/// </summary>

public void fnShapeBase_setImageScriptAnimPrefix (string shapebase, int slot, string prefix)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageScriptAnimPrefix'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,prefix));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbprefix = null;
if (prefix != null)
     sbprefix = new StringBuilder(prefix, 1024);

SafeNativeMethods.mwle_fnShapeBase_setImageScriptAnimPrefix(sbshapebase, slot, sbprefix);
}
/// <summary>
/// @brief Set the target state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param state new target state for the Image
///    @return the Image's new target state )
/// 
/// </summary>

public bool fnShapeBase_setImageTarget (string shapebase, int slot, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageTarget'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageTarget(sbshapebase, slot, state)>=1;
}
/// <summary>
/// @brief Set the trigger state of the Image mounted in the specified slot.
/// 
///    @param slot Image slot to modify
///    @param state new trigger state for the Image
///    @return the Image's new trigger state )
/// 
/// </summary>

public bool fnShapeBase_setImageTrigger (string shapebase, int slot, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setImageTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,state));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setImageTrigger(sbshapebase, slot, state)>=1;
}
/// <summary>
/// @brief Set the hidden state on the named shape mesh.
/// 
///    @param name name of the mesh to hide/show
///    @param hide new hidden state for the mesh )
/// 
/// </summary>

public void fnShapeBase_setMeshHidden (string shapebase, string name, bool hide)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setMeshHidden'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,name,hide));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnShapeBase_setMeshHidden(sbshapebase, sbname, hide);
}
/// <summary>
/// @brief Set the recharge rate.
/// 
///    The recharge rate is added to the object's current energy level each tick, 
///    up to the maxEnergy level set in the ShapeBaseData datablock.
///    
///    @param rate the recharge rate (per tick)
///    
///    @see getRechargeRate())
/// 
/// </summary>

public void fnShapeBase_setRechargeRate (string shapebase, float rate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setRechargeRate'" + string.Format("\"{0}\" \"{1}\" ",shapebase,rate));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setRechargeRate(sbshapebase, rate);
}
/// <summary>
/// @brief Set amount to repair damage by each tick.
/// 
///    Note that this value is separate to the repairRate field in ShapeBaseData. 
///    This value will be subtracted from the damage level each tick, whereas the 
///    ShapeBaseData field limits how much of the applyRepair value is subtracted 
///    each tick. Both repair types can be active at the same time.
///    
///    @param rate value to subtract from damage level each tick (must be > 0)
///    
///    @see getRepairRate())
/// 
/// </summary>

public void fnShapeBase_setRepairRate (string shapebase, float rate)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setRepairRate'" + string.Format("\"{0}\" \"{1}\" ",shapebase,rate));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setRepairRate(sbshapebase, rate);
}
/// <summary>
/// @brief Set the name of this shape.
/// 
///    @note This is the name of the shape object that is sent to the client, 
///    not the DTS or DAE model filename.
/// 
///    @param name new name for the shape
///    
///    @see getShapeName())
/// 
/// </summary>

public void fnShapeBase_setShapeName (string shapebase, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setShapeName'" + string.Format("\"{0}\" \"{1}\" ",shapebase,name));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnShapeBase_setShapeName(sbshapebase, sbname);
}
/// <summary>
/// @brief Apply a new skin to this shape.
/// 
///    'Skinning' the shape effectively renames the material targets, allowing 
///    different materials to be used on different instances of the same model.
/// 
///    @param name name of the skin to apply
/// 
///    @see skin
///    @see getSkinName())
/// 
/// </summary>

public void fnShapeBase_setSkinName (string shapebase, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setSkinName'" + string.Format("\"{0}\" \"{1}\" ",shapebase,name));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnShapeBase_setSkinName(sbshapebase, sbname);
}
/// <summary>
/// @brief Set the playback direction of an animation thread.
/// 
///    @param slot thread slot to modify
///    @param fwd true to play the animation forwards, false to play backwards
///    @return true if successful, false if failed
///    
///    @see playThread() )
/// 
/// </summary>

public bool fnShapeBase_setThreadDir (string shapebase, int slot, bool fwd)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setThreadDir'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,fwd));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setThreadDir(sbshapebase, slot, fwd)>=1;
}
/// <summary>
/// @brief Set the position within an animation thread.
/// 
///    @param slot thread slot to modify
///    @param pos position within thread
///    @return true if successful, false if failed
///    
///    @see playThread )
/// 
/// </summary>

public bool fnShapeBase_setThreadPosition (string shapebase, int slot, float pos)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setThreadPosition'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,pos));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setThreadPosition(sbshapebase, slot, pos)>=1;
}
/// <summary>
/// @brief Set the playback time scale of an animation thread.
/// 
///    @param slot thread slot to modify
///    @param scale new thread time scale (1=normal speed, 0.5=half speed etc)
///    @return true if successful, false if failed
///    
///    @see playThread )
/// 
/// </summary>

public bool fnShapeBase_setThreadTimeScale (string shapebase, int slot, float scale)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setThreadTimeScale'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebase,slot,scale));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setThreadTimeScale(sbshapebase, slot, scale)>=1;
}
/// <summary>
/// @brief Set the object's velocity.
/// 
///    @param vel new velocity for the object
///    @return true )
/// 
/// </summary>

public bool fnShapeBase_setVelocity (string shapebase, string vel)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setVelocity'" + string.Format("\"{0}\" \"{1}\" ",shapebase,vel));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);
StringBuilder sbvel = null;
if (vel != null)
     sbvel = new StringBuilder(vel, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_setVelocity(sbshapebase, sbvel)>=1;
}
/// <summary>
/// @brief Set the white-out level.
/// 
///    White-out may be used as a postfx effect to brighten the screen in response 
///    to a game event.
/// 
///    @note Relies on the flash postFx.
/// 
///    @param level flash level (0-1)
///    
///    @see getWhiteOut())
/// 
/// </summary>

public void fnShapeBase_setWhiteOut (string shapebase, float level)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_setWhiteOut'" + string.Format("\"{0}\" \"{1}\" ",shapebase,level));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_setWhiteOut(sbshapebase, level);
}
/// <summary>
/// @brief Fade the object in or out without removing it from the scene.
/// 
///    A faded out object is still in the scene and can still be collided with, 
///    so if you want to disable collisions for this shape after it fades out 
///    use setHidden to temporarily remove this shape from the scene.
///   
///    @note Items have the ability to light their surroundings. When an Item with 
///    an active light is fading out, the light it emits is correspondingly 
///    reduced until it goes out. Likewise, when the item fades in, the light is 
///    turned-up till it reaches it's normal brightntess.
/// 
///    @param time duration of the fade effect in ms
///    @param delay delay in ms before the fade effect begins
///    @param fadeOut true to fade-out to invisible, false to fade-in to full visibility )
/// 
/// </summary>

public void fnShapeBase_startFade (string shapebase, int time, int delay, bool fadeOut)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_startFade'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",shapebase,time,delay,fadeOut));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

SafeNativeMethods.mwle_fnShapeBase_startFade(sbshapebase, time, delay, fadeOut);
}
/// <summary>
/// @brief Stop a sound started with playAudio.
/// 
///    @param slot audio slot index (started with playAudio)
///    @return true if the sound was stopped successfully, false if failed
///    
///    @see playAudio())
/// 
/// </summary>

public bool fnShapeBase_stopAudio (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_stopAudio'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_stopAudio(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Stop an animation thread.
/// 
///    If restarted using playThread, the animation 
///    will start from the beginning again.
///    @param slot thread slot to stop
///    @return true if successful, false if failed
///    
///    @see playThread )
/// 
/// </summary>

public bool fnShapeBase_stopThread (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_stopThread'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_stopThread(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Unmount the mounted Image in the specified slot.
/// 
///    @param slot Image slot to unmount
///    @return true if successful, false if failed
///    
///    @see mountImage())
/// 
/// </summary>

public bool fnShapeBase_unmountImage (string shapebase, int slot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBase_unmountImage'" + string.Format("\"{0}\" \"{1}\" ",shapebase,slot));
StringBuilder sbshapebase = null;
if (shapebase != null)
     sbshapebase = new StringBuilder(shapebase, 1024);

return  SafeNativeMethods.mwle_fnShapeBase_unmountImage(sbshapebase, slot)>=1;
}
/// <summary>
/// @brief Check if there is the space at the given transform is free to spawn into.
/// 
///    The shape's bounding box volume is used to check for collisions at the given world 
///    transform.  Only interior and static objects are checked for collision.
/// 
///    @param txfm Deploy transform to check
///    @return True if the space is free, false if there is already something in 
///    the way.
/// 
///    @note This is a server side only check, and is not actually limited to spawning.)
/// 
/// </summary>

public bool fnShapeBaseData_checkDeployPos (string shapebasedata, string txfm)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBaseData_checkDeployPos'" + string.Format("\"{0}\" \"{1}\" ",shapebasedata,txfm));
StringBuilder sbshapebasedata = null;
if (shapebasedata != null)
     sbshapebasedata = new StringBuilder(shapebasedata, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);

return  SafeNativeMethods.mwle_fnShapeBaseData_checkDeployPos(sbshapebasedata, sbtxfm)>=1;
}
/// <summary>
/// @brief Helper method to get a transform from a position and vector (suitable for use with setTransform).
///    @param pos Desired transform position
///    @param normal Vector of desired direction
///    @return The deploy transform )
/// 
/// </summary>

public string fnShapeBaseData_getDeployTransform (string shapebasedata, string pos, string normal)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnShapeBaseData_getDeployTransform'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",shapebasedata,pos,normal));
var returnbuff = new StringBuilder(1024);
StringBuilder sbshapebasedata = null;
if (shapebasedata != null)
     sbshapebasedata = new StringBuilder(shapebasedata, 1024);
StringBuilder sbpos = null;
if (pos != null)
     sbpos = new StringBuilder(pos, 1024);
StringBuilder sbnormal = null;
if (normal != null)
     sbnormal = new StringBuilder(normal, 1024);

SafeNativeMethods.mwle_fnShapeBaseData_getDeployTransform(sbshapebasedata, sbpos, sbnormal, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( SimComponent, addComponents, bool, 3, 64, %obj.addComponents( %compObjName, %compObjName2, ... );
/// 			  Adds additional components to current list.
/// 			  @param Up to 62 component names
/// 			  @return Returns true on success, false otherwise.)
/// 
/// </summary>

public bool fnSimComponent_addComponents (string simcomponent, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19, string a20, string a21, string a22, string a23, string a24, string a25, string a26, string a27, string a28, string a29, string a30, string a31, string a32, string a33, string a34, string a35, string a36, string a37, string a38, string a39, string a40, string a41, string a42, string a43, string a44, string a45, string a46, string a47, string a48, string a49, string a50, string a51, string a52, string a53, string a54, string a55, string a56, string a57, string a58, string a59, string a60, string a61, string a62, string a63)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimComponent_addComponents'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" \"{19}\" \"{20}\" \"{21}\" \"{22}\" \"{23}\" \"{24}\" \"{25}\" \"{26}\" \"{27}\" \"{28}\" \"{29}\" \"{30}\" \"{31}\" \"{32}\" \"{33}\" \"{34}\" \"{35}\" \"{36}\" \"{37}\" \"{38}\" \"{39}\" \"{40}\" \"{41}\" \"{42}\" \"{43}\" \"{44}\" \"{45}\" \"{46}\" \"{47}\" \"{48}\" \"{49}\" \"{50}\" \"{51}\" \"{52}\" \"{53}\" \"{54}\" \"{55}\" \"{56}\" \"{57}\" \"{58}\" \"{59}\" \"{60}\" \"{61}\" \"{62}\" ",simcomponent,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30,a31,a32,a33,a34,a35,a36,a37,a38,a39,a40,a41,a42,a43,a44,a45,a46,a47,a48,a49,a50,a51,a52,a53,a54,a55,a56,a57,a58,a59,a60,a61,a62,a63));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);
StringBuilder sba20 = null;
if (a20 != null)
     sba20 = new StringBuilder(a20, 1024);
StringBuilder sba21 = null;
if (a21 != null)
     sba21 = new StringBuilder(a21, 1024);
StringBuilder sba22 = null;
if (a22 != null)
     sba22 = new StringBuilder(a22, 1024);
StringBuilder sba23 = null;
if (a23 != null)
     sba23 = new StringBuilder(a23, 1024);
StringBuilder sba24 = null;
if (a24 != null)
     sba24 = new StringBuilder(a24, 1024);
StringBuilder sba25 = null;
if (a25 != null)
     sba25 = new StringBuilder(a25, 1024);
StringBuilder sba26 = null;
if (a26 != null)
     sba26 = new StringBuilder(a26, 1024);
StringBuilder sba27 = null;
if (a27 != null)
     sba27 = new StringBuilder(a27, 1024);
StringBuilder sba28 = null;
if (a28 != null)
     sba28 = new StringBuilder(a28, 1024);
StringBuilder sba29 = null;
if (a29 != null)
     sba29 = new StringBuilder(a29, 1024);
StringBuilder sba30 = null;
if (a30 != null)
     sba30 = new StringBuilder(a30, 1024);
StringBuilder sba31 = null;
if (a31 != null)
     sba31 = new StringBuilder(a31, 1024);
StringBuilder sba32 = null;
if (a32 != null)
     sba32 = new StringBuilder(a32, 1024);
StringBuilder sba33 = null;
if (a33 != null)
     sba33 = new StringBuilder(a33, 1024);
StringBuilder sba34 = null;
if (a34 != null)
     sba34 = new StringBuilder(a34, 1024);
StringBuilder sba35 = null;
if (a35 != null)
     sba35 = new StringBuilder(a35, 1024);
StringBuilder sba36 = null;
if (a36 != null)
     sba36 = new StringBuilder(a36, 1024);
StringBuilder sba37 = null;
if (a37 != null)
     sba37 = new StringBuilder(a37, 1024);
StringBuilder sba38 = null;
if (a38 != null)
     sba38 = new StringBuilder(a38, 1024);
StringBuilder sba39 = null;
if (a39 != null)
     sba39 = new StringBuilder(a39, 1024);
StringBuilder sba40 = null;
if (a40 != null)
     sba40 = new StringBuilder(a40, 1024);
StringBuilder sba41 = null;
if (a41 != null)
     sba41 = new StringBuilder(a41, 1024);
StringBuilder sba42 = null;
if (a42 != null)
     sba42 = new StringBuilder(a42, 1024);
StringBuilder sba43 = null;
if (a43 != null)
     sba43 = new StringBuilder(a43, 1024);
StringBuilder sba44 = null;
if (a44 != null)
     sba44 = new StringBuilder(a44, 1024);
StringBuilder sba45 = null;
if (a45 != null)
     sba45 = new StringBuilder(a45, 1024);
StringBuilder sba46 = null;
if (a46 != null)
     sba46 = new StringBuilder(a46, 1024);
StringBuilder sba47 = null;
if (a47 != null)
     sba47 = new StringBuilder(a47, 1024);
StringBuilder sba48 = null;
if (a48 != null)
     sba48 = new StringBuilder(a48, 1024);
StringBuilder sba49 = null;
if (a49 != null)
     sba49 = new StringBuilder(a49, 1024);
StringBuilder sba50 = null;
if (a50 != null)
     sba50 = new StringBuilder(a50, 1024);
StringBuilder sba51 = null;
if (a51 != null)
     sba51 = new StringBuilder(a51, 1024);
StringBuilder sba52 = null;
if (a52 != null)
     sba52 = new StringBuilder(a52, 1024);
StringBuilder sba53 = null;
if (a53 != null)
     sba53 = new StringBuilder(a53, 1024);
StringBuilder sba54 = null;
if (a54 != null)
     sba54 = new StringBuilder(a54, 1024);
StringBuilder sba55 = null;
if (a55 != null)
     sba55 = new StringBuilder(a55, 1024);
StringBuilder sba56 = null;
if (a56 != null)
     sba56 = new StringBuilder(a56, 1024);
StringBuilder sba57 = null;
if (a57 != null)
     sba57 = new StringBuilder(a57, 1024);
StringBuilder sba58 = null;
if (a58 != null)
     sba58 = new StringBuilder(a58, 1024);
StringBuilder sba59 = null;
if (a59 != null)
     sba59 = new StringBuilder(a59, 1024);
StringBuilder sba60 = null;
if (a60 != null)
     sba60 = new StringBuilder(a60, 1024);
StringBuilder sba61 = null;
if (a61 != null)
     sba61 = new StringBuilder(a61, 1024);
StringBuilder sba62 = null;
if (a62 != null)
     sba62 = new StringBuilder(a62, 1024);
StringBuilder sba63 = null;
if (a63 != null)
     sba63 = new StringBuilder(a63, 1024);

return  SafeNativeMethods.mwle_fnSimComponent_addComponents(sbsimcomponent, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, sba20, sba21, sba22, sba23, sba24, sba25, sba26, sba27, sba28, sba29, sba30, sba31, sba32, sba33, sba34, sba35, sba36, sba37, sba38, sba39, sba40, sba41, sba42, sba43, sba44, sba45, sba46, sba47, sba48, sba49, sba50, sba51, sba52, sba53, sba54, sba55, sba56, sba57, sba58, sba59, sba60, sba61, sba62, sba63)>=1;
}
/// <summary>
/// ( SimComponent, removeComponents, bool, 3, 64, %obj.removeComponents( %compObjName, %compObjName2, ... );
/// 			  Removes components by name from current list.
/// 			  @param objNamex Up to 62 component names
/// 			  @return Returns true on success, false otherwise.)
/// 
/// </summary>

public bool fnSimComponent_removeComponents (string simcomponent, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19, string a20, string a21, string a22, string a23, string a24, string a25, string a26, string a27, string a28, string a29, string a30, string a31, string a32, string a33, string a34, string a35, string a36, string a37, string a38, string a39, string a40, string a41, string a42, string a43, string a44, string a45, string a46, string a47, string a48, string a49, string a50, string a51, string a52, string a53, string a54, string a55, string a56, string a57, string a58, string a59, string a60, string a61, string a62, string a63)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimComponent_removeComponents'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" \"{19}\" \"{20}\" \"{21}\" \"{22}\" \"{23}\" \"{24}\" \"{25}\" \"{26}\" \"{27}\" \"{28}\" \"{29}\" \"{30}\" \"{31}\" \"{32}\" \"{33}\" \"{34}\" \"{35}\" \"{36}\" \"{37}\" \"{38}\" \"{39}\" \"{40}\" \"{41}\" \"{42}\" \"{43}\" \"{44}\" \"{45}\" \"{46}\" \"{47}\" \"{48}\" \"{49}\" \"{50}\" \"{51}\" \"{52}\" \"{53}\" \"{54}\" \"{55}\" \"{56}\" \"{57}\" \"{58}\" \"{59}\" \"{60}\" \"{61}\" \"{62}\" ",simcomponent,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30,a31,a32,a33,a34,a35,a36,a37,a38,a39,a40,a41,a42,a43,a44,a45,a46,a47,a48,a49,a50,a51,a52,a53,a54,a55,a56,a57,a58,a59,a60,a61,a62,a63));
StringBuilder sbsimcomponent = null;
if (simcomponent != null)
     sbsimcomponent = new StringBuilder(simcomponent, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);
StringBuilder sba20 = null;
if (a20 != null)
     sba20 = new StringBuilder(a20, 1024);
StringBuilder sba21 = null;
if (a21 != null)
     sba21 = new StringBuilder(a21, 1024);
StringBuilder sba22 = null;
if (a22 != null)
     sba22 = new StringBuilder(a22, 1024);
StringBuilder sba23 = null;
if (a23 != null)
     sba23 = new StringBuilder(a23, 1024);
StringBuilder sba24 = null;
if (a24 != null)
     sba24 = new StringBuilder(a24, 1024);
StringBuilder sba25 = null;
if (a25 != null)
     sba25 = new StringBuilder(a25, 1024);
StringBuilder sba26 = null;
if (a26 != null)
     sba26 = new StringBuilder(a26, 1024);
StringBuilder sba27 = null;
if (a27 != null)
     sba27 = new StringBuilder(a27, 1024);
StringBuilder sba28 = null;
if (a28 != null)
     sba28 = new StringBuilder(a28, 1024);
StringBuilder sba29 = null;
if (a29 != null)
     sba29 = new StringBuilder(a29, 1024);
StringBuilder sba30 = null;
if (a30 != null)
     sba30 = new StringBuilder(a30, 1024);
StringBuilder sba31 = null;
if (a31 != null)
     sba31 = new StringBuilder(a31, 1024);
StringBuilder sba32 = null;
if (a32 != null)
     sba32 = new StringBuilder(a32, 1024);
StringBuilder sba33 = null;
if (a33 != null)
     sba33 = new StringBuilder(a33, 1024);
StringBuilder sba34 = null;
if (a34 != null)
     sba34 = new StringBuilder(a34, 1024);
StringBuilder sba35 = null;
if (a35 != null)
     sba35 = new StringBuilder(a35, 1024);
StringBuilder sba36 = null;
if (a36 != null)
     sba36 = new StringBuilder(a36, 1024);
StringBuilder sba37 = null;
if (a37 != null)
     sba37 = new StringBuilder(a37, 1024);
StringBuilder sba38 = null;
if (a38 != null)
     sba38 = new StringBuilder(a38, 1024);
StringBuilder sba39 = null;
if (a39 != null)
     sba39 = new StringBuilder(a39, 1024);
StringBuilder sba40 = null;
if (a40 != null)
     sba40 = new StringBuilder(a40, 1024);
StringBuilder sba41 = null;
if (a41 != null)
     sba41 = new StringBuilder(a41, 1024);
StringBuilder sba42 = null;
if (a42 != null)
     sba42 = new StringBuilder(a42, 1024);
StringBuilder sba43 = null;
if (a43 != null)
     sba43 = new StringBuilder(a43, 1024);
StringBuilder sba44 = null;
if (a44 != null)
     sba44 = new StringBuilder(a44, 1024);
StringBuilder sba45 = null;
if (a45 != null)
     sba45 = new StringBuilder(a45, 1024);
StringBuilder sba46 = null;
if (a46 != null)
     sba46 = new StringBuilder(a46, 1024);
StringBuilder sba47 = null;
if (a47 != null)
     sba47 = new StringBuilder(a47, 1024);
StringBuilder sba48 = null;
if (a48 != null)
     sba48 = new StringBuilder(a48, 1024);
StringBuilder sba49 = null;
if (a49 != null)
     sba49 = new StringBuilder(a49, 1024);
StringBuilder sba50 = null;
if (a50 != null)
     sba50 = new StringBuilder(a50, 1024);
StringBuilder sba51 = null;
if (a51 != null)
     sba51 = new StringBuilder(a51, 1024);
StringBuilder sba52 = null;
if (a52 != null)
     sba52 = new StringBuilder(a52, 1024);
StringBuilder sba53 = null;
if (a53 != null)
     sba53 = new StringBuilder(a53, 1024);
StringBuilder sba54 = null;
if (a54 != null)
     sba54 = new StringBuilder(a54, 1024);
StringBuilder sba55 = null;
if (a55 != null)
     sba55 = new StringBuilder(a55, 1024);
StringBuilder sba56 = null;
if (a56 != null)
     sba56 = new StringBuilder(a56, 1024);
StringBuilder sba57 = null;
if (a57 != null)
     sba57 = new StringBuilder(a57, 1024);
StringBuilder sba58 = null;
if (a58 != null)
     sba58 = new StringBuilder(a58, 1024);
StringBuilder sba59 = null;
if (a59 != null)
     sba59 = new StringBuilder(a59, 1024);
StringBuilder sba60 = null;
if (a60 != null)
     sba60 = new StringBuilder(a60, 1024);
StringBuilder sba61 = null;
if (a61 != null)
     sba61 = new StringBuilder(a61, 1024);
StringBuilder sba62 = null;
if (a62 != null)
     sba62 = new StringBuilder(a62, 1024);
StringBuilder sba63 = null;
if (a63 != null)
     sba63 = new StringBuilder(a63, 1024);

return  SafeNativeMethods.mwle_fnSimComponent_removeComponents(sbsimcomponent, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, sba20, sba21, sba22, sba23, sba24, sba25, sba26, sba27, sba28, sba29, sba30, sba31, sba32, sba33, sba34, sba35, sba36, sba37, sba38, sba39, sba40, sba41, sba42, sba43, sba44, sba45, sba46, sba47, sba48, sba49, sba50, sba51, sba52, sba53, sba54, sba55, sba56, sba57, sba58, sba59, sba60, sba61, sba62, sba63)>=1;
}
/// <summary>
/// Assign a persistent ID to the object if it does not already have one. )
/// 
/// </summary>

public void fnSimObject_assignPersistentId (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_assignPersistentId'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_assignPersistentId(sbsimobject);
}
/// <summary>
/// ( SimObject, call, const char*, 3, 0, ( string method, string args... ) Dynamically call a method on an object.
///    @param method Name of method to call.
///    @param args Zero or more arguments for the method.
///    @return The result of the method call. )
/// 
/// </summary>

public string fnSimObject_call (string simobject, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_call'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simobject,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnSimObject_call(sbsimobject, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Create a copy of this object.
///    @return An exact duplicate of this object. )
/// 
/// </summary>

public string fnSimObject_clone (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_clone'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_clone(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Create a copy of this object and all its subobjects.
///    @return An exact duplicate of this object and all objects it references. )
/// 
/// </summary>

public string fnSimObject_deepClone (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_deepClone'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_deepClone(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Dump a description of all fields and methods defined on this object to the console.
///    @param detailed Whether to print detailed information about members. )
/// 
/// </summary>

public void fnSimObject_dump (string simobject, bool detailed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_dump'" + string.Format("\"{0}\" \"{1}\" ",simobject,detailed));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_dump(sbsimobject, detailed);
}
/// <summary>
/// Dump the hierarchy of this object up to RootGroup to the console. )
/// 
/// </summary>

public void fnSimObject_dumpGroupHierarchy (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_dumpGroupHierarchy'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_dumpGroupHierarchy(sbsimobject);
}
/// <summary>
/// Return some behind-the-scenes information on the object.
///    @return An ArrayObject filled with internal information about the object. )
/// 
/// </summary>

public string fnSimObject_getDebugInfo (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_getDebugInfo'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_getDebugInfo(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the group that this object is contained in.
///    @note If not assigned to particular SimGroup, an object belongs to RootGroup.
///    @return The SimGroup object to which the object belongs. )
/// 
/// </summary>

public string fnSimObject_getGroup (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_getGroup'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_getGroup(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the underlying unique numeric ID of the object.
///    @note Object IDs are unique only during single engine runs.
///    @return The unique numeric ID of the object. )
/// 
/// </summary>

public int fnSimObject_getId (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_getId'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fnSimObject_getId(sbsimobject);
}
/// <summary>
/// Get the internal name of the object.
///    @return The internal name of the object. )
/// 
/// </summary>

public string fnSimObject_getInternalName (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_getInternalName'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_getInternalName(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the global name of the object.
///    @return The global name assigned to the object. )
/// 
/// </summary>

public string fnSimObject_getName (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_getName'" + string.Format("\"{0}\" ",simobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_getName(sbsimobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Test whether the object belongs directly or indirectly to the given group.
///    @param group The SimGroup object.
///    @return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to. )
/// 
/// </summary>

public bool fnSimObject_isChildOfGroup (string simobject, string group)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_isChildOfGroup'" + string.Format("\"{0}\" \"{1}\" ",simobject,group));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbgroup = null;
if (group != null)
     sbgroup = new StringBuilder(group, 1024);

return  SafeNativeMethods.mwle_fnSimObject_isChildOfGroup(sbsimobject, sbgroup)>=1;
}
/// <summary>
/// Editable/Non-editable object in the game.
///    @return If the object is editable or not. )
/// 
/// </summary>

public bool fnSimObject_isEditable (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_isEditable'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fnSimObject_isEditable(sbsimobject)>=1;
}
/// <summary>
/// Return true if the object is only used by the editor.
///    @return True if this object exists only for the sake of editing. )
/// 
/// </summary>

public bool fnSimObject_isEditorOnly (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_isEditorOnly'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fnSimObject_isEditorOnly(sbsimobject)>=1;
}
/// <summary>
/// Get whether this object may be renamed.
///    @return True if this object can be renamed; false otherwise. )
/// 
/// </summary>

public bool fnSimObject_isNameChangeAllowed (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_isNameChangeAllowed'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fnSimObject_isNameChangeAllowed(sbsimobject)>=1;
}
/// <summary>
/// Get whether the object has been marked as selected. (in editor)
///    @return True if the object is currently selected. )
/// 
/// </summary>

public bool fnSimObject_isSelected (string simobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_isSelected'" + string.Format("\"{0}\" ",simobject));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

return  SafeNativeMethods.mwle_fnSimObject_isSelected(sbsimobject)>=1;
}
/// <summary>
/// ( SimObject,schedule, S32, 4, 0, ( float time, string method, string args... ) Delay an invocation of a method.
///    @param time The number of milliseconds after which to invoke the method.  This is a soft limit.
///    @param method The method to call.
///    @param args The arguments with which to call the method.
///    @return The numeric ID of the created schedule.  Can be used to cancel the call. )
/// 
/// </summary>

public int fnSimObject_schedule (string simobject, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_schedule'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simobject,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

return  SafeNativeMethods.mwle_fnSimObject_schedule(sbsimobject, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Editable/Non-editable object in the game.
///    @param value If true, the object will be editable; if false, the object will not be editable. )
/// 
/// </summary>

public void fnSimObject_setEditable (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setEditable'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setEditable(sbsimobject, value);
}
/// <summary>
/// Set/clear the editor-only flag on this object.
///    @param value If true, the object is marked as existing only for the editor. )
/// 
/// </summary>

public void fnSimObject_setEditorOnly (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setEditorOnly'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setEditorOnly(sbsimobject, value);
}
/// <summary>
/// Hide/unhide the object.
///    @param value If true, the object will be hidden; if false, the object will be unhidden. )
/// 
/// </summary>

public void fnSimObject_setHidden (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setHidden'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setHidden(sbsimobject, value);
}
/// <summary>
/// Set the internal name of the object.
///    @param newInternalName The new internal name for the object. )
/// 
/// </summary>

public void fnSimObject_setInternalName (string simobject, string newInternalName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setInternalName'" + string.Format("\"{0}\" \"{1}\" ",simobject,newInternalName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbnewInternalName = null;
if (newInternalName != null)
     sbnewInternalName = new StringBuilder(newInternalName, 1024);

SafeNativeMethods.mwle_fnSimObject_setInternalName(sbsimobject, sbnewInternalName);
}
/// <summary>
/// Set whether the object has been marked as selected. (in editor)
///    @param state True if object is to be marked selected; false if not. )
/// 
/// </summary>

public void fnSimObject_setIsSelected (string simobject, bool state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setIsSelected'" + string.Format("\"{0}\" \"{1}\" ",simobject,state));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setIsSelected(sbsimobject, state);
}
/// <summary>
/// Lock/unlock the object in the editor.
///    @param value If true, the object will be locked; if false, the object will be unlocked. )
/// 
/// </summary>

public void fnSimObject_setLocked (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setLocked'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setLocked(sbsimobject, value);
}
/// <summary>
/// Set the global name of the object.
///    @param newName The new global name to assign to the object.
///    @note If name changing is disallowed on the object, the method will fail with a console error. )
/// 
/// </summary>

public void fnSimObject_setName (string simobject, string newName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setName'" + string.Format("\"{0}\" \"{1}\" ",simobject,newName));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sbnewName = null;
if (newName != null)
     sbnewName = new StringBuilder(newName, 1024);

SafeNativeMethods.mwle_fnSimObject_setName(sbsimobject, sbnewName);
}
/// <summary>
/// Set whether this object can be renamed from its first name.
///    @param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error. )
/// 
/// </summary>

public void fnSimObject_setNameChangeAllowed (string simobject, bool value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_setNameChangeAllowed'" + string.Format("\"{0}\" \"{1}\" ",simobject,value));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);

SafeNativeMethods.mwle_fnSimObject_setNameChangeAllowed(sbsimobject, value);
}
/// <summary>
/// (SimObject, signal, void, 3, 4, evaluates strings stored in dynamic fields take a string as parameter)
/// 
/// </summary>

public void fnSimObject_signal (string simobject, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimObject_signal'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simobject,a2,a3));
StringBuilder sbsimobject = null;
if (simobject != null)
     sbsimobject = new StringBuilder(simobject, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

SafeNativeMethods.mwle_fnSimObject_signal(sbsimobject, sba2, sba3);
}
/// <summary>
/// @brief Sets the internal message variable.
/// 
///    SimpleNetObject is set up to automatically transmit this new message to 
///    all connected clients.  It will appear in the clients' console.
/// 
///    @param msg The new message to send
///    
///    @tsexample
///       // On the server, create a new SimpleNetObject.  This is a ghost always
///       // object so it will be immediately ghosted to all connected clients.
///       $s = new SimpleNetObject();
/// 
///       // All connected clients will see the following in their console:
///       // 
///       // Got message: Hello World!
/// 
///       // Now again on the server, change the message.  This will cause it to
///       // be sent to all connected clients.
///       $s.setMessage(\"A new message from me!\");
/// 
///       // All connected clients will now see in their console:
///       // 
///       // Go message: A new message from me!
///    @endtsexample
///    )
/// 
/// </summary>

public void fnSimpleNetObject_setMessage (string simplenetobject, string msg)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimpleNetObject_setMessage'" + string.Format("\"{0}\" \"{1}\" ",simplenetobject,msg));
StringBuilder sbsimplenetobject = null;
if (simplenetobject != null)
     sbsimplenetobject = new StringBuilder(simplenetobject, 1024);
StringBuilder sbmsg = null;
if (msg != null)
     sbmsg = new StringBuilder(msg, 1024);

SafeNativeMethods.mwle_fnSimpleNetObject_setMessage(sbsimplenetobject, sbmsg);
}
/// <summary>
/// Test whether the given object may be added to the set.
///    @param obj The object to test for potential membership.
///    @return True if the object may be added to the set, false otherwise. )
/// 
/// </summary>

public bool fnSimSet_acceptsAsChild (string simset, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_acceptsAsChild'" + string.Format("\"{0}\" \"{1}\" ",simset,obj));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnSimSet_acceptsAsChild(sbsimset, sbobj)>=1;
}
/// <summary>
/// ( SimSet, add, void, 3, 0,
///    ( SimObject objects... ) Add the given objects to the set.
///    @param objects The objects to add to the set. )
/// 
/// </summary>

public void fnSimSet_add (string simset, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_add'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simset,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnSimSet_add(sbsimset, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Make the given object the first object in the set.
///    @param obj The object to bring to the frontmost position.  Must be contained in the set. )
/// 
/// </summary>

public void fnSimSet_bringToFront (string simset, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_bringToFront'" + string.Format("\"{0}\" \"{1}\" ",simset,obj));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fnSimSet_bringToFront(sbsimset, sbobj);
}
/// <summary>
/// ( SimSet, callOnChildren, void, 3, 0,
///    ( string method, string args... ) Call a method on all objects contained in the set.
///    @param method The name of the method to call.
///    @param args The arguments to the method.
///    @note This method recurses into all SimSets that are children to the set.
///    @see callOnChildrenNoRecurse )
/// 
/// </summary>

public void fnSimSet_callOnChildren (string simset, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_callOnChildren'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simset,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnSimSet_callOnChildren(sbsimset, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// ( SimSet, callOnChildrenNoRecurse, void, 3, 0,
///    ( string method, string args... ) Call a method on all objects contained in the set.
///    @param method The name of the method to call.
///    @param args The arguments to the method.
///    @note This method does not recurse into child SimSets.
///    @see callOnChildren )
/// 
/// </summary>

public void fnSimSet_callOnChildrenNoRecurse (string simset, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_callOnChildrenNoRecurse'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simset,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnSimSet_callOnChildrenNoRecurse(sbsimset, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Remove all objects from the set. )
/// 
/// </summary>

public void fnSimSet_clear (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_clear'" + string.Format("\"{0}\" ",simset));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

SafeNativeMethods.mwle_fnSimSet_clear(sbsimset);
}
/// <summary>
/// Find an object in the set by its internal name.
///    @param internalName The internal name of the object to look for.
///    @param searchChildren If true, SimSets contained in the set will be recursively searched for the object.
///    @return The object with the given internal name or 0 if no match was found. )
/// 
/// </summary>

public string fnSimSet_findObjectByInternalName (string simset, string internalName, bool searchChildren)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_findObjectByInternalName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simset,internalName,searchChildren));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbinternalName = null;
if (internalName != null)
     sbinternalName = new StringBuilder(internalName, 1024);

SafeNativeMethods.mwle_fnSimSet_findObjectByInternalName(sbsimset, sbinternalName, searchChildren, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of objects contained in the set.
///    @return The number of objects contained in the set. )
/// 
/// </summary>

public int fnSimSet_getCount (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_getCount'" + string.Format("\"{0}\" ",simset));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

return  SafeNativeMethods.mwle_fnSimSet_getCount(sbsimset);
}
/// <summary>
/// Get the object at the given index.
///    @param index The object index.
///    @return The object at the given index or -1 if index is out of range. )
/// 
/// </summary>

public string fnSimSet_getObject (string simset, uint index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_getObject'" + string.Format("\"{0}\" \"{1}\" ",simset,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

SafeNativeMethods.mwle_fnSimSet_getObject(sbsimset, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Return the index of the given object in this set.
///    @param obj The object for which to return the index.  Must be contained in the set.
///    @return The index of the object or -1 if the object is not contained in the set. )
/// 
/// </summary>

public int fnSimSet_getObjectIndex (string simset, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_getObjectIndex'" + string.Format("\"{0}\" \"{1}\" ",simset,obj));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnSimSet_getObjectIndex(sbsimset, sbobj);
}
/// <summary>
/// Return a random object from the set.
///    @return A randomly selected object from the set or -1 if the set is empty. )
/// 
/// </summary>

public string fnSimSet_getRandom (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_getRandom'" + string.Format("\"{0}\" ",simset));
var returnbuff = new StringBuilder(1024);
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

SafeNativeMethods.mwle_fnSimSet_getRandom(sbsimset, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Test whether the given object belongs to the set.
///    @param obj The object.
///    @return True if the object is contained in the set; false otherwise. )
/// 
/// </summary>

public bool fnSimSet_isMember (string simset, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_isMember'" + string.Format("\"{0}\" \"{1}\" ",simset,obj));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnSimSet_isMember(sbsimset, sbobj)>=1;
}
/// <summary>
/// Dump a list of all objects contained in the set to the console. )
/// 
/// </summary>

public void fnSimSet_listObjects (string simset)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_listObjects'" + string.Format("\"{0}\" ",simset));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);

SafeNativeMethods.mwle_fnSimSet_listObjects(sbsimset);
}
/// <summary>
/// Make the given object the last object in the set.
///    @param obj The object to bring to the last position.  Must be contained in the set. )
/// 
/// </summary>

public void fnSimSet_pushToBack (string simset, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_pushToBack'" + string.Format("\"{0}\" \"{1}\" ",simset,obj));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

SafeNativeMethods.mwle_fnSimSet_pushToBack(sbsimset, sbobj);
}
/// <summary>
/// ( SimSet, remove, void, 3, 0,
///    ( SimObject objects... ) Remove the given objects from the set.
///    @param objects The objects to remove from the set. )
/// 
/// </summary>

public void fnSimSet_remove (string simset, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_remove'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",simset,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnSimSet_remove(sbsimset, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Make sure child1 is ordered right before child2 in the set.
///    @param child1 The first child.  The object must already be contained in the set.
///    @param child2 The second child.  The object must already be contained in the set. )
/// 
/// </summary>

public void fnSimSet_reorderChild (string simset, string child1, string child2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimSet_reorderChild'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simset,child1,child2));
StringBuilder sbsimset = null;
if (simset != null)
     sbsimset = new StringBuilder(simset, 1024);
StringBuilder sbchild1 = null;
if (child1 != null)
     sbchild1 = new StringBuilder(child1, 1024);
StringBuilder sbchild2 = null;
if (child2 != null)
     sbchild2 = new StringBuilder(child2, 1024);

SafeNativeMethods.mwle_fnSimSet_reorderChild(sbsimset, sbchild1, sbchild2);
}
/// <summary>
/// @brief Add the given comment as a child of the document.
///   @param comment String containing the comment.
/// 
///    @tsexample
///    // Create a new XML document with a header, a comment and single element.
///    %x = new SimXMLDocument();
///    %x.addHeader();
///    %x.addComment(\"This is a test comment\");
///    %x.addNewElement(\"NewElement\");
///    %x.saveFile(\"test.xml\");
///    // Produces the following file:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // !--This is a test comment-->
///    // NewElement />
///    @endtsexample
///    
///    @see readComment())
/// 
/// </summary>

public void fnSimXMLDocument_addComment (string simxmldocument, string comment)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_addComment'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,comment));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbcomment = null;
if (comment != null)
     sbcomment = new StringBuilder(comment, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_addComment(sbsimxmldocument, sbcomment);
}
/// <summary>
/// @brief Add the given text as a child of current Element.
/// 
///    Use getData() to retrieve any text from the current Element.
/// 
///    addData() and addText() may be used interchangeably.  As there is no 
///    difference between data and text, you may also use removeText() to clear 
///    any data from the current Element.
/// 
///    @param text String containing the text.
/// 
///    @tsexample
///    // Create a new XML document with a header and single element
///    // with some added data.
///    %x = new SimXMLDocument();
///    %x.addHeader();
///    %x.addNewElement(\"NewElement\");
///    %x.addData(\"Some text\");
///    %x.saveFile(\"test.xml\");
///    // Produces the following file:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement>Some text/NewElement>
///    @endtsexample
/// 
///    @see getData()
///    @see addText()
///    @see getText()
///    @see removeText())
/// 
/// </summary>

public void fnSimXMLDocument_addData (string simxmldocument, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_addData'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,text));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_addData(sbsimxmldocument, sbtext);
}
/// <summary>
/// @brief Add a XML header to a document.
/// 
///    Sometimes called a declaration, you typically add a standard header to 
///    the document before adding any elements.  SimXMLDocument always produces 
///    the following header:
///    ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///   
///    @tsexample
///    // Create a new XML document with just a header and single element.
///    %x = new SimXMLDocument();
///    %x.addHeader();
///    %x.addNewElement(\"NewElement\");
///    %x.saveFile(\"test.xml\");
///    // Produces the following file:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement />
///    @endtsexample)
/// 
/// </summary>

public void fnSimXMLDocument_addHeader (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_addHeader'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_addHeader(sbsimxmldocument);
}
/// <summary>
/// @brief Create a new element with the given name as child of current Element's 
///    parent and push it onto the Element stack making it the current one.
/// 
///    @note This differs from pushNewElement() in that it adds the new Element to the 
///    current Element's parent (or document if there is no parent Element).  This makes 
///    the new Element a sibling of the current one.
/// 
///    @param name XML tag for the new Element.
///    
///    @see pushNewElement())
/// 
/// </summary>

public void fnSimXMLDocument_addNewElement (string simxmldocument, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_addNewElement'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,name));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_addNewElement(sbsimxmldocument, sbname);
}
/// <summary>
/// @brief Add the given text as a child of current Element.
/// 
///    Use getText() to retrieve any text from the current Element and removeText() 
///    to clear any text.
/// 
///    addText() and addData() may be used interchangeably.
/// 
///    @param text String containing the text.
/// 
///    @tsexample
///    // Create a new XML document with a header and single element
///    // with some added text.
///    %x = new SimXMLDocument();
///    %x.addHeader();
///    %x.addNewElement(\"NewElement\");
///    %x.addText(\"Some text\");
///    %x.saveFile(\"test.xml\");
///    // Produces the following file:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement>Some text/NewElement>
///    @endtsexample
/// 
///    @see getText()
///    @see removeText()
///    @see addData()
///    @see getData())
/// 
/// </summary>

public void fnSimXMLDocument_addText (string simxmldocument, string text)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_addText'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,text));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbtext = null;
if (text != null)
     sbtext = new StringBuilder(text, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_addText(sbsimxmldocument, sbtext);
}
/// <summary>
/// @brief Get a string attribute from the current Element on the stack.
///    @param attributeName Name of attribute to retrieve.
///    @return The attribute string if found.  Otherwise returns an empty string.)
/// 
/// </summary>

public string fnSimXMLDocument_attribute (string simxmldocument, string attributeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_attribute'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,attributeName));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbattributeName = null;
if (attributeName != null)
     sbattributeName = new StringBuilder(attributeName, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_attribute(sbsimxmldocument, sbattributeName, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Tests if the requested attribute exists.
///    @param attributeName Name of attribute being queried for.
///    @return True if the attribute exists.)
/// 
/// </summary>

public bool fnSimXMLDocument_attributeExists (string simxmldocument, string attributeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_attributeExists'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,attributeName));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbattributeName = null;
if (attributeName != null)
     sbattributeName = new StringBuilder(attributeName, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_attributeExists(sbsimxmldocument, sbattributeName)>=1;
}
/// <summary>
/// @brief Set this document to its default state.
///    
///    Clears all Elements from the documents.  Equivalent to using reset()
///    
///    @see reset())
/// 
/// </summary>

public void fnSimXMLDocument_clear (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_clear'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_clear(sbsimxmldocument);
}
/// <summary>
/// @brief Clear the last error description.)
/// 
/// </summary>

public void fnSimXMLDocument_clearError (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_clearError'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_clearError(sbsimxmldocument);
}
/// <summary>
/// @brief Get the Element's value if it exists.
///    Usually returns the text from the Element.
///    @return The value from the Element, or an empty string if none is found.)
/// 
/// </summary>

public string fnSimXMLDocument_elementValue (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_elementValue'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_elementValue(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Obtain the name of the current Element's first attribute.
///    @return String containing the first attribute's name, or an empty string if none is found.
///    @see nextAttribute()
///    @see lastAttribute()
///    @see prevAttribute())
/// 
/// </summary>

public string fnSimXMLDocument_firstAttribute (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_firstAttribute'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_firstAttribute(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the text from the current Element.
/// 
///    Use addData() to add text to the current Element.
/// 
///    getData() and getText() may be used interchangeably.  As there is no 
///    difference between data and text, you may also use removeText() to clear 
///    any data from the current Element.
/// 
///    @return String containing the text in the current Element.
/// 
///    @tsexample
///    // Using the following test.xml file as an example:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement>Some data/NewElement>
/// 
///    // Load in the file
///    %x = new SimXMLDocument();
///    %x.loadFile(\"test.xml\");
/// 
///    // Make the first Element the current one
///    %x.pushFirstChildElement(\"NewElement\");
/// 
///    // Store the current Element's data ('Some data' in this example)
///    // into 'result'
///    %result = %x.getData();
///    echo( %result );
///    @endtsexample
///    
///    @see addData()
///    @see addText()
///    @see getText()
///    @see removeText())
/// 
/// </summary>

public string fnSimXMLDocument_getData (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_getData'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_getData(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get last error description.
///    @return A string of the last error message.)
/// 
/// </summary>

public string fnSimXMLDocument_getErrorDesc (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_getErrorDesc'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_getErrorDesc(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the text from the current Element.
/// 
///    Use addText() to add text to the current Element and removeText() 
///    to clear any text.
/// 
///    getText() and getData() may be used interchangeably.
/// 
///    @return String containing the text in the current Element.
/// 
///    @tsexample
///    // Using the following test.xml file as an example:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement>Some text/NewElement>
/// 
///    // Load in the file
///    %x = new SimXMLDocument();
///    %x.loadFile(\"test.xml\");
/// 
///    // Make the first Element the current one
///    %x.pushFirstChildElement(\"NewElement\");
/// 
///    // Store the current Element's text ('Some text' in this example)
///    // into 'result'
///    %result = %x.getText();
///    echo( %result );
///    @endtsexample
///    
///    @see addText()
///    @see removeText()
///    @see addData()
///    @see getData())
/// 
/// </summary>

public string fnSimXMLDocument_getText (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_getText'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_getText(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Obtain the name of the current Element's last attribute.
///    @return String containing the last attribute's name, or an empty string if none is found.
///    @see prevAttribute()
///    @see firstAttribute()
///    @see lastAttribute())
/// 
/// </summary>

public string fnSimXMLDocument_lastAttribute (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_lastAttribute'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_lastAttribute(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Load in given filename and prepare it for use.
///    @note Clears the current document's contents.
///    @param fileName Name and path of XML document
///    @return True if the file was loaded successfully.)
/// 
/// </summary>

public bool fnSimXMLDocument_loadFile (string simxmldocument, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_loadFile'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,fileName));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_loadFile(sbsimxmldocument, sbfileName)>=1;
}
/// <summary>
/// @brief Get the name of the next attribute for the current Element after a call to firstAttribute().
///    @return String containing the next attribute's name, or an empty string if none is found.
///    @see firstAttribute()
///    @see lastAttribute()
///    @see prevAttribute())
/// 
/// </summary>

public string fnSimXMLDocument_nextAttribute (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_nextAttribute'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_nextAttribute(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Put the next sibling Element with the given name on the stack, making it the current one.
///    @param name String containing name of the next sibling.
///    @return True if the Element was found and made the current one.)
/// 
/// </summary>

public bool fnSimXMLDocument_nextSiblingElement (string simxmldocument, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_nextSiblingElement'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,name));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_nextSiblingElement(sbsimxmldocument, sbname)>=1;
}
/// <summary>
/// @brief Create a document from a XML string.
///    @note Clears the current document's contents.
///    @param xmlString Valid XML to parse and store as a document.)
/// 
/// </summary>

public void fnSimXMLDocument_parse (string simxmldocument, string xmlString)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_parse'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,xmlString));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbxmlString = null;
if (xmlString != null)
     sbxmlString = new StringBuilder(xmlString, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_parse(sbsimxmldocument, sbxmlString);
}
/// <summary>
/// @brief Pop the last Element off the stack.)
/// 
/// </summary>

public void fnSimXMLDocument_popElement (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_popElement'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_popElement(sbsimxmldocument);
}
/// <summary>
/// @brief Get the name of the previous attribute for the current Element after a call to lastAttribute().
///    @return String containing the previous attribute's name, or an empty string if none is found.
///    @see lastAttribute()
///    @see firstAttribute()
///    @see nextAttribute())
/// 
/// </summary>

public string fnSimXMLDocument_prevAttribute (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_prevAttribute'" + string.Format("\"{0}\" ",simxmldocument));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_prevAttribute(sbsimxmldocument, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Push the child Element at the given index onto the stack, making it the current one.
///    @param index Numerical index of Element being pushed.
///    @return True if the Element was found and made the current one.)
/// 
/// </summary>

public bool fnSimXMLDocument_pushChildElement (string simxmldocument, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_pushChildElement'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,index));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_pushChildElement(sbsimxmldocument, index)>=1;
}
/// <summary>
/// @brief Push the first child Element with the given name onto the stack, making it the current Element.
/// 
///    @param name String containing name of the child Element.
///    @return True if the Element was found and made the current one.
/// 
///    @tsexample
///    // Using the following test.xml file as an example:
///    // ?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>
///    // NewElement>Some text/NewElement>
/// 
///    // Load in the file
///    %x = new SimXMLDocument();
///    %x.loadFile(\"test.xml\");
/// 
///    // Make the first Element the current one
///    %x.pushFirstChildElement(\"NewElement\");
/// 
///    // Store the current Element's text ('Some text' in this example)
///    // into 'result'
///    %result = %x.getText();
///    echo( %result );
///    @endtsexample)
/// 
/// </summary>

public bool fnSimXMLDocument_pushFirstChildElement (string simxmldocument, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_pushFirstChildElement'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,name));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_pushFirstChildElement(sbsimxmldocument, sbname)>=1;
}
/// <summary>
/// @brief Create a new element with the given name as child of current Element 
///    and push it onto the Element stack making it the current one.
/// 
///    @note This differs from addNewElement() in that it adds the new Element as a 
///    child of the current Element (or a child of the document if no Element exists).
/// 
///    @param name XML tag for the new Element.
/// 
///    @see addNewElement())
/// 
/// </summary>

public void fnSimXMLDocument_pushNewElement (string simxmldocument, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_pushNewElement'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,name));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_pushNewElement(sbsimxmldocument, sbname);
}
/// <summary>
/// Gives the comment at the specified index, if any.
/// 
///    Unlike addComment() that only works at the document level, readComment() may read 
///    comments from the document or any child Element.  The current Element (or document 
///    if no Elements have been pushed to the stack) is the parent for any comments, and the 
///    provided index is the number of comments in to read back.
/// 
///    @param index Comment index number to query from the current Element stack
///    @return String containing the comment, or an empty string if no comment is found.
/// 
///    @see addComment())
/// 
/// </summary>

public string fnSimXMLDocument_readComment (string simxmldocument, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_readComment'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_readComment(sbsimxmldocument, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Remove any text on the current Element.
/// 
///    Use getText() to retrieve any text from the current Element and addText() 
///    to add text to the current Element.  As getData() and addData() are equivalent 
///    to getText() and addText(), removeText() will also remove any data from the 
///    current Element.
///    
///    @see addText()
///    @see getText()
///    @see addData()
///    @see getData())
/// 
/// </summary>

public void fnSimXMLDocument_removeText (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_removeText'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_removeText(sbsimxmldocument);
}
/// <summary>
/// @brief Set this document to its default state.
///    
///    Clears all Elements from the documents.  Equivalent to using clear()
///    
///    @see clear())
/// 
/// </summary>

public void fnSimXMLDocument_reset (string simxmldocument)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_reset'" + string.Format("\"{0}\" ",simxmldocument));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_reset(sbsimxmldocument);
}
/// <summary>
/// @brief Save document to the given file name.
///    @param fileName Path and name of XML file to save to.
///    @return True if the file was successfully saved.)
/// 
/// </summary>

public bool fnSimXMLDocument_saveFile (string simxmldocument, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_saveFile'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,fileName));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fnSimXMLDocument_saveFile(sbsimxmldocument, sbfileName)>=1;
}
/// <summary>
/// @brief Set the attribute of the current Element on the stack to the given value.
///    @param attributeName Name of attribute being changed
///    @param value New value to assign to the attribute)
/// 
/// </summary>

public void fnSimXMLDocument_setAttribute (string simxmldocument, string attributeName, string value)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_setAttribute'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",simxmldocument,attributeName,value));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbattributeName = null;
if (attributeName != null)
     sbattributeName = new StringBuilder(attributeName, 1024);
StringBuilder sbvalue = null;
if (value != null)
     sbvalue = new StringBuilder(value, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_setAttribute(sbsimxmldocument, sbattributeName, sbvalue);
}
/// <summary>
/// @brief Add the given SimObject's fields as attributes of the current Element on the stack.
///    @param objectID ID of SimObject being copied.)
/// 
/// </summary>

public void fnSimXMLDocument_setObjectAttributes (string simxmldocument, string objectID)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnSimXMLDocument_setObjectAttributes'" + string.Format("\"{0}\" \"{1}\" ",simxmldocument,objectID));
StringBuilder sbsimxmldocument = null;
if (simxmldocument != null)
     sbsimxmldocument = new StringBuilder(simxmldocument, 1024);
StringBuilder sbobjectID = null;
if (objectID != null)
     sbobjectID = new StringBuilder(objectID, 1024);

SafeNativeMethods.mwle_fnSimXMLDocument_setObjectAttributes(sbsimxmldocument, sbobjectID);
}
/// <summary>
/// @brief Copy from another StreamObject into this StreamObject
///    @param other The StreamObject to copy from.
///    @return True if the copy was successful.)
/// 
/// </summary>

public bool fnStreamObject_copyFrom (string streamobject, string other)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_copyFrom'" + string.Format("\"{0}\" \"{1}\" ",streamobject,other));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);
StringBuilder sbother = null;
if (other != null)
     sbother = new StringBuilder(other, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_copyFrom(sbstreamobject, sbother)>=1;
}
/// <summary>
/// @brief Gets the position in the stream
///    
///    The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by 
///    five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. 
///    For StreamObject, when you read in the line the position is increased by the number of characters parsed, 
///    the null terminator, and a newline.
///    
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    // This file contains two lines of text repeated:
///    // Hello World
///    // Hello World
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Read in the first line
///    %line = %fsObject.readLine();
///    // Get the position of the stream
///    %position = %fsObject.getPosition();
///    // Print the current position
///    // Should be 13, 10 for the words, 1 for the space, 1 for the null terminator, and 1 for the newline
///    echo(%position);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return Number of bytes which stream has parsed so far, null terminators and newlines are included
///    
///    @see setPosition())
/// 
/// </summary>

public int fnStreamObject_getPosition (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_getPosition'" + string.Format("\"{0}\" ",streamobject));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_getPosition(sbstreamobject);
}
/// <summary>
/// @brief Gets a printable string form of the stream's status
///    
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Get the status and print it
///    %status = %fsObject.getStatus();
///    echo(%status);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return String containing status constant, one of the following:
/// 
///    	OK - Stream is active and no file errors
/// 
///    	IOError - Something went wrong during read or writing the stream
/// 
///    	EOS - End of Stream reached (mostly for reads)
/// 
///    	IllegalCall - An unsupported operation used.  Always w/ accompanied by AssertWarn
/// 
///      Closed - Tried to operate on a closed stream (or detached filter)
/// 
///    	UnknownError - Catch all for an error of some kind
/// 
///    	Invalid - Entire stream is invalid)
/// 
/// </summary>

public string fnStreamObject_getStatus (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_getStatus'" + string.Format("\"{0}\" ",streamobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

SafeNativeMethods.mwle_fnStreamObject_getStatus(sbstreamobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the size of the stream
///    
///    The size is dependent on the type of stream being used. If it is a file stream, returned value will 
///    be the size of the file. If it is a memory stream, it will be the size of the allocated buffer.
///       
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    // This file contains the following two lines:
///    // HelloWorld
///    // HelloWorld
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Found out how large the file stream is
///    // Then print it to the console
///    // Should be 22
///    %streamSize = %fsObject.getStreamSize();
///    echo(%streamSize);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return Size of stream, in bytes)
/// 
/// </summary>

public int fnStreamObject_getStreamSize (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_getStreamSize'" + string.Format("\"{0}\" ",streamobject));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_getStreamSize(sbstreamobject);
}
/// <summary>
/// @brief Tests if the stream has reached the end of the file
///    
///    This is an alternative name for isEOS. Both functions are interchangeable. This simply exists 
///    for those familiar with some C++ file I/O standards.
///    
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Keep reading until we reach the end of the file
///    while( !%fsObject.isEOF() )
///    {
///       %line = %fsObject.readLine();
///       echo(%line);
///    }
///    // Made it to the end
///    echo(\"Finished reading file\");
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return True if the parser has reached the end of the file, false otherwise
///    
///    @see isEOS())
/// 
/// </summary>

public bool fnStreamObject_isEOF (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_isEOF'" + string.Format("\"{0}\" ",streamobject));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_isEOF(sbstreamobject)>=1;
}
/// <summary>
/// @brief Tests if the stream has reached the end of the file
///    
///    This is an alternative name for isEOF. Both functions are interchangeable. This simply exists 
///    for those familiar with some C++ file I/O standards.
/// 
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Keep reading until we reach the end of the file
///    while( !%fsObject.isEOS() )
///    {
///       %line = %fsObject.readLine();
///       echo(%line);
///    }
///    // Made it to the end
///    echo(\"Finished reading file\");
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return True if the parser has reached the end of the file, false otherwise
/// 
///    @see isEOF())
/// 
/// </summary>

public bool fnStreamObject_isEOS (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_isEOS'" + string.Format("\"{0}\" ",streamobject));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_isEOS(sbstreamobject)>=1;
}
/// <summary>
/// @brief Read a line from the stream.
///    
///    Emphasis on *line*, as in you cannot parse individual characters or chunks of data. 
///    There is no limitation as to what kind of data you can read.
///    
///    @tsexample
///    // Create a file stream object for reading
///    // This file contains the following two lines:
///    // HelloWorld
///    // HelloWorld
///    %fsObject = new FileStreamObject();
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Read in the first line
///    %line = %fsObject.readLine();
///    // Print the line we just read
///    echo(%line);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return String containing the line of data that was just read
///    
///    @see writeLine())
/// 
/// </summary>

public string fnStreamObject_readLine (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_readLine'" + string.Format("\"{0}\" ",streamobject));
var returnbuff = new StringBuilder(16384);
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

SafeNativeMethods.mwle_fnStreamObject_readLine(sbstreamobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Read in a string up to the given maximum number of characters.
///    @param maxLength The maximum number of characters to read in.
///    @return The string that was read from the stream.
///    @see writeLongString()
///    
///    @note When working with these particular string reading and writing methods, the stream 
///    begins with the length of the string followed by the string itself, and does not include 
///    a NULL terminator.)
/// 
/// </summary>

public string fnStreamObject_readLongString (string streamobject, int maxLength)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_readLongString'" + string.Format("\"{0}\" \"{1}\" ",streamobject,maxLength));
var returnbuff = new StringBuilder(1024);
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

SafeNativeMethods.mwle_fnStreamObject_readLongString(sbstreamobject, maxLength, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Read a string up to a maximum of 256 characters
///    @return The string that was read from the stream.
///    @see writeString()
///    
///    @note When working with these particular string reading and writing methods, the stream 
///    begins with the length of the string followed by the string itself, and does not include 
///    a NULL terminator.)
/// 
/// </summary>

public string fnStreamObject_readString (string streamobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_readString'" + string.Format("\"{0}\" ",streamobject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

SafeNativeMethods.mwle_fnStreamObject_readString(sbstreamobject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Read in a string and place it on the string table.
///    @param caseSensitive If false then case will not be taken into account when attempting 
///    to match the read in string with what is already in the string table.
///    @return The string that was read from the stream.
///    @see writeString()
///    
///    @note When working with these particular string reading and writing methods, the stream 
///    begins with the length of the string followed by the string itself, and does not include 
///    a NULL terminator.)
/// 
/// </summary>

public string fnStreamObject_readSTString (string streamobject, bool caseSensitive)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_readSTString'" + string.Format("\"{0}\" \"{1}\" ",streamobject,caseSensitive));
var returnbuff = new StringBuilder(1024);
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

SafeNativeMethods.mwle_fnStreamObject_readSTString(sbstreamobject, caseSensitive, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Gets the position in the stream
///    
///    The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by 
///    five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. 
///    For StreamObject, when you read in the line the position is increased by the number of characters parsed, 
///    the null terminator, and a newline. Using setPosition allows you to skip to specific points of the file.
///    
///    @tsexample
///    // Create a file stream object for reading
///    %fsObject = new FileStreamObject();
///    // Open a file for reading
///    // This file contains the following two lines:
///    // 11111111111
///    // Hello World
///    %fsObject.open(\"./test.txt\", \"read\");
///    // Skip ahead by 12, which will bypass the first line entirely
///    %fsObject.setPosition(12);
///    // Read in the next line
///    %line = %fsObject.readLine();
///    // Print the line just read in, should be \"Hello World\"
///    echo(%line);
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
/// 
///    @return Number of bytes which stream has parsed so far, null terminators and newlines are included
///    
///    @see getPosition())
/// 
/// </summary>

public bool fnStreamObject_setPosition (string streamobject, int newPosition)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_setPosition'" + string.Format("\"{0}\" \"{1}\" ",streamobject,newPosition));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);

return  SafeNativeMethods.mwle_fnStreamObject_setPosition(sbstreamobject, newPosition)>=1;
}
/// <summary>
/// @brief Write a line to the stream, if it was opened for writing.
///    
///    There is no limit as to what kind of data you can write. Any format and data is allowable, not just text. 
///    Be careful of what you write, as whitespace, current values, and literals will be preserved.
/// 
///    @param line The data we are writing out to file.
///    
///    @tsexample
///    // Create a file stream
///    %fsObject = new FileStreamObject();
///    // Open the file for writing
///    // If it does not exist, it is created. If it does exist, the file is cleared
///    %fsObject.open(\"./test.txt\", \"write\");
///    // Write a line to the file
///    %fsObject.writeLine(\"Hello World\");
///    // Write another line to the file
///    %fsObject.writeLine(\"Documentation Rocks!\");
///    // Always remember to close a file stream when finished
///    %fsObject.close();
///    @endtsexample
///    
///    @see readLine())
/// 
/// </summary>

public void fnStreamObject_writeLine (string streamobject, string line)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_writeLine'" + string.Format("\"{0}\" \"{1}\" ",streamobject,line));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);
StringBuilder sbline = null;
if (line != null)
     sbline = new StringBuilder(line, 1024);

SafeNativeMethods.mwle_fnStreamObject_writeLine(sbstreamobject, sbline);
}
/// <summary>
/// @brief Write out a string up to the maximum number of characters.
///    @param maxLength The maximum number of characters that will be written.
///    @param string The string to write out to the stream.
///    @see readLongString()
///    
///    @note When working with these particular string reading and writing methods, the stream 
///    begins with the length of the string followed by the string itself, and does not include 
///    a NULL terminator.)
/// 
/// </summary>

public void fnStreamObject_writeLongString (string streamobject, int maxLength, string stringx)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_writeLongString'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",streamobject,maxLength,stringx));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);
StringBuilder sbstringx = null;
if (stringx != null)
     sbstringx = new StringBuilder(stringx, 1024);

SafeNativeMethods.mwle_fnStreamObject_writeLongString(sbstreamobject, maxLength, sbstringx);
}
/// <summary>
/// @brief Write out a string with a default maximum length of 256 characters.
///    @param string The string to write out to the stream
///    @param maxLength The maximum string length to write out with a default of 256 characters.  This 
///    value should not be larger than 256 as it is written to the stream as a single byte.
///    @see readString()
///    
///    @note When working with these particular string reading and writing methods, the stream 
///    begins with the length of the string followed by the string itself, and does not include 
///    a NULL terminator.)
/// 
/// </summary>

public void fnStreamObject_writeString (string streamobject, string stringx, int maxLength)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnStreamObject_writeString'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",streamobject,stringx,maxLength));
StringBuilder sbstreamobject = null;
if (streamobject != null)
     sbstreamobject = new StringBuilder(streamobject, 1024);
StringBuilder sbstringx = null;
if (stringx != null)
     sbstringx = new StringBuilder(stringx, 1024);

SafeNativeMethods.mwle_fnStreamObject_writeString(sbstreamobject, sbstringx, maxLength);
}
/// <summary>
/// @brief Connect to the given address.
/// 
///    @param address Server address (including port) to connect to.
/// 
///    @tsexample
///       // Set the address.
///       %address = \"www.garagegames.com:80\";
/// 
///       // Inform this TCPObject to connect to the specified address.
///       %thisTCPObj.connect(%address);
///    @endtsexample)
/// 
/// </summary>

public void fnTCPObject_connect (string tcpobject, string address)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTCPObject_connect'" + string.Format("\"{0}\" \"{1}\" ",tcpobject,address));
StringBuilder sbtcpobject = null;
if (tcpobject != null)
     sbtcpobject = new StringBuilder(tcpobject, 1024);
StringBuilder sbaddress = null;
if (address != null)
     sbaddress = new StringBuilder(address, 1024);

SafeNativeMethods.mwle_fnTCPObject_connect(sbtcpobject, sbaddress);
}
/// <summary>
/// @brief Disconnect from whatever this TCPObject is currently connected to, if anything.
/// 
///    @tsexample
///       // Inform this TCPObject to disconnect from anything it is currently connected to.
///       %thisTCPObj.disconnect();
///    @endtsexample)
/// 
/// </summary>

public void fnTCPObject_disconnect (string tcpobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTCPObject_disconnect'" + string.Format("\"{0}\" ",tcpobject));
StringBuilder sbtcpobject = null;
if (tcpobject != null)
     sbtcpobject = new StringBuilder(tcpobject, 1024);

SafeNativeMethods.mwle_fnTCPObject_disconnect(sbtcpobject);
}
/// <summary>
/// @brief Start listening on the specified port for connections.
/// 
///    This method starts a listener which looks for incoming TCP connections to a port.  
///    You must overload the onConnectionRequest callback to create a new TCPObject to 
///    read, write, or reject the new connection.
/// 
///    @param port Port for this TCPObject to start listening for connections on.
/// 
///    @tsexample
/// 
///     // Create a listener on port 8080.
///     new TCPObject( TCPListener );
///     TCPListener.listen( 8080 );
/// 
///     function TCPListener::onConnectionRequest( %this, %address, %id )
///     {
///        // Create a new object to manage the connection.
///        new TCPObject( TCPClient, %id );
///     }
/// 
///     function TCPClient::onLine( %this, %line )
///     {
///        // Print the line of text from client.
///        echo( %line );
///     }
/// 
///    @endtsexample)
/// 
/// </summary>

public void fnTCPObject_listen (string tcpobject, uint port)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTCPObject_listen'" + string.Format("\"{0}\" \"{1}\" ",tcpobject,port));
StringBuilder sbtcpobject = null;
if (tcpobject != null)
     sbtcpobject = new StringBuilder(tcpobject, 1024);

SafeNativeMethods.mwle_fnTCPObject_listen(sbtcpobject, port);
}
/// <summary>
/// @brief Transmits the data string to the connected computer.
/// 
///    This method is used to send text data to the connected computer regardless if we initiated the 
///    connection using connect(), or listening to a port using listen().
/// 
///    @param data The data string to send.
/// 
///    @tsexample
///       // Set the command data
///       %data = \"GET \" @ $RSSFeed::serverURL @ \" HTTP/1.0\\r\\";
///       %data = %data @ \"Host: \" @ $RSSFeed::serverName @ \"\\r\\";
///       %data = %data @ \"User-Agent: \" @ $RSSFeed::userAgent @ \"\\r\\\r\\"
/// 
///       // Send the command to the connected server.
///       %thisTCPObj.send(%data);
///    @endtsexample)
/// 
/// </summary>

public void fnTCPObject_send (string tcpobject, string data)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTCPObject_send'" + string.Format("\"{0}\" \"{1}\" ",tcpobject,data));
StringBuilder sbtcpobject = null;
if (tcpobject != null)
     sbtcpobject = new StringBuilder(tcpobject, 1024);
StringBuilder sbdata = null;
if (data != null)
     sbdata = new StringBuilder(data, 1024);

SafeNativeMethods.mwle_fnTCPObject_send(sbtcpobject, sbdata);
}
/// <summary>
/// @brief Saves the terrain block's terrain file to the specified file name.
/// 
/// 				   @param fileName Name and path of file to save terrain data to.
/// 
/// 				   @return True if file save was successful, false otherwise)
/// 
/// </summary>

public bool fnTerrainBlock_save (string terrainblock, string fileName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTerrainBlock_save'" + string.Format("\"{0}\" \"{1}\" ",terrainblock,fileName));
StringBuilder sbterrainblock = null;
if (terrainblock != null)
     sbterrainblock = new StringBuilder(terrainblock, 1024);
StringBuilder sbfileName = null;
if (fileName != null)
     sbfileName = new StringBuilder(fileName, 1024);

return  SafeNativeMethods.mwle_fnTerrainBlock_save(sbterrainblock, sbfileName)>=1;
}
/// <summary>
///  )
/// 
/// </summary>

public void fnTimeOfDay_addTimeOfDayEvent (string timeofday, float elevation, string identifier)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTimeOfDay_addTimeOfDayEvent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",timeofday,elevation,identifier));
StringBuilder sbtimeofday = null;
if (timeofday != null)
     sbtimeofday = new StringBuilder(timeofday, 1024);
StringBuilder sbidentifier = null;
if (identifier != null)
     sbidentifier = new StringBuilder(identifier, 1024);

SafeNativeMethods.mwle_fnTimeOfDay_addTimeOfDayEvent(sbtimeofday, elevation, sbidentifier);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnTimeOfDay_animate (string timeofday, float elevation, float degreesPerSecond)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTimeOfDay_animate'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",timeofday,elevation,degreesPerSecond));
StringBuilder sbtimeofday = null;
if (timeofday != null)
     sbtimeofday = new StringBuilder(timeofday, 1024);

SafeNativeMethods.mwle_fnTimeOfDay_animate(sbtimeofday, elevation, degreesPerSecond);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnTimeOfDay_setDayLength (string timeofday, float seconds)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTimeOfDay_setDayLength'" + string.Format("\"{0}\" \"{1}\" ",timeofday,seconds));
StringBuilder sbtimeofday = null;
if (timeofday != null)
     sbtimeofday = new StringBuilder(timeofday, 1024);

SafeNativeMethods.mwle_fnTimeOfDay_setDayLength(sbtimeofday, seconds);
}
/// <summary>
/// )
/// 
/// </summary>

public void fnTimeOfDay_setPlay (string timeofday, bool enabled)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTimeOfDay_setPlay'" + string.Format("\"{0}\" \"{1}\" ",timeofday,enabled));
StringBuilder sbtimeofday = null;
if (timeofday != null)
     sbtimeofday = new StringBuilder(timeofday, 1024);

SafeNativeMethods.mwle_fnTimeOfDay_setPlay(sbtimeofday, enabled);
}
/// <summary>
///  )
/// 
/// </summary>

public void fnTimeOfDay_setTimeOfDay (string timeofday, float time)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTimeOfDay_setTimeOfDay'" + string.Format("\"{0}\" \"{1}\" ",timeofday,time));
StringBuilder sbtimeofday = null;
if (timeofday != null)
     sbtimeofday = new StringBuilder(timeofday, 1024);

SafeNativeMethods.mwle_fnTimeOfDay_setTimeOfDay(sbtimeofday, time);
}
/// <summary>
/// @brief Get the number of objects that are within the Trigger's bounds.
///    @see getObject())
/// 
/// </summary>

public int fnTrigger_getNumObjects (string trigger)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTrigger_getNumObjects'" + string.Format("\"{0}\" ",trigger));
StringBuilder sbtrigger = null;
if (trigger != null)
     sbtrigger = new StringBuilder(trigger, 1024);

return  SafeNativeMethods.mwle_fnTrigger_getNumObjects(sbtrigger);
}
/// <summary>
/// @brief Retrieve the requested object that is within the Trigger's bounds.
///    @param index Index of the object to get (range is 0 to getNumObjects()-1)
///    @returns The SimObjectID of the object, or -1 if the requested index is invalid.
///    @see getNumObjects())
/// 
/// </summary>

public int fnTrigger_getObject (string trigger, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTrigger_getObject'" + string.Format("\"{0}\" \"{1}\" ",trigger,index));
StringBuilder sbtrigger = null;
if (trigger != null)
     sbtrigger = new StringBuilder(trigger, 1024);

return  SafeNativeMethods.mwle_fnTrigger_getObject(sbtrigger, index);
}
/// <summary>
/// Attaches an object to this one.
///       @param obj The scene object to attach to us
///       @return true if successful, false if failed. This function will fail if the object passed 
///       is invalid or is not located directly above and within RayLength of this shape.)
/// 
/// </summary>

public bool fnTSAttachable_attachObject (string tsattachable, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSAttachable_attachObject'" + string.Format("\"{0}\" \"{1}\" ",tsattachable,obj));
StringBuilder sbtsattachable = null;
if (tsattachable != null)
     sbtsattachable = new StringBuilder(tsattachable, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnTSAttachable_attachObject(sbtsattachable, sbobj)>=1;
}
/// <summary>
/// Detaches all attached objects. Note: if UseAutoAttach is true when this is called, all of
///        the objects may be re-attached on the next tick.
///       @tsexample
///          // Dump all riders
///          %attachableObj.UseAutoAttach = false
///          %attachableObj.detachAll(); = false
///       @endtsexample)
/// 
/// </summary>

public void fnTSAttachable_detachAll (string tsattachable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSAttachable_detachAll'" + string.Format("\"{0}\" ",tsattachable));
StringBuilder sbtsattachable = null;
if (tsattachable != null)
     sbtsattachable = new StringBuilder(tsattachable, 1024);

SafeNativeMethods.mwle_fnTSAttachable_detachAll(sbtsattachable);
}
/// <summary>
/// Detaches an object from this one.
///       @param obj The scene object to be detached
///       @return true if successful, false if failed. This function will fail if the object passed 
///       is invalid or is not currently attached to this shape.)
/// 
/// </summary>

public bool fnTSAttachable_detachObject (string tsattachable, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSAttachable_detachObject'" + string.Format("\"{0}\" \"{1}\" ",tsattachable,obj));
StringBuilder sbtsattachable = null;
if (tsattachable != null)
     sbtsattachable = new StringBuilder(tsattachable, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnTSAttachable_detachObject(sbtsattachable, sbobj)>=1;
}
/// <summary>
/// Returns the attachment at the passed index value.)
/// 
/// </summary>

public string fnTSAttachable_getAttachment (string tsattachable, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSAttachable_getAttachment'" + string.Format("\"{0}\" \"{1}\" ",tsattachable,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbtsattachable = null;
if (tsattachable != null)
     sbtsattachable = new StringBuilder(tsattachable, 1024);

SafeNativeMethods.mwle_fnTSAttachable_getAttachment(sbtsattachable, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the number of objects that are currently attached.)
/// 
/// </summary>

public int fnTSAttachable_getNumAttachments (string tsattachable)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSAttachable_getNumAttachments'" + string.Format("\"{0}\" ",tsattachable));
StringBuilder sbtsattachable = null;
if (tsattachable != null)
     sbtsattachable = new StringBuilder(tsattachable, 1024);

return  SafeNativeMethods.mwle_fnTSAttachable_getNumAttachments(sbtsattachable);
}
/// <summary>
/// ,NULL,NULL),
///    @brief Change one of the materials on the shape.
/// 
///    This method changes materials per mapTo with others. The material that 
///    is being replaced is mapped to unmapped_mat as a part of this transition.
/// 
///    @note Warning, right now this only sort of works. It doesn't do a live 
///    update like it should.
/// 
///    @param mapTo the name of the material target to remap (from getTargetName)
///    @param oldMat the old Material that was mapped 
///    @param newMat the new Material to map
/// 
///    @tsexample
///       // remap the first material in the shape
///       %mapTo = %obj.getTargetName( 0 );
///       %obj.changeMaterial( %mapTo, 0, MyMaterial );
///    @endtsexample )
/// 
/// </summary>

public void fnTSDynamic_changeMaterial (string tsdynamic, string mapTo, string oldMat, string newMat)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSDynamic_changeMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsdynamic,mapTo,oldMat,newMat));
StringBuilder sbtsdynamic = null;
if (tsdynamic != null)
     sbtsdynamic = new StringBuilder(tsdynamic, 1024);
StringBuilder sbmapTo = null;
if (mapTo != null)
     sbmapTo = new StringBuilder(mapTo, 1024);
StringBuilder sboldMat = null;
if (oldMat != null)
     sboldMat = new StringBuilder(oldMat, 1024);
StringBuilder sbnewMat = null;
if (newMat != null)
     sbnewMat = new StringBuilder(newMat, 1024);

SafeNativeMethods.mwle_fnTSDynamic_changeMaterial(sbtsdynamic, sbmapTo, sboldMat, sbnewMat);
}
/// <summary>
/// @brief Get the model filename used by this shape.
/// 
///    @return the shape filename
///    @tsexample
/// 		// Acquire the model filename used on this shape.
/// 		%modelFilename = %obj.getModelFile();
///    @endtsexample
///    )
/// 
/// </summary>

public string fnTSDynamic_getModelFile (string tsdynamic)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSDynamic_getModelFile'" + string.Format("\"{0}\" ",tsdynamic));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsdynamic = null;
if (tsdynamic != null)
     sbtsdynamic = new StringBuilder(tsdynamic, 1024);

SafeNativeMethods.mwle_fnTSDynamic_getModelFile(sbtsdynamic, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of materials in the shape.
///    @return the number of materials in the shape.
///    @see getTargetName())
/// 
/// </summary>

public int fnTSDynamic_getTargetCount (string tsdynamic)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSDynamic_getTargetCount'" + string.Format("\"{0}\" ",tsdynamic));
StringBuilder sbtsdynamic = null;
if (tsdynamic != null)
     sbtsdynamic = new StringBuilder(tsdynamic, 1024);

return  SafeNativeMethods.mwle_fnTSDynamic_getTargetCount(sbtsdynamic);
}
/// <summary>
/// Get the name of the indexed shape material.
///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
///    @return the name of the indexed material.
///    @see getTargetCount())
/// 
/// </summary>

public string fnTSDynamic_getTargetName (string tsdynamic, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSDynamic_getTargetName'" + string.Format("\"{0}\" \"{1}\" ",tsdynamic,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsdynamic = null;
if (tsdynamic != null)
     sbtsdynamic = new StringBuilder(tsdynamic, 1024);

SafeNativeMethods.mwle_fnTSDynamic_getTargetName(sbtsdynamic, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the looping state for the shape.)
/// 
/// </summary>

public bool fnTSPathShape_getLooping (string tspathshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_getLooping'" + string.Format("\"{0}\" ",tspathshape));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

return  SafeNativeMethods.mwle_fnTSPathShape_getLooping(sbtspathshape)>=1;
}
/// <summary>
/// Returns the number of nodes on the shape's path.)
/// 
/// </summary>

public int fnTSPathShape_getNodeCount (string tspathshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_getNodeCount'" + string.Format("\"{0}\" ",tspathshape));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

return  SafeNativeMethods.mwle_fnTSPathShape_getNodeCount(sbtspathshape);
}
/// <summary>
/// Get the current position of the shape along the path (0.0 - lastNode - 1).)
/// 
/// </summary>

public float fnTSPathShape_getPathPosition (string tspathshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_getPathPosition'" + string.Format("\"{0}\" ",tspathshape));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

return  SafeNativeMethods.mwle_fnTSPathShape_getPathPosition(sbtspathshape);
}
/// <summary>
/// Removes the knot at the front of the shape's path.
/// 													@tsexample
/// 														// Remove the first knot in the shape's path.
/// 														%pathShape.popFront();
/// 													@endtsexample)
/// 
/// </summary>

public void fnTSPathShape_popFront (string tspathshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_popFront'" + string.Format("\"{0}\" ",tspathshape));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_popFront(sbtspathshape);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the back of a shape's path.
/// 													@param transform Transform for the new knot.  In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\"
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the shape to add a new knot to the back of its path
/// 														%pathShape.pushBack(%transform,%speed,%type,%path);
/// 													@endtsexample)
/// 
/// </summary>

public void fnTSPathShape_pushBack (string tspathshape, string transform, float speed, string type, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_pushBack'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",tspathshape,transform,speed,type,path));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnTSPathShape_pushBack(sbtspathshape, sbtransform, speed, sbtype, sbpath);
}
/// <summary>
/// Normal, Linear), 
/// 											      @brief Adds a new knot to the front of a path shape's path.
/// 													@param transform Transform for the new knot. In the form of \"x y z ax ay az aa\" such as returned by SceneObject::getTransform()
/// 													@param speed Speed setting for this knot.
/// 													@param type Knot type (Normal, Position Only, Kink).
/// 													@param path %Path type (Linear, Spline).
/// 													@tsexample
/// 														// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
/// 														%transform = \"15.0 5.0 5.0 1.4 1.0 0.2 1.0\"
/// 														// Speed setting for knot.
/// 														%speed = \"1.0\";
/// 														// Knot type. (Normal, Position Only, Kink)
/// 														%type = \"Normal\";
/// 														// Path Type. (Linear, Spline)
/// 														%path = \"Linear\";
/// 														// Inform the shape to add a new knot to the front of its path
/// 														%pathShape.pushFront(%transform, %speed, %type, %path);
/// 													@endtsexample)
/// 
/// </summary>

public void fnTSPathShape_pushFront (string tspathshape, string transform, float speed, string type, string path)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_pushFront'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",tspathshape,transform,speed,type,path));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);
StringBuilder sbtransform = null;
if (transform != null)
     sbtransform = new StringBuilder(transform, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbpath = null;
if (path != null)
     sbpath = new StringBuilder(path, 1024);

SafeNativeMethods.mwle_fnTSPathShape_pushFront(sbtspathshape, sbtransform, speed, sbtype, sbpath);
}
/// <summary>
/// @brief Clear the shapes's path and optionally initializes the first node with the shapes current transform and speed.
///          The shapes movement is stopped and any current path is cleared. The target and position values are both reset to 0. 
///          When makeFirstKnot is true a new knot is created and pushed onto the path.
///          @param speed Speed for the first knot if created.
///          @param makeFirstKnot Initialize a new path with the current shape transform.
///          @param initFromPath Initialize the knot type and smoothing values from the current path.)
/// 
/// </summary>

public void fnTSPathShape_reset (string tspathshape, float speed, bool makeFirstKnot, bool initFromPath)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_reset'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tspathshape,speed,makeFirstKnot,initFromPath));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_reset(sbtspathshape, speed, makeFirstKnot, initFromPath);
}
/// <summary>
/// Sets whether the path should loop or stop at the last node.
/// 													@param isLooping New loop flag true/false.)
/// 
/// </summary>

public void fnTSPathShape_setLooping (string tspathshape, bool isLooping)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_setLooping'" + string.Format("\"{0}\" \"{1}\" ",tspathshape,isLooping));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_setLooping(sbtspathshape, isLooping);
}
/// <summary>
/// Set the movement state for this shape.
/// 													@param newState New movement state type for this shape. Forward, Backward or Stop.)
/// 
/// </summary>

public void fnTSPathShape_setMoveState (string tspathshape, int newState)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_setMoveState'" + string.Format("\"{0}\" \"{1}\" ",tspathshape,newState));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_setMoveState(sbtspathshape, newState);
}
/// <summary>
/// Set the current position of the shape along the path.
/// 													@param position Position along the path, from 0.0 (path start) - 1.0 (path end), to place the shape.)
/// 
/// </summary>

public void fnTSPathShape_setPathPosition (string tspathshape, float position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_setPathPosition'" + string.Format("\"{0}\" \"{1}\" ",tspathshape,position));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_setPathPosition(sbtspathshape, position);
}
/// <summary>
/// @brief Set the movement target for this shape along its path.
///                                        The shape will attempt to move along the path to the given target without going past the loop node. 
///                                        Once the shape arrives at the target,the onTargetReached() callback will be triggered and the target 
///                                        state will be cleared.
/// 													@param position Target position, between 0.0 (path start) and nodeCount - 1 (path end), for the 
///                                        shape to move to along its path.)
/// 
/// </summary>

public void fnTSPathShape_setTarget (string tspathshape, float position)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSPathShape_setTarget'" + string.Format("\"{0}\" \"{1}\" ",tspathshape,position));
StringBuilder sbtspathshape = null;
if (tspathshape != null)
     sbtspathshape = new StringBuilder(tspathshape, 1024);

SafeNativeMethods.mwle_fnTSPathShape_setTarget(sbtspathshape, position);
}
/// <summary>
/// Autofit a mesh primitive or set of convex hulls to the shape geometry. Hulls 
///    may optionally be converted to boxes, spheres and/or capsules based on their 
///    volume.
///    @param size size for this detail level
///    @param type one of: box, sphere, capsule, 10-dop x, 10-dop y, 10-dop z, 18-dop, 
///       26-dop, convex hulls. See the Shape Editor documentation for more details 
///       about these types.
///    @param target geometry to fit collision mesh(es) to; either \"bounds\" (for the 
///       whole shape), or the name of an object in the shape
///    @param depth maximum split recursion depth (hulls only)
///    @param merge volume % threshold used to merge hulls together (hulls only)
///    @param concavity volume % threshold used to detect concavity (hulls only)
///    @param maxVerts maximum number of vertices per hull (hulls only)
///    @param boxMaxError max % volume difference for a hull to be converted to a 
///       box (hulls only)
///    @param sphereMaxError max % volume difference for a hull to be converted to 
///       a sphere (hulls only)
///    @param capsuleMaxError max % volume difference for a hull to be converted to 
///       a capsule (hulls only)
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addCollisionDetail( -1, \"box\", \"bounds\" );
///    %this.addCollisionDetail( -1, \"convex hulls\", \"bounds\", 4, 30, 30, 32, 0, 0, 0 );
///    %this.addCollisionDetail( -1, \"convex hulls\", \"bounds\", 4, 30, 30, 32, 50, 50, 50 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addCollisionDetail (string tsshapeconstructor, int size, string type, string target, int depth, float merge, float concavity, int maxVerts, float boxMaxError, float sphereMaxError, float capsuleMaxError)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addCollisionDetail'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" ",tsshapeconstructor,size,type,target,depth,merge,concavity,maxVerts,boxMaxError,sphereMaxError,capsuleMaxError));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbtarget = null;
if (target != null)
     sbtarget = new StringBuilder(target, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addCollisionDetail(sbtsshapeconstructor, size, sbtype, sbtarget, depth, merge, concavity, maxVerts, boxMaxError, sphereMaxError, capsuleMaxError)>=1;
}
/// <summary>
/// Add (or edit) an imposter detail level to the shape.
///    If the shape already contains an imposter detail level, this command will 
///    simply change the imposter settings
///    @param size size of the imposter detail level
///    @param equatorSteps defines the number of snapshots to take around the 
///    equator. Imagine the object being rotated around the vertical axis, then 
///    a snapshot taken at regularly spaced intervals.
///    @param polarSteps defines the number of snapshots taken between the poles 
///    (top and bottom), at each equator step. eg. At each equator snapshot, 
///    snapshots are taken at regular intervals between the poles.
///    @param dl the detail level to use when generating the snapshots. Note that 
///    this is an array index rather than a detail size. So if an object has detail 
///    sizes of: 200, 150, and 40, then setting @a dl to 1 will generate the snapshots 
///    using detail size 150.
///    @param dim defines the size of the imposter images in pixels. The larger the 
///    number, the more detailed the billboard will be.
///    @param includePoles flag indicating whether to include the \"pole\" snapshots. 
///    ie. the views from the top and bottom of the object.
///    @param polar_angle if pole snapshots are active (@a includePoles is true), this 
///    parameter defines the camera angle (in degrees) within which to render the 
///    pole snapshot. eg. if polar_angle is set to 25 degrees, then the snapshot 
///    taken at the pole (looking directly down or up at the object) will be rendered 
///    when the camera is within 25 degrees of the pole.
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addImposter( 2, 4, 0, 0, 64, false, 0 );
///    %this.addImposter( 2, 4, 2, 0, 64, true, 10 );   // this command would edit the existing imposter detail level
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_addImposter (string tsshapeconstructor, int size, int equatorSteps, int polarSteps, int dl, int dim, bool includePoles, float polarAngle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addImposter'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" ",tsshapeconstructor,size,equatorSteps,polarSteps,dl,dim,includePoles,polarAngle));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addImposter(sbtsshapeconstructor, size, equatorSteps, polarSteps, dl, dim, includePoles, polarAngle);
}
/// <summary>
/// Add geometry from another DTS or DAE shape file into this shape.
///    Any materials required by the source mesh are also copied into this shape.br>
///    @param meshName full name (object name + detail size) of the new mesh. If 
///       no detail size is present at the end of the name, a value of 2 is used.br>
///       An underscore before the number at the end of the name will be interpreted as 
///       a negative sign. eg. \"MyMesh_4\" will be interpreted as \"MyMesh-4\".
///    @param srcShape name of a shape file (DTS or DAE) that contains the mesh
///    @param srcMesh the full name (object name + detail size) of the mesh to 
///       copy from the DTS/DAE file into this shape/li>
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addMesh( \"ColMesh-1\", \"./collision.dts\", \"ColMesh\", \"Col-1\" );
///    %this.addMesh( \"SimpleShape10\", \"./testShape.dae\", \"MyMesh2\",  );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addMesh (string tsshapeconstructor, string meshName, string srcShape, string srcMesh)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addMesh'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsshapeconstructor,meshName,srcShape,srcMesh));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbmeshName = null;
if (meshName != null)
     sbmeshName = new StringBuilder(meshName, 1024);
StringBuilder sbsrcShape = null;
if (srcShape != null)
     sbsrcShape = new StringBuilder(srcShape, 1024);
StringBuilder sbsrcMesh = null;
if (srcMesh != null)
     sbsrcMesh = new StringBuilder(srcMesh, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addMesh(sbtsshapeconstructor, sbmeshName, sbsrcShape, sbsrcMesh)>=1;
}
/// <summary>
/// Add a new node.
///    @param name name for the new node (must not already exist)
///    @param parentName name of an existing node to be the parent of the new node. 
///    If empty (\"\"), the new node will be at the root level of the node hierarchy.
///    @param txfm (optional) transform string of the form: \"pos.x pos.y pos.z rot.x rot.y rot.z rot.angle\"
///    @param isworld (optional) flag to set the local-to-parent or the global 
///    transform. If false, or not specified, the position and orientation are 
///    treated as relative to the node's parent.
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addNode( \"Nose\", \"Bip01 Head\", \"0 2 2 0 0 1 0\" );
///    %this.addNode( \"myRoot\", \"\", \"0 0 4 0 0 1 1.57\" );
///    %this.addNode( \"Nodes\", \"Bip01 Head\", \"0 2 0 0 0 1 0\", true );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addNode (string tsshapeconstructor, string name, string parentName, string txfm, bool isWorld)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addNode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",tsshapeconstructor,name,parentName,txfm,isWorld));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbparentName = null;
if (parentName != null)
     sbparentName = new StringBuilder(parentName, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addNode(sbtsshapeconstructor, sbname, sbparentName, sbtxfm, isWorld)>=1;
}
/// <summary>
/// Add a new mesh primitive to the shape.
///    @param meshName full name (object name + detail size) of the new mesh. If 
///       no detail size is present at the end of the name, a value of 2 is used.br>
///       An underscore before the number at the end of the name will be interpreted as 
///       a negative sign. eg. \"MyMesh_4\" will be interpreted as \"MyMesh-4\".
///    @param type one of: \"box\", \"sphere\", \"capsule\"
///    @param params mesh primitive parameters:
///       ul>
///          li>for box: \"size_x size_y size_z\"/li>
///          li>for sphere: \"radius\"/li>
///          li>for capsule: \"height radius\"/li>
///       /ul>
///    /ul>
///    @param txfm local transform offset from the node for this mesh
///    @param nodeName name of the node to attach the new mesh to (will change the 
///    object's node if adding a new mesh to an existing object)
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addMesh( \"Box4\", \"box\", \"2 4 2\", \"0 2 0 0 0 1 0\", \"eye\" );
///    %this.addMesh( \"Sphere256\", \"sphere\", \"2\", \"0 0 0 0 0 1 0\", \"root\" );
///    %this.addMesh( \"MyCapsule-1\", \"capsule\", \"2 5\", \"0 0 2 0 0 1 0\", \"base01\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addPrimitive (string tsshapeconstructor, string meshName, string type, string paramsx, string txfm, string nodeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addPrimitive'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" ",tsshapeconstructor,meshName,type,paramsx,txfm,nodeName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbmeshName = null;
if (meshName != null)
     sbmeshName = new StringBuilder(meshName, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);
StringBuilder sbparamsx = null;
if (paramsx != null)
     sbparamsx = new StringBuilder(paramsx, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);
StringBuilder sbnodeName = null;
if (nodeName != null)
     sbnodeName = new StringBuilder(nodeName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addPrimitive(sbtsshapeconstructor, sbmeshName, sbtype, sbparamsx, sbtxfm, sbnodeName)>=1;
}
/// <summary>
/// Add a new sequence to the shape.
///    @param source the name of an existing sequence, or the name of a DTS or DAE 
///    shape or DSQ sequence file. When the shape file contains more than one 
///    sequence, the desired sequence can be specified by appending the name to the 
///    end of the shape file. eg. \"myShape.dts run\" would select the \"run\" 
///    sequence from the \"myShape.dts\" file.
///    @param name name of the new sequence
///    @param start (optional) first frame to copy. Defaults to 0, the first frame in the sequence.
///    @param end (optional) last frame to copy. Defaults to -1, the last frame in the sequence.
///    @param padRot (optional) copy root-pose rotation keys for non-animated nodes. This is useful if 
///    the source sequence data has a different root-pose to the target shape, such as if one character was 
///    in the T pose, and the other had arms at the side. Normally only nodes that are actually rotated by 
///    the source sequence have keyframes added, but setting this flag will also add keyframes for nodes 
///    that are not animated, but have a different root-pose rotation to the target shape root pose.
///    @param padTrans (optional) copy root-pose translation keys for non-animated nodes.  This is useful if 
///    the source sequence data has a different root-pose to the target shape, such as if one character was 
///    in the T pose, and the other had arms at the side. Normally only nodes that are actually moved by 
///    the source sequence have keyframes added, but setting this flag will also add keyframes for nodes 
///    that are not animated, but have a different root-pose position to the target shape root pose.
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addSequence( \"./testShape.dts ambient\", \"ambient\" );
///    %this.addSequence( \"./myPlayer.dae run\", \"run\" );
///    %this.addSequence( \"./player_look.dsq\", \"look\", 0, -1 );     // start to end
///    %this.addSequence( \"walk\", \"walk_shortA\", 0, 4 );            // start to frame 4
///    %this.addSequence( \"walk\", \"walk_shortB\", 4, -1 );           // frame 4 to end
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addSequence (string tsshapeconstructor, string source, string name, int start, int end, bool padRot, bool padTrans)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addSequence'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" ",tsshapeconstructor,source,name,start,end,padRot,padTrans));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbsource = null;
if (source != null)
     sbsource = new StringBuilder(source, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addSequence(sbtsshapeconstructor, sbsource, sbname, start, end, padRot, padTrans)>=1;
}
/// <summary>
/// Add a new trigger to the sequence.
///    @param name name of the sequence to modify
///    @param keyframe keyframe of the new trigger
///    @param state of the new trigger
///    @return true if successful, false otherwise
///    @tsexample
///    %this.addTrigger( \"walk\", 3, 1 );
///    %this.addTrigger( \"walk\", 5, -1 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_addTrigger (string tsshapeconstructor, string name, int keyframe, int state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_addTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsshapeconstructor,name,keyframe,state));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_addTrigger(sbtsshapeconstructor, sbname, keyframe, state)>=1;
}
/// <summary>
/// Dump the shape hierarchy to the console or to a file. Useful for reviewing 
///    the result of a series of construction commands.
///    @param filename Destination filename. If not specified, dump to console.
///    @tsexample
///    %this.dumpShape();               // dump to console
///    %this.dumpShape( \"./dump.txt\" ); // dump to file
///    @endtsexample )
/// 
/// </summary>

public void fnTSShapeConstructor_dumpShape (string tsshapeconstructor, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_dumpShape'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,filename));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_dumpShape(sbtsshapeconstructor, sbfilename);
}
/// <summary>
/// Get the bounding box for the shape.
///    @return Bounding box \"minX minY minZ maxX maxY maxZ\" )
/// 
/// </summary>

public string fnTSShapeConstructor_getBounds (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getBounds'" + string.Format("\"{0}\" ",tsshapeconstructor));
var returnbuff = new StringBuilder(1024);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getBounds(sbtsshapeconstructor, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the total number of detail levels in the shape.
///    @return the number of detail levels in the shape )
/// 
/// </summary>

public int fnTSShapeConstructor_getDetailLevelCount (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getDetailLevelCount'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getDetailLevelCount(sbtsshapeconstructor);
}
/// <summary>
/// Get the index of the detail level with a given size.
///    @param size size of the detail level to lookup
///    @return index of the detail level with the desired size, or -1 if no such 
///    detail exists
///    @tsexample
///    if ( %this.getDetailLevelSize( 32 ) == -1 )
///       echo( \"Error: This shape does not have a detail level at size 32\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getDetailLevelIndex (string tsshapeconstructor, int size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getDetailLevelIndex'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,size));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getDetailLevelIndex(sbtsshapeconstructor, size);
}
/// <summary>
/// Get the name of the indexed detail level.
///    @param index detail level index (valid range is 0 - getDetailLevelCount()-1)
///    @return the detail level name
///    @tsexample
///    // print the names of all detail levels in the shape
///    %count = %this.getDetailLevelCount();
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %i SPC %this.getDetailLevelName( %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getDetailLevelName (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getDetailLevelName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getDetailLevelName(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the size of the indexed detail level.
///    @param index detail level index (valid range is 0 - getDetailLevelCount()-1)
///    @return the detail level size
///    @tsexample
///    // print the sizes of all detail levels in the shape
///    %count = %this.getDetailLevelCount();
///    for ( %i = 0; %i  %count; %i++ )
///       echo( \"Detail\" @ %i @ \" has size \" @ %this.getDetailLevelSize( %i ) );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getDetailLevelSize (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getDetailLevelSize'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getDetailLevelSize(sbtsshapeconstructor, index);
}
/// <summary>
/// Get the index of the imposter (auto-billboard) detail level (if any).
///    @return imposter detail level index, or -1 if the shape does not use 
///    imposters. )
/// 
/// </summary>

public int fnTSShapeConstructor_getImposterDetailLevel (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getImposterDetailLevel'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getImposterDetailLevel(sbtsshapeconstructor);
}
/// <summary>
/// Get the settings used to generate imposters for the indexed detail level.
///    @param index index of the detail level to query (does not need to be an 
///    imposter detail level
///    @return string of the form: \"valid eqSteps pSteps dl dim poles angle\", where:
///    dl>
///       dt>valid/dt>dd>1 if this detail level generates imposters, 0 otherwise/dd>
///       dt>eqSteps/dt>dd>number of steps around the equator/dd>
///       dt>pSteps/dt>dd>number of steps between the poles/dd>
///       dt>dl/dt>dd>index of the detail level used to generate imposters/dd>
///       dt>dim/dt>dd>size (in pixels) of each imposter image/dd>
///       dt>poles/dt>dd>1 to include pole images, 0 otherwise/dd>
///       dt>angle/dt>dd>angle at which to display pole images/dd>
///    /dl>
///    @tsexample
///    // print the imposter detail level settings
///    %index = %this.getImposterDetailLevel();
///    if ( %index != -1 )
///       echo( \"Imposter settings: \" @ %this.getImposterSettings( %index ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getImposterSettings (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getImposterSettings'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getImposterSettings(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of meshes (detail levels) for the specified object.
///    @param name name of the object to query
///    @return the number of meshes for this object.
///    @tsexample
///    %count = %this.getMeshCount( \"SimpleShape\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getMeshCount (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getMeshCount'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getMeshCount(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the material attached to a mesh. Note that only the first 
///    material used by the mesh is returned.
///    @param name full name (object name + detail size) of the mesh to query
///    @return name of the material attached to the mesh (suitable for use with the Material mapTo field)
///    @tsexample
///    echo( \"Mesh material is \" @ %this.sgetMeshMaterial( \"SimpleShape128\" ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getMeshMaterial (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getMeshMaterial'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getMeshMaterial(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the indexed mesh (detail level) for the specified object.
///    @param name name of the object to query
///    @param index index of the mesh (valid range is 0 - getMeshCount()-1)
///    @return the mesh name.
///    @tsexample
///    // print the names of all meshes in the shape
///    %objCount = %this.getObjectCount();
///    for ( %i = 0; %i  %objCount; %i++ )
///    {
///       %objName = %this.getObjectName( %i );
///       %meshCount = %this.getMeshCount( %objName );
///       for ( %j = 0; %j  %meshCount; %j++ )
///          echo( %this.getMeshName( %objName, %j ) );
///    }
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getMeshName (string tsshapeconstructor, string name, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getMeshName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getMeshName(sbtsshapeconstructor, sbname, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the detail level size of the indexed mesh for the specified object.
///    @param name name of the object to query
///    @param index index of the mesh (valid range is 0 - getMeshCount()-1)
///    @return the mesh detail level size.
///    @tsexample
///    // print sizes for all detail levels of this object
///    %objName = \"trunk\";
///    %count = %this.getMeshCount( %objName );
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %this.getMeshSize( %objName, %i ) );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getMeshSize (string tsshapeconstructor, string name, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getMeshSize'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,index));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getMeshSize(sbtsshapeconstructor, sbname, index);
}
/// <summary>
/// Get the display type of the mesh.
///    @param name name of the mesh to query
///    @return the string returned is one of:
///    dl>dt>normal/dt>dd>a normal 3D mesh/dd>
///    dt>billboard/dt>dd>a mesh that always faces the camera/dd>
///    dt>billboardzaxis/dt>dd>a mesh that always faces the camera in the Z-axis/dd>/dl>
///    @tsexample
///    echo( \"Mesh type is \" @ %this.getMeshType( \"SimpleShape128\" ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getMeshType (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getMeshType'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getMeshType(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of children of this node.
///    @param name name of the node to query.
///    @return the number of child nodes.
///    @tsexample
///    %count = %this.getNodeChildCount( \"Bip01 Pelvis\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getNodeChildCount (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeChildCount'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeChildCount(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the indexed child node.
///    @param name name of the parent node to query.
///    @param index index of the child node (valid range is 0 - getNodeChildName()-1).
///    @return the name of the indexed child node.
///    @tsexample
///    function dumpNode( %shape, %name, %indent )
///    {
///       echo( %indent @ %name );
///       %count = %shape.getNodeChildCount( %name );
///       for ( %i = 0; %i  %count; %i++ )
///          dumpNode( %shape, %shape.getNodeChildName( %name, %i ), %indent @ \"   \" );
///    }
///    function dumpShape( %shape )
///    {
///       // recursively dump node hierarchy
///       %count = %shape.getNodeCount();
///       for ( %i = 0; %i  %count; %i++ )
///       {
///          // dump top level nodes
///          %name = %shape.getNodeName( %i );
///          if ( %shape.getNodeParentName( %name ) $=  )
///             dumpNode( %shape, %name, \"\" );
///       }
///    }
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getNodeChildName (string tsshapeconstructor, string name, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeChildName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeChildName(sbtsshapeconstructor, sbname, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the total number of nodes in the shape.
///    @return the number of nodes in the shape.
///    @tsexample
///    %count = %this.getNodeCount();
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getNodeCount (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeCount'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeCount(sbtsshapeconstructor);
}
/// <summary>
/// Get the index of the node.
///    @param name name of the node to lookup.
///    @return the index of the named node, or -1 if no such node exists.
///    @tsexample
///    // get the index of Bip01 Pelvis node in the shape
///    %index = %this.getNodeIndex( \"Bip01 Pelvis\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getNodeIndex (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeIndex'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeIndex(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the indexed node.
///    @param index index of the node to lookup (valid range is 0 - getNodeCount()-1).
///    @return the name of the indexed node, or \"\" if no such node exists.
///    @tsexample
///    // print the names of all the nodes in the shape
///    %count = %this.getNodeCount();
///    for (%i = 0; %i  %count; %i++)
///       echo(%i SPC %this.getNodeName(%i));
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getNodeName (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeName(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of geometry objects attached to this node.
///    @param name name of the node to query.
///    @return the number of attached objects.
///    @tsexample
///    %count = %this.getNodeObjectCount( \"Bip01 Head\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getNodeObjectCount (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeObjectCount'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeObjectCount(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the indexed object.
///    @param name name of the node to query.
///    @param index index of the object (valid range is 0 - getNodeObjectCount()-1).
///    @return the name of the indexed object.
///    @tsexample
///    // print the names of all objects attached to the node
///    %count = %this.getNodeObjectCount( \"Bip01 Head\" );
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %this.getNodeObjectName( \"Bip01 Head\", %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getNodeObjectName (string tsshapeconstructor, string name, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeObjectName'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeObjectName(sbtsshapeconstructor, sbname, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the node's parent. If the node has no parent (ie. it is at 
///    the root level), return an empty string.
///    @param name name of the node to query.
///    @return the name of the node's parent, or \"\" if the node is at the root level
///    @tsexample
///    echo( \"Bip01 Pelvis parent = \" @ %this.getNodeParentName( \"Bip01 Pelvis \") );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getNodeParentName (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeParentName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeParentName(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the base (ie. not animated) transform of a node.
///    @param name name of the node to query.
///    @param isWorld true to get the global transform, false (or omitted) to get 
///    the local-to-parent transform.
///    @return the node transform in the form \"pos.x pos.y pos.z rot.x rot.y rot.z rot.angle\".
///    @tsexample
///    %ret = %this.getNodeTransform( \"mount0\" );
///    %this.setNodeTransform( \"mount4\", %ret );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getNodeTransform (string tsshapeconstructor, string name, bool isWorld)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getNodeTransform'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,isWorld));
var returnbuff = new StringBuilder(1024);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getNodeTransform(sbtsshapeconstructor, sbname, isWorld, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the total number of objects in the shape.
///    @return the number of objects in the shape.
///    @tsexample
///    %count = %this.getObjectCount();
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getObjectCount (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getObjectCount'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getObjectCount(sbtsshapeconstructor);
}
/// <summary>
/// Get the index of the first object with the given name.
///    @param name name of the object to get.
///    @return the index of the named object.
///    @tsexample
///    %index = %this.getObjectIndex( \"Head\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getObjectIndex (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getObjectIndex'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getObjectIndex(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the indexed object.
///    @param index index of the object to get (valid range is 0 - getObjectCount()-1).
///    @return the name of the indexed object.
///    @tsexample
///    // print the names of all objects in the shape
///    %count = %this.getObjectCount();
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %i SPC %this.getObjectName( %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getObjectName (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getObjectName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getObjectName(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the name of the node this object is attached to.
///    @param name name of the object to get.
///    @return the name of the attached node, or an empty string if this 
///    object is not attached to a node (usually the case for skinned meshes).
///    @tsexample
///    echo( \"Hand is attached to \" @ %this.getObjectNode( \"Hand\" ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getObjectNode (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getObjectNode'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getObjectNode(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get information about blended sequences.
///    @param name name of the sequence to query
///    @return TAB delimited string of the form: \"isBlend blendSeq blendFrame\", where:
///    dl>
///    dt>blend_flag/dt>dd>a boolean flag indicating whether this sequence is a blend/dd>
///    dt>blend_seq_name/dt>dd>the name of the sequence that contains the reference 
///    frame (empty for blend sequences embedded in DTS files)/dd>
///    dt>blend_seq_frame/dt>dd>the blend reference frame (empty for blend sequences 
///    embedded in DTS files)/dd>
///    /dl>
///    @note Note that only sequences set to be blends using the setSequenceBlend 
///    command will contain the blendSeq and blendFrame information.
///    @tsexample
///    %blendData = %this.getSequenceBlend( \"look\" );
///    if ( getField( %blendData, 0 ) )
///       echo( \"look is a blend, reference: \" @ getField( %blendData, 1 ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getSequenceBlend (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceBlend'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceBlend(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the total number of sequences in the shape.
///    @return the number of sequences in the shape )
/// 
/// </summary>

public int fnTSShapeConstructor_getSequenceCount (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceCount'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceCount(sbtsshapeconstructor);
}
/// <summary>
/// Check if this sequence is cyclic (looping).
///    @param name name of the sequence to query
///    @return true if this sequence is cyclic, false if not
///    @tsexample
///    if ( !%this.getSequenceCyclic( \"ambient\" ) )
///       error( \"ambient sequence is not cyclic!\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_getSequenceCyclic (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceCyclic'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceCyclic(sbtsshapeconstructor, sbname)>=1;
}
/// <summary>
/// Get the number of keyframes in the sequence.
///    @param name name of the sequence to query
///    @return number of keyframes in the sequence
///    @tsexample
///    echo( \"Run has \" @ %this.getSequenceFrameCount( \"run\" ) @ \" keyframes\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getSequenceFrameCount (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceFrameCount'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceFrameCount(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the ground speed of the sequence.
///    @note Note that only the first 2 ground frames of the sequence are 
///    examined; the speed is assumed to be constant throughout the sequence.
///    @param name name of the sequence to query
///    @return string of the form: \"trans.x trans.y trans.z rot.x rot.y rot.z\"
///    @tsexample
///    %speed = VectorLen( getWords( %this.getSequenceGroundSpeed( \"run\" ), 0, 2 ) );
///       echo( \"Run moves at \" @ %speed @ \" units per frame\" );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getSequenceGroundSpeed (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceGroundSpeed'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceGroundSpeed(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Find the index of the sequence with the given name.
///    @param name name of the sequence to lookup
///    @return index of the sequence with matching name, or -1 if not found
///    @tsexample
///    // Check if a given sequence exists in the shape
///    if ( %this.getSequenceIndex( \"walk\" ) == -1 )
///       echo( \"Could not find 'walk' sequence\" );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getSequenceIndex (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceIndex'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceIndex(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get the name of the indexed sequence.
///    @param index index of the sequence to query (valid range is 0 - getSequenceCount()-1)
///    @return the name of the sequence
///    @tsexample
///    // print the name of all sequences in the shape
///    %count = %this.getSequenceCount();
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %i SPC %this.getSequenceName( %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getSequenceName (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceName(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the priority setting of the sequence.
///    @param name name of the sequence to query
///    @return priority value of the sequence )
/// 
/// </summary>

public float fnTSShapeConstructor_getSequencePriority (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequencePriority'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getSequencePriority(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Get information about where the sequence data came from.
///    For example, whether it was loaded from an external DSQ file.
///    @param name name of the sequence to query
///    @return TAB delimited string of the form: \"from reserved start end total\", where:
///    dl>
///       dt>from/dt>dd>the source of the animation data, such as the path to 
///       a DSQ file, or the name of an existing sequence in the shape. This field 
///       will be empty for sequences already embedded in the DTS or DAE file./dd>
///       dt>reserved/dt>dd>reserved value/dd>
///       dt>start/dt>dd>the first frame in the source sequence used to create this sequence/dd>
///       dt>end/dt>dd>the last frame in the source sequence used to create this sequence/dd>
///       dt>total/dt>dd>the total number of frames in the source sequence/dd>
///    /dl>
///    @tsexample
///    // print the source for the walk animation
///    echo( \"walk source:\" SPC getField( %this.getSequenceSource( \"walk\" ), 0 ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getSequenceSource (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getSequenceSource'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getSequenceSource(sbtsshapeconstructor, sbname, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of materials in the shape.
///    @return the number of materials in the shape.
///    @tsexample
///    %count = %this.getTargetCount();
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_getTargetCount (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getTargetCount'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getTargetCount(sbtsshapeconstructor);
}
/// <summary>
/// Get the name of the indexed shape material.
///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
///    @return the name of the indexed material.
///    @tsexample
///    %count = %this.getTargetCount();
///    for ( %i = 0; %i  %count; %i++ )
///       echo( \"Target \" @ %i @ \": \" @ %this.getTargetName( %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getTargetName (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getTargetName'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getTargetName(sbtsshapeconstructor, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get information about the indexed trigger
///    @param name name of the sequence to query
///    @param index index of the trigger (valid range is 0 - getTriggerCount()-1)
///    @return string of the form \"frame state\"
///    @tsexample
///    // print all triggers in the sequence
///    %count = %this.getTriggerCount( \"back\" );
///    for ( %i = 0; %i  %count; %i++ )
///       echo( %i SPC %this.getTrigger( \"back\", %i ) );
///    @endtsexample )
/// 
/// </summary>

public string fnTSShapeConstructor_getTrigger (string tsshapeconstructor, string name, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_getTrigger(sbtsshapeconstructor, sbname, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of triggers in the specified sequence.
///    @param name name of the sequence to query
///    @return number of triggers in the sequence )
/// 
/// </summary>

public int fnTSShapeConstructor_getTriggerCount (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_getTriggerCount'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_getTriggerCount(sbtsshapeconstructor, sbname);
}
/// <summary>
/// Notify game objects that this shape file has changed, allowing them to update 
///    internal data if needed. )
/// 
/// </summary>

public void fnTSShapeConstructor_notifyShapeChanged (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_notifyShapeChanged'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_notifyShapeChanged(sbtsshapeconstructor);
}
/// <summary>
/// Remove the detail level (including all meshes in the detail level)
///    @param size size of the detail level to remove
///    @return true if successful, false otherwise
///    @tsexample
///    %this.removeDetailLevel( 2 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeDetailLevel (string tsshapeconstructor, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeDetailLevel'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,index));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeDetailLevel(sbtsshapeconstructor, index)>=1;
}
/// <summary>
/// () Remove the imposter detail level (if any) from the shape.
///    @return true if successful, false otherwise )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeImposter (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeImposter'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeImposter(sbtsshapeconstructor)>=1;
}
/// <summary>
/// Remove a mesh from the shape.
///    If all geometry is removed from an object, the object is also removed.
///    @param name full name (object name + detail size) of the mesh to remove
///    @return true if successful, false otherwise
///    @tsexample
///    %this.removeMesh( \"SimpleShape128\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeMesh (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeMesh'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeMesh(sbtsshapeconstructor, sbname)>=1;
}
/// <summary>
/// Remove a node from the shape.
///    The named node is removed from the shape, including from any sequences that 
///    use the node. Child nodes and objects attached to the node are re-assigned 
///    to the node's parent.
///    @param name name of the node to remove.
///    @return true if successful, false otherwise.
///    @tsexample
///    %this.removeNode( \"Nose\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeNode (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeNode'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeNode(sbtsshapeconstructor, sbname)>=1;
}
/// <summary>
/// Remove an object (including all meshes for that object) from the shape.
///    @param name name of the object to remove.
///    @return true if successful, false otherwise.
///    @tsexample
///    // clear all objects in the shape
///    %count = %this.getObjectCount();
///    for ( %i = %count-1; %i >= 0; %i-- )
///       %this.removeObject( %this.getObjectName(%i) );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeObject (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeObject'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeObject(sbtsshapeconstructor, sbname)>=1;
}
/// <summary>
/// Remove the sequence from the shape.
///    @param name name of the sequence to remove
///    @return true if successful, false otherwise )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeSequence (string tsshapeconstructor, string name)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeSequence'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,name));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeSequence(sbtsshapeconstructor, sbname)>=1;
}
/// <summary>
/// Remove a trigger from the sequence.
///    @param name name of the sequence to modify
///    @param keyframe keyframe of the trigger to remove
///    @param state of the trigger to remove
///    @return true if successful, false otherwise
///    @tsexample
///    %this.removeTrigger( \"walk\", 3, 1 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_removeTrigger (string tsshapeconstructor, string name, int keyframe, int state)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_removeTrigger'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsshapeconstructor,name,keyframe,state));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_removeTrigger(sbtsshapeconstructor, sbname, keyframe, state)>=1;
}
/// <summary>
/// Rename a detail level.
///    @note Note that detail level names must be unique, so this command will 
///    fail if there is already a detail level with the desired name
///    @param oldName current name of the detail level
///    @param newName new name of the detail level
///    @return true if successful, false otherwise
///    @tsexample
///    %this.renameDetailLevel( \"detail-1\", \"collision-1\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_renameDetailLevel (string tsshapeconstructor, string oldName, string newName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_renameDetailLevel'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,oldName,newName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sboldName = null;
if (oldName != null)
     sboldName = new StringBuilder(oldName, 1024);
StringBuilder sbnewName = null;
if (newName != null)
     sbnewName = new StringBuilder(newName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_renameDetailLevel(sbtsshapeconstructor, sboldName, sbnewName)>=1;
}
/// <summary>
/// Rename a node.
///    @note Note that node names must be unique, so this command will fail if 
///    there is already a node with the desired name
///    @param oldName current name of the node
///    @param newName new name of the node
///    @return true if successful, false otherwise
///    @tsexample
///    %this.renameNode( \"Bip01 L Hand\", \"mount5\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_renameNode (string tsshapeconstructor, string oldName, string newName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_renameNode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,oldName,newName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sboldName = null;
if (oldName != null)
     sboldName = new StringBuilder(oldName, 1024);
StringBuilder sbnewName = null;
if (newName != null)
     sbnewName = new StringBuilder(newName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_renameNode(sbtsshapeconstructor, sboldName, sbnewName)>=1;
}
/// <summary>
/// Rename an object.
///    @note Note that object names must be unique, so this command will fail if 
///    there is already an object with the desired name
///    @param oldName current name of the object
///    @param newName new name of the object
///    @return true if successful, false otherwise
///    @tsexample
///    %this.renameObject( \"MyBox\", \"Box\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_renameObject (string tsshapeconstructor, string oldName, string newName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_renameObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,oldName,newName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sboldName = null;
if (oldName != null)
     sboldName = new StringBuilder(oldName, 1024);
StringBuilder sbnewName = null;
if (newName != null)
     sbnewName = new StringBuilder(newName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_renameObject(sbtsshapeconstructor, sboldName, sbnewName)>=1;
}
/// <summary>
/// Rename a sequence.
///    @note Note that sequence names must be unique, so this command will fail 
///    if there is already a sequence with the desired name
///    @param oldName current name of the sequence
///    @param newName new name of the sequence
///    @return true if successful, false otherwise
///    @tsexample
///    %this.renameSequence( \"walking\", \"walk\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_renameSequence (string tsshapeconstructor, string oldName, string newName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_renameSequence'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,oldName,newName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sboldName = null;
if (oldName != null)
     sboldName = new StringBuilder(oldName, 1024);
StringBuilder sbnewName = null;
if (newName != null)
     sbnewName = new StringBuilder(newName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_renameSequence(sbtsshapeconstructor, sboldName, sbnewName)>=1;
}
/// <summary>
/// Save the shape (with all current changes) to a new DTS file.
///    @param filename Destination filename.
///    @tsexample
///    %this.saveShape( \"./myShape.dts\" );
///    @endtsexample )
/// 
/// </summary>

public void fnTSShapeConstructor_saveShape (string tsshapeconstructor, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_saveShape'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,filename));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_saveShape(sbtsshapeconstructor, sbfilename);
}
/// <summary>
/// Set the shape bounds to the given bounding box.
///    @param Bounding box \"minX minY minZ maxX maxY maxZ\"
///    @return true if successful, false otherwise )
/// 
/// </summary>

public bool fnTSShapeConstructor_setBounds (string tsshapeconstructor, string bbox)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setBounds'" + string.Format("\"{0}\" \"{1}\" ",tsshapeconstructor,bbox));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbbbox = null;
if (bbox != null)
     sbbbox = new StringBuilder(bbox, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setBounds(sbtsshapeconstructor, sbbbox)>=1;
}
/// <summary>
/// Change the size of a detail level.
///    @note Note that detail levels are always sorted in decreasing size order, 
///    so this command may cause detail level indices to change.
///    @param index index of the detail level to modify
///    @param newSize new size for the detail level
///    @return new index for this detail level
///    @tsexample
///    %this.setDetailLevelSize( 2, 256 );
///    @endtsexample )
/// 
/// </summary>

public int fnTSShapeConstructor_setDetailLevelSize (string tsshapeconstructor, int index, int newSize)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setDetailLevelSize'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,index,newSize));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setDetailLevelSize(sbtsshapeconstructor, index, newSize);
}
/// <summary>
/// Set the name of the material attached to the mesh.
///    @param meshName full name (object name + detail size) of the mesh to modify
///    @param matName name of the material to attach. This could be the base name of 
///    the diffuse texture (eg. \"test_mat\" for \"test_mat.jpg\"), or the name of a 
///    Material object already defined in script.
///    @return true if successful, false otherwise
///    @tsexample
///    // set the mesh material
///    %this.setMeshMaterial( \"SimpleShape128\", \"test_mat\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setMeshMaterial (string tsshapeconstructor, string meshName, string matName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setMeshMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,meshName,matName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbmeshName = null;
if (meshName != null)
     sbmeshName = new StringBuilder(meshName, 1024);
StringBuilder sbmatName = null;
if (matName != null)
     sbmatName = new StringBuilder(matName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setMeshMaterial(sbtsshapeconstructor, sbmeshName, sbmatName)>=1;
}
/// <summary>
/// Change the detail level size of the named mesh.
///    @param name full name (object name + current size ) of the mesh to modify
///    @param size new detail level size
///    @return true if successful, false otherwise.
///    @tsexample
///    %this.setMeshSize( \"SimpleShape128\", 64 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setMeshSize (string tsshapeconstructor, string name, int size)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setMeshSize'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,size));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setMeshSize(sbtsshapeconstructor, sbname, size)>=1;
}
/// <summary>
/// Set the display type for the mesh.
///    @param name full name (object name + detail size) of the mesh to modify
///    @param type the new type for the mesh: \"normal\", \"billboard\" or \"billboardzaxis\"
///    @return true if successful, false otherwise
///    @tsexample
///    // set the mesh to be a billboard
///    %this.setMeshType( \"SimpleShape64\", \"billboard\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setMeshType (string tsshapeconstructor, string name, string type)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setMeshType'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,type));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbtype = null;
if (type != null)
     sbtype = new StringBuilder(type, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setMeshType(sbtsshapeconstructor, sbname, sbtype)>=1;
}
/// <summary>
/// Set the parent of a node.
///   @param name name of the node to modify
///   @param parentName name of the parent node to set (use \"\" to move the node to the root level)
///   @return true if successful, false if failed
///   @tsexample
///   %this.setNodeParent( \"Bip01 Pelvis\", \"start01\" );
///   @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setNodeParent (string tsshapeconstructor, string name, string parentName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setNodeParent'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,parentName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbparentName = null;
if (parentName != null)
     sbparentName = new StringBuilder(parentName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setNodeParent(sbtsshapeconstructor, sbname, sbparentName)>=1;
}
/// <summary>
/// Set the base transform of a node. That is, the transform of the node when 
///    in the root (not-animated) pose.
///    @param name name of the node to modify
///    @param txfm transform string of the form: \"pos.x pos.y pos.z rot.x rot.y rot.z rot.angle\"
///    @param isworld (optional) flag to set the local-to-parent or the global 
///    transform. If false, or not specified, the position and orientation are 
///    treated as relative to the node's parent.
///    @return true if successful, false otherwise
///    @tsexample
///    %this.setNodeTransform( \"mount0\", \"0 0 1 0 0 1 0\" );
///    %this.setNodeTransform( \"mount0\", \"0 0 0 0 0 1 1.57\" );
///    %this.setNodeTransform( \"mount0\", \"1 0 0 0 0 1 0\", true );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setNodeTransform (string tsshapeconstructor, string name, string txfm, bool isWorld)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setNodeTransform'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsshapeconstructor,name,txfm,isWorld));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbtxfm = null;
if (txfm != null)
     sbtxfm = new StringBuilder(txfm, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setNodeTransform(sbtsshapeconstructor, sbname, sbtxfm, isWorld)>=1;
}
/// <summary>
/// Set the node an object is attached to.
///    When the shape is rendered, the object geometry is rendered at the node's 
///    current transform.
///    @param objName name of the object to modify
///    @param nodeName name of the node to attach the object to
///    @return true if successful, false otherwise
///    @tsexample
///    %this.setObjectNode( \"Hand\", \"Bip01 LeftHand\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setObjectNode (string tsshapeconstructor, string objName, string nodeName)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setObjectNode'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,objName,nodeName));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbobjName = null;
if (objName != null)
     sbobjName = new StringBuilder(objName, 1024);
StringBuilder sbnodeName = null;
if (nodeName != null)
     sbnodeName = new StringBuilder(nodeName, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setObjectNode(sbtsshapeconstructor, sbobjName, sbnodeName)>=1;
}
/// <summary>
/// Mark a sequence as a blend or non-blend.
///    A blend sequence is one that will be added on top of any other playing 
///    sequences. This is done by storing the animated node transforms relative 
///    to a reference frame, rather than as absolute transforms.
///    @param name name of the sequence to modify
///    @param blend true to make the sequence a blend, false for a non-blend
///    @param blendSeq the name of the sequence that contains the blend reference frame
///    @param blendFrame the reference frame in the blendSeq sequence
///    @return true if successful, false otherwise
///    @tsexample
///    %this.setSequenceBlend( \"look\", true, \"root\", 0 );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setSequenceBlend (string tsshapeconstructor, string name, bool blend, string blendSeq, int blendFrame)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setSequenceBlend'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" ",tsshapeconstructor,name,blend,blendSeq,blendFrame));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbblendSeq = null;
if (blendSeq != null)
     sbblendSeq = new StringBuilder(blendSeq, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setSequenceBlend(sbtsshapeconstructor, sbname, blend, sbblendSeq, blendFrame)>=1;
}
/// <summary>
/// Mark a sequence as cyclic or non-cyclic.
///    @param name name of the sequence to modify
///    @param cyclic true to make the sequence cyclic, false for non-cyclic
///    @return true if successful, false otherwise
///    @tsexample
///    %this.setSequenceCyclic( \"ambient\", true );
///    %this.setSequenceCyclic( \"shoot\", false );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setSequenceCyclic (string tsshapeconstructor, string name, bool cyclic)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setSequenceCyclic'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,cyclic));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setSequenceCyclic(sbtsshapeconstructor, sbname, cyclic)>=1;
}
/// <summary>
/// Set the translation and rotation ground speed of the sequence.
///    The ground speed of the sequence is set by generating ground transform 
///    keyframes. The ground translational and rotational speed is assumed to 
///    be constant for the duration of the sequence. Existing ground frames for 
///    the sequence (if any) will be replaced.
///    @param name name of the sequence to modify
///    @param transSpeed translational speed (trans.x trans.y trans.z) in 
///    Torque units per frame
///    @param rotSpeed (optional) rotational speed (rot.x rot.y rot.z) in 
///    radians per frame. Default is \"0 0 0\"
///    @return true if successful, false otherwise
///    @tsexample
///    %this.setSequenceGroundSpeed( \"run\", \"5 0 0\" );
///    %this.setSequenceGroundSpeed( \"spin\", \"0 0 0\", \"4 0 0\" );
///    @endtsexample )
/// 
/// </summary>

public bool fnTSShapeConstructor_setSequenceGroundSpeed (string tsshapeconstructor, string name, string transSpeed, string rotSpeed)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setSequenceGroundSpeed'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsshapeconstructor,name,transSpeed,rotSpeed));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);
StringBuilder sbtransSpeed = null;
if (transSpeed != null)
     sbtransSpeed = new StringBuilder(transSpeed, 1024);
StringBuilder sbrotSpeed = null;
if (rotSpeed != null)
     sbrotSpeed = new StringBuilder(rotSpeed, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setSequenceGroundSpeed(sbtsshapeconstructor, sbname, sbtransSpeed, sbrotSpeed)>=1;
}
/// <summary>
/// Set the sequence priority.
///    @param name name of the sequence to modify
///    @param priority new priority value
///    @return true if successful, false otherwise )
/// 
/// </summary>

public bool fnTSShapeConstructor_setSequencePriority (string tsshapeconstructor, string name, float priority)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_setSequencePriority'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",tsshapeconstructor,name,priority));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);
StringBuilder sbname = null;
if (name != null)
     sbname = new StringBuilder(name, 1024);

return  SafeNativeMethods.mwle_fnTSShapeConstructor_setSequencePriority(sbtsshapeconstructor, sbname, priority)>=1;
}
/// <summary>
/// Write the current change set to a TSShapeConstructor script file. The 
///    name of the script file is the same as the model, but with .cs extension. 
///    eg. myShape.cs for myShape.dts or myShape.dae. )
/// 
/// </summary>

public void fnTSShapeConstructor_writeChangeSet (string tsshapeconstructor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSShapeConstructor_writeChangeSet'" + string.Format("\"{0}\" ",tsshapeconstructor));
StringBuilder sbtsshapeconstructor = null;
if (tsshapeconstructor != null)
     sbtsshapeconstructor = new StringBuilder(tsshapeconstructor, 1024);

SafeNativeMethods.mwle_fnTSShapeConstructor_writeChangeSet(sbtsshapeconstructor);
}
/// <summary>
/// ,NULL,NULL),
///    @brief Change one of the materials on the shape.
/// 
///    This method changes materials per mapTo with others. The material that 
///    is being replaced is mapped to unmapped_mat as a part of this transition.
/// 
///    @note Warning, right now this only sort of works. It doesn't do a live 
///    update like it should.
/// 
///    @param mapTo the name of the material target to remap (from getTargetName)
///    @param oldMat the old Material that was mapped 
///    @param newMat the new Material to map
/// 
///    @tsexample
///       // remap the first material in the shape
///       %mapTo = %obj.getTargetName( 0 );
///       %obj.changeMaterial( %mapTo, 0, MyMaterial );
///    @endtsexample )
/// 
/// </summary>

public void fnTSStatic_changeMaterial (string tsstatic, string mapTo, string oldMat, string newMat)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSStatic_changeMaterial'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",tsstatic,mapTo,oldMat,newMat));
StringBuilder sbtsstatic = null;
if (tsstatic != null)
     sbtsstatic = new StringBuilder(tsstatic, 1024);
StringBuilder sbmapTo = null;
if (mapTo != null)
     sbmapTo = new StringBuilder(mapTo, 1024);
StringBuilder sboldMat = null;
if (oldMat != null)
     sboldMat = new StringBuilder(oldMat, 1024);
StringBuilder sbnewMat = null;
if (newMat != null)
     sbnewMat = new StringBuilder(newMat, 1024);

SafeNativeMethods.mwle_fnTSStatic_changeMaterial(sbtsstatic, sbmapTo, sboldMat, sbnewMat);
}
/// <summary>
/// @brief Get the model filename used by this shape.
/// 
///    @return the shape filename
///    @tsexample
/// 		// Acquire the model filename used on this shape.
/// 		%modelFilename = %obj.getModelFile();
///    @endtsexample
///    )
/// 
/// </summary>

public string fnTSStatic_getModelFile (string tsstatic)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSStatic_getModelFile'" + string.Format("\"{0}\" ",tsstatic));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsstatic = null;
if (tsstatic != null)
     sbtsstatic = new StringBuilder(tsstatic, 1024);

SafeNativeMethods.mwle_fnTSStatic_getModelFile(sbtsstatic, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the number of materials in the shape.
///    @return the number of materials in the shape.
///    @see getTargetName())
/// 
/// </summary>

public int fnTSStatic_getTargetCount (string tsstatic)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSStatic_getTargetCount'" + string.Format("\"{0}\" ",tsstatic));
StringBuilder sbtsstatic = null;
if (tsstatic != null)
     sbtsstatic = new StringBuilder(tsstatic, 1024);

return  SafeNativeMethods.mwle_fnTSStatic_getTargetCount(sbtsstatic);
}
/// <summary>
/// Get the name of the indexed shape material.
///    @param index index of the material to get (valid range is 0 - getTargetCount()-1).
///    @return the name of the indexed material.
///    @see getTargetCount())
/// 
/// </summary>

public string fnTSStatic_getTargetName (string tsstatic, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTSStatic_getTargetName'" + string.Format("\"{0}\" \"{1}\" ",tsstatic,index));
var returnbuff = new StringBuilder(16384);
StringBuilder sbtsstatic = null;
if (tsstatic != null)
     sbtsstatic = new StringBuilder(tsstatic, 1024);

SafeNativeMethods.mwle_fnTSStatic_getTargetName(sbtsstatic, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Does the turret respawn after it has been destroyed.
///    @returns True if the turret respawns.)
/// 
/// </summary>

public bool fnTurretShape_doRespawn (string turretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_doRespawn'" + string.Format("\"{0}\" ",turretshape));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

return  SafeNativeMethods.mwle_fnTurretShape_doRespawn(sbturretshape)>=1;
}
/// <summary>
/// @brief Get if the turret is allowed to fire through moves.
///    @return True if the turret is allowed to fire through moves. )
/// 
/// </summary>

public bool fnTurretShape_getAllowManualFire (string turretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_getAllowManualFire'" + string.Format("\"{0}\" ",turretshape));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

return  SafeNativeMethods.mwle_fnTurretShape_getAllowManualFire(sbturretshape)>=1;
}
/// <summary>
/// @brief Get if the turret is allowed to rotate through moves.
///    @return True if the turret is allowed to rotate through moves. )
/// 
/// </summary>

public bool fnTurretShape_getAllowManualRotation (string turretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_getAllowManualRotation'" + string.Format("\"{0}\" ",turretshape));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

return  SafeNativeMethods.mwle_fnTurretShape_getAllowManualRotation(sbturretshape)>=1;
}
/// <summary>
/// @brief Get the name of the turret's current state.
/// 
///    The state is one of the following:ul>
///    li>Dead - The TurretShape is destroyed./li>
///    li>Mounted - The TurretShape is mounted to an object such as a vehicle./li>
///    li>Ready - The TurretShape is free to move.  The usual state./li>/ul>
/// 
///    @return The current state; one of: \"Dead\", \"Mounted\", \"Ready\" )
/// 
/// </summary>

public string fnTurretShape_getState (string turretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_getState'" + string.Format("\"{0}\" ",turretshape));
var returnbuff = new StringBuilder(16384);
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

SafeNativeMethods.mwle_fnTurretShape_getState(sbturretshape, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get Euler rotation of this turret's heading and pitch nodes.
///    @return the orientation of the turret's heading and pitch nodes in the 
///    form of rotations around the X, Y and Z axes in degrees. )
/// 
/// </summary>

public string fnTurretShape_getTurretEulerRotation (string turretshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_getTurretEulerRotation'" + string.Format("\"{0}\" ",turretshape));
var returnbuff = new StringBuilder(1024);
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

SafeNativeMethods.mwle_fnTurretShape_getTurretEulerRotation(sbturretshape, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Set if the turret is allowed to fire through moves.
///    @param allow If true then the turret may be fired through moves.)
/// 
/// </summary>

public void fnTurretShape_setAllowManualFire (string turretshape, bool allow)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_setAllowManualFire'" + string.Format("\"{0}\" \"{1}\" ",turretshape,allow));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

SafeNativeMethods.mwle_fnTurretShape_setAllowManualFire(sbturretshape, allow);
}
/// <summary>
/// @brief Set if the turret is allowed to rotate through moves.
///    @param allow If true then the turret may be rotated through moves.)
/// 
/// </summary>

public void fnTurretShape_setAllowManualRotation (string turretshape, bool allow)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_setAllowManualRotation'" + string.Format("\"{0}\" \"{1}\" ",turretshape,allow));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);

SafeNativeMethods.mwle_fnTurretShape_setAllowManualRotation(sbturretshape, allow);
}
/// <summary>
/// @brief Set Euler rotation of this turret's heading and pitch nodes in degrees.
///    @param rot The rotation in degrees.  The pitch is the X component and the 
///    heading is the Z component.  The Y component is ignored.)
/// 
/// </summary>

public void fnTurretShape_setTurretEulerRotation (string turretshape, string rot)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnTurretShape_setTurretEulerRotation'" + string.Format("\"{0}\" \"{1}\" ",turretshape,rot));
StringBuilder sbturretshape = null;
if (turretshape != null)
     sbturretshape = new StringBuilder(turretshape, 1024);
StringBuilder sbrot = null;
if (rot != null)
     sbrot = new StringBuilder(rot, 1024);

SafeNativeMethods.mwle_fnTurretShape_setTurretEulerRotation(sbturretshape, sbrot);
}
/// <summary>
/// @brief Changes the color of the fog.
/// 	@params new_color the new fog color (rgb 0-255, a is ignored.)
/// 
/// </summary>

public void fnVolumetricFog_SetFogColor (string volumetricfog, string new_color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnVolumetricFog_SetFogColor'" + string.Format("\"{0}\" \"{1}\" ",volumetricfog,new_color));
StringBuilder sbvolumetricfog = null;
if (volumetricfog != null)
     sbvolumetricfog = new StringBuilder(volumetricfog, 1024);
StringBuilder sbnew_color = null;
if (new_color != null)
     sbnew_color = new StringBuilder(new_color, 1024);

SafeNativeMethods.mwle_fnVolumetricFog_SetFogColor(sbvolumetricfog, sbnew_color);
}
/// <summary>
/// @brief Changes the color of the fog.
/// 	@params new_color the new fog color (rgb 0.0 - 1.0, a is ignored.)
/// 
/// </summary>

public void fnVolumetricFog_SetFogColorF (string volumetricfog, string new_color)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnVolumetricFog_SetFogColorF'" + string.Format("\"{0}\" \"{1}\" ",volumetricfog,new_color));
StringBuilder sbvolumetricfog = null;
if (volumetricfog != null)
     sbvolumetricfog = new StringBuilder(volumetricfog, 1024);
StringBuilder sbnew_color = null;
if (new_color != null)
     sbnew_color = new StringBuilder(new_color, 1024);

SafeNativeMethods.mwle_fnVolumetricFog_SetFogColorF(sbvolumetricfog, sbnew_color);
}
/// <summary>
/// @brief Changes the density of the fog.
/// 	@params new_density the new fog density.)
/// 
/// </summary>

public void fnVolumetricFog_SetFogDensity (string volumetricfog, float new_density)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnVolumetricFog_SetFogDensity'" + string.Format("\"{0}\" \"{1}\" ",volumetricfog,new_density));
StringBuilder sbvolumetricfog = null;
if (volumetricfog != null)
     sbvolumetricfog = new StringBuilder(volumetricfog, 1024);

SafeNativeMethods.mwle_fnVolumetricFog_SetFogDensity(sbvolumetricfog, new_density);
}
/// <summary>
/// @brief Changes the modulation of the fog.
/// 	@params new_strenght the new strength of the modulation.
/// 	@params new_speed1 the new speed (x y) of the modulation layer 1.
/// 	@params new_speed2 the new speed (x y) of the modulation layer 2.)
/// 
/// </summary>

public void fnVolumetricFog_SetFogModulation (string volumetricfog, float new_strenght, string new_speed1, string new_speed2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnVolumetricFog_SetFogModulation'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",volumetricfog,new_strenght,new_speed1,new_speed2));
StringBuilder sbvolumetricfog = null;
if (volumetricfog != null)
     sbvolumetricfog = new StringBuilder(volumetricfog, 1024);
StringBuilder sbnew_speed1 = null;
if (new_speed1 != null)
     sbnew_speed1 = new StringBuilder(new_speed1, 1024);
StringBuilder sbnew_speed2 = null;
if (new_speed2 != null)
     sbnew_speed2 = new StringBuilder(new_speed2, 1024);

SafeNativeMethods.mwle_fnVolumetricFog_SetFogModulation(sbvolumetricfog, new_strenght, sbnew_speed1, sbnew_speed2);
}
/// <summary>
/// Attaches an object to this one.
///       @param obj The scene object to attach to us
///       @return true if successful, false if failed. This function will fail if the object passed 
///       is invalid or is not located directly above and within RayLength of this shape.)
/// 
/// </summary>

public bool fnWalkableShape_attachObject (string walkableshape, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWalkableShape_attachObject'" + string.Format("\"{0}\" \"{1}\" ",walkableshape,obj));
StringBuilder sbwalkableshape = null;
if (walkableshape != null)
     sbwalkableshape = new StringBuilder(walkableshape, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnWalkableShape_attachObject(sbwalkableshape, sbobj)>=1;
}
/// <summary>
/// Detaches all attached objects. Note: if UseAutoAttach is true when this is called, all of
///        the objects may be re-attached on the next tick.
///       @tsexample
///          // Dump all riders
///          %attachableObj.UseAutoAttach = false
///          %attachableObj.detachAll(); = false
///       @endtsexample)
/// 
/// </summary>

public void fnWalkableShape_detachAll (string walkableshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWalkableShape_detachAll'" + string.Format("\"{0}\" ",walkableshape));
StringBuilder sbwalkableshape = null;
if (walkableshape != null)
     sbwalkableshape = new StringBuilder(walkableshape, 1024);

SafeNativeMethods.mwle_fnWalkableShape_detachAll(sbwalkableshape);
}
/// <summary>
/// Detaches an object from this one.
///       @param obj The scene object to be detached
///       @return true if successful, false if failed. This function will fail if the object passed 
///       is invalid or is not currently attached to this shape.)
/// 
/// </summary>

public bool fnWalkableShape_detachObject (string walkableshape, string obj)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWalkableShape_detachObject'" + string.Format("\"{0}\" \"{1}\" ",walkableshape,obj));
StringBuilder sbwalkableshape = null;
if (walkableshape != null)
     sbwalkableshape = new StringBuilder(walkableshape, 1024);
StringBuilder sbobj = null;
if (obj != null)
     sbobj = new StringBuilder(obj, 1024);

return  SafeNativeMethods.mwle_fnWalkableShape_detachObject(sbwalkableshape, sbobj)>=1;
}
/// <summary>
/// Returns the attachment at the passed index value.)
/// 
/// </summary>

public string fnWalkableShape_getAttachment (string walkableshape, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWalkableShape_getAttachment'" + string.Format("\"{0}\" \"{1}\" ",walkableshape,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbwalkableshape = null;
if (walkableshape != null)
     sbwalkableshape = new StringBuilder(walkableshape, 1024);

SafeNativeMethods.mwle_fnWalkableShape_getAttachment(sbwalkableshape, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Returns the number of objects that are currently attached.)
/// 
/// </summary>

public int fnWalkableShape_getNumAttachments (string walkableshape)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWalkableShape_getNumAttachments'" + string.Format("\"{0}\" ",walkableshape));
StringBuilder sbwalkableshape = null;
if (walkableshape != null)
     sbwalkableshape = new StringBuilder(walkableshape, 1024);

return  SafeNativeMethods.mwle_fnWalkableShape_getNumAttachments(sbwalkableshape);
}
/// <summary>
/// @brief Get the number of wheels on this vehicle.
///    @return the number of wheels (equal to the number of hub nodes defined in the model) )
/// 
/// </summary>

public int fnWheeledVehicle_getWheelCount (string wheeledvehicle)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWheeledVehicle_getWheelCount'" + string.Format("\"{0}\" ",wheeledvehicle));
StringBuilder sbwheeledvehicle = null;
if (wheeledvehicle != null)
     sbwheeledvehicle = new StringBuilder(wheeledvehicle, 1024);

return  SafeNativeMethods.mwle_fnWheeledVehicle_getWheelCount(sbwheeledvehicle);
}
/// <summary>
/// @brief Set whether the wheel is powered (has torque applied from the engine).
///    A rear wheel drive car for example would set the front wheels to false, 
///    and the rear wheels to true.
///    @param wheel index of the wheel to set (hub node #)
///    @param powered flag indicating whether to power the wheel or not
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnWheeledVehicle_setWheelPowered (string wheeledvehicle, int wheel, bool powered)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWheeledVehicle_setWheelPowered'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",wheeledvehicle,wheel,powered));
StringBuilder sbwheeledvehicle = null;
if (wheeledvehicle != null)
     sbwheeledvehicle = new StringBuilder(wheeledvehicle, 1024);

return  SafeNativeMethods.mwle_fnWheeledVehicle_setWheelPowered(sbwheeledvehicle, wheel, powered)>=1;
}
/// <summary>
/// @brief Set the WheeledVehicleSpring datablock for this wheel.
///    @param wheel index of the wheel to set (hub node #)
///    @param spring WheeledVehicleSpring datablock
///    @return true if successful, false if failed
///    @tsexample
///    %obj.setWheelSpring( 0, FrontSpring );
///    @endtsexample )
/// 
/// </summary>

public bool fnWheeledVehicle_setWheelSpring (string wheeledvehicle, int wheel, string spring)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWheeledVehicle_setWheelSpring'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",wheeledvehicle,wheel,spring));
StringBuilder sbwheeledvehicle = null;
if (wheeledvehicle != null)
     sbwheeledvehicle = new StringBuilder(wheeledvehicle, 1024);
StringBuilder sbspring = null;
if (spring != null)
     sbspring = new StringBuilder(spring, 1024);

return  SafeNativeMethods.mwle_fnWheeledVehicle_setWheelSpring(sbwheeledvehicle, wheel, sbspring)>=1;
}
/// <summary>
/// @brief Set how much the wheel is affected by steering.
///    The steering factor controls how much the wheel is rotated by the vehicle 
///    steering. For example, most cars would have their front wheels set to 1.0, 
///    and their rear wheels set to 0 since only the front wheels should turn.
///    Negative values will turn the wheel in the opposite direction to the steering 
///    angle.
///    @param wheel index of the wheel to set (hub node #)
///    @param steering steering factor from -1 (full inverse) to 1 (full)
///    @return true if successful, false if failed )
/// 
/// </summary>

public bool fnWheeledVehicle_setWheelSteering (string wheeledvehicle, int wheel, float steering)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWheeledVehicle_setWheelSteering'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",wheeledvehicle,wheel,steering));
StringBuilder sbwheeledvehicle = null;
if (wheeledvehicle != null)
     sbwheeledvehicle = new StringBuilder(wheeledvehicle, 1024);

return  SafeNativeMethods.mwle_fnWheeledVehicle_setWheelSteering(sbwheeledvehicle, wheel, steering)>=1;
}
/// <summary>
/// @brief Set the WheeledVehicleTire datablock for this wheel.
///    @param wheel index of the wheel to set (hub node #)
///    @param tire WheeledVehicleTire datablock
///    @return true if successful, false if failed
///    @tsexample
///    %obj.setWheelTire( 0, FrontTire );
///    @endtsexample )
/// 
/// </summary>

public bool fnWheeledVehicle_setWheelTire (string wheeledvehicle, int wheel, string tire)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWheeledVehicle_setWheelTire'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",wheeledvehicle,wheel,tire));
StringBuilder sbwheeledvehicle = null;
if (wheeledvehicle != null)
     sbwheeledvehicle = new StringBuilder(wheeledvehicle, 1024);
StringBuilder sbtire = null;
if (tire != null)
     sbtire = new StringBuilder(tire, 1024);

return  SafeNativeMethods.mwle_fnWheeledVehicle_setWheelTire(sbwheeledvehicle, wheel, sbtire)>=1;
}
/// <summary>
/// Create a ConvexShape from the given polyhedral object. )
/// 
/// </summary>

public string fnWorldEditor_createConvexShapeFrom (string worldeditor, string polyObject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_createConvexShapeFrom'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,polyObject));
var returnbuff = new StringBuilder(1024);
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbpolyObject = null;
if (polyObject != null)
     sbpolyObject = new StringBuilder(polyObject, 1024);

SafeNativeMethods.mwle_fnWorldEditor_createConvexShapeFrom(sbworldeditor, sbpolyObject, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Grab the geometry from @a geometryProvider, create a @a className object, and assign it the extracted geometry. )
/// 
/// </summary>

public string fnWorldEditor_createPolyhedralObject (string worldeditor, string className, string geometryProvider)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_createPolyhedralObject'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",worldeditor,className,geometryProvider));
var returnbuff = new StringBuilder(1024);
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sbclassName = null;
if (className != null)
     sbclassName = new StringBuilder(className, 1024);
StringBuilder sbgeometryProvider = null;
if (geometryProvider != null)
     sbgeometryProvider = new StringBuilder(geometryProvider, 1024);

SafeNativeMethods.mwle_fnWorldEditor_createPolyhedralObject(sbworldeditor, sbclassName, sbgeometryProvider, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Get the soft snap alignment. )
/// 
/// </summary>

public int fnWorldEditor_getSoftSnapAlignment (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_getSoftSnapAlignment'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fnWorldEditor_getSoftSnapAlignment(sbworldeditor);
}
/// <summary>
/// Get the terrain snap alignment.  )
/// 
/// </summary>

public int fnWorldEditor_getTerrainSnapAlignment (string worldeditor)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_getTerrainSnapAlignment'" + string.Format("\"{0}\" ",worldeditor));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

return  SafeNativeMethods.mwle_fnWorldEditor_getTerrainSnapAlignment(sbworldeditor);
}
/// <summary>
/// ( WorldEditor, ignoreObjClass, void, 3, 0, (string class_name, ...))
/// 
/// </summary>

public void fnWorldEditor_ignoreObjClass (string worldeditor, string a2, string a3, string a4, string a5, string a6, string a7, string a8, string a9, string a10, string a11, string a12, string a13, string a14, string a15, string a16, string a17, string a18, string a19)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_ignoreObjClass'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" \"{4}\" \"{5}\" \"{6}\" \"{7}\" \"{8}\" \"{9}\" \"{10}\" \"{11}\" \"{12}\" \"{13}\" \"{14}\" \"{15}\" \"{16}\" \"{17}\" \"{18}\" ",worldeditor,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);
StringBuilder sba4 = null;
if (a4 != null)
     sba4 = new StringBuilder(a4, 1024);
StringBuilder sba5 = null;
if (a5 != null)
     sba5 = new StringBuilder(a5, 1024);
StringBuilder sba6 = null;
if (a6 != null)
     sba6 = new StringBuilder(a6, 1024);
StringBuilder sba7 = null;
if (a7 != null)
     sba7 = new StringBuilder(a7, 1024);
StringBuilder sba8 = null;
if (a8 != null)
     sba8 = new StringBuilder(a8, 1024);
StringBuilder sba9 = null;
if (a9 != null)
     sba9 = new StringBuilder(a9, 1024);
StringBuilder sba10 = null;
if (a10 != null)
     sba10 = new StringBuilder(a10, 1024);
StringBuilder sba11 = null;
if (a11 != null)
     sba11 = new StringBuilder(a11, 1024);
StringBuilder sba12 = null;
if (a12 != null)
     sba12 = new StringBuilder(a12, 1024);
StringBuilder sba13 = null;
if (a13 != null)
     sba13 = new StringBuilder(a13, 1024);
StringBuilder sba14 = null;
if (a14 != null)
     sba14 = new StringBuilder(a14, 1024);
StringBuilder sba15 = null;
if (a15 != null)
     sba15 = new StringBuilder(a15, 1024);
StringBuilder sba16 = null;
if (a16 != null)
     sba16 = new StringBuilder(a16, 1024);
StringBuilder sba17 = null;
if (a17 != null)
     sba17 = new StringBuilder(a17, 1024);
StringBuilder sba18 = null;
if (a18 != null)
     sba18 = new StringBuilder(a18, 1024);
StringBuilder sba19 = null;
if (a19 != null)
     sba19 = new StringBuilder(a19, 1024);

SafeNativeMethods.mwle_fnWorldEditor_ignoreObjClass(sbworldeditor, sba2, sba3, sba4, sba5, sba6, sba7, sba8, sba9, sba10, sba11, sba12, sba13, sba14, sba15, sba16, sba17, sba18, sba19);
}
/// <summary>
/// Set the soft snap alignment. )
/// 
/// </summary>

public void fnWorldEditor_setSoftSnapAlignment (string worldeditor, int type)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_setSoftSnapAlignment'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,type));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fnWorldEditor_setSoftSnapAlignment(sbworldeditor, type);
}
/// <summary>
/// Set the terrain snap alignment. )
/// 
/// </summary>

public void fnWorldEditor_setTerrainSnapAlignment (string worldeditor, int alignment)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditor_setTerrainSnapAlignment'" + string.Format("\"{0}\" \"{1}\" ",worldeditor,alignment));
StringBuilder sbworldeditor = null;
if (worldeditor != null)
     sbworldeditor = new StringBuilder(worldeditor, 1024);

SafeNativeMethods.mwle_fnWorldEditor_setTerrainSnapAlignment(sbworldeditor, alignment);
}
/// <summary>
/// ( WorldEditorSelection, containsGlobalBounds, bool, 2, 2, () - True if an object with global bounds is contained in the selection. )
/// 
/// </summary>

public bool fnWorldEditorSelection_containsGlobalBounds (string worldeditorselection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_containsGlobalBounds'" + string.Format("\"{0}\" ",worldeditorselection));
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);

return  SafeNativeMethods.mwle_fnWorldEditorSelection_containsGlobalBounds(sbworldeditorselection)>=1;
}
/// <summary>
/// ( WorldEditorSelection, getBoxCentroid, const char*, 2, 2, () - Return the center of the bounding box around the selection. )
/// 
/// </summary>

public string fnWorldEditorSelection_getBoxCentroid (string worldeditorselection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_getBoxCentroid'" + string.Format("\"{0}\" ",worldeditorselection));
var returnbuff = new StringBuilder(16384);
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);

SafeNativeMethods.mwle_fnWorldEditorSelection_getBoxCentroid(sbworldeditorselection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( WorldEditorSelection, getCentroid, const char*, 2, 2, () - Return the median of all object positions in the selection. )
/// 
/// </summary>

public string fnWorldEditorSelection_getCentroid (string worldeditorselection)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_getCentroid'" + string.Format("\"{0}\" ",worldeditorselection));
var returnbuff = new StringBuilder(16384);
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);

SafeNativeMethods.mwle_fnWorldEditorSelection_getCentroid(sbworldeditorselection, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// ( WorldEditorSelection, offset, void, 3, 4, ( vector delta, float gridSnap=0 ) - Move all objects in the selection by the given delta. )
/// 
/// </summary>

public void fnWorldEditorSelection_offset (string worldeditorselection, string a2, string a3)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_offset'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",worldeditorselection,a2,a3));
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);
StringBuilder sba3 = null;
if (a3 != null)
     sba3 = new StringBuilder(a3, 1024);

SafeNativeMethods.mwle_fnWorldEditorSelection_offset(sbworldeditorselection, sba2, sba3);
}
/// <summary>
/// ( WorldEditorSelection, subtract, void, 3, 3, ( SimSet ) - Remove all objects in the given set from this selection. )
/// 
/// </summary>

public void fnWorldEditorSelection_subtract (string worldeditorselection, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_subtract'" + string.Format("\"{0}\" \"{1}\" ",worldeditorselection,a2));
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnWorldEditorSelection_subtract(sbworldeditorselection, sba2);
}
/// <summary>
/// ( WorldEditorSelection, union, void, 3, 3, ( SimSet set ) - Add all objects in the given set to this selection. )
/// 
/// </summary>

public void fnWorldEditorSelection_union (string worldeditorselection, string a2)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnWorldEditorSelection_union'" + string.Format("\"{0}\" \"{1}\" ",worldeditorselection,a2));
StringBuilder sbworldeditorselection = null;
if (worldeditorselection != null)
     sbworldeditorselection = new StringBuilder(worldeditorselection, 1024);
StringBuilder sba2 = null;
if (a2 != null)
     sba2 = new StringBuilder(a2, 1024);

SafeNativeMethods.mwle_fnWorldEditorSelection_union(sbworldeditorselection, sba2);
}
/// <summary>
/// @brief Add a file to the zip archive
///    
///    @param filename The path and name of the file to add to the zip archive.
///    @param pathInZip The path and name to be given to the file within the zip archive.
///    @param replace If a file already exists within the zip archive at the same location as this 
///    new file, this parameter indicates if it should be replaced.  By default, it will be replaced.
///    @return True if the file was successfully added to the zip archive.)
/// 
/// </summary>

public bool fnZipObject_addFile (string zipobject, string filename, string pathInZip, bool replace)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_addFile'" + string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}\" ",zipobject,filename,pathInZip,replace));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbpathInZip = null;
if (pathInZip != null)
     sbpathInZip = new StringBuilder(pathInZip, 1024);

return  SafeNativeMethods.mwle_fnZipObject_addFile(sbzipobject, sbfilename, sbpathInZip, replace)>=1;
}
/// <summary>
/// @brief Close an already opened zip archive.
///    @see openArchive())
/// 
/// </summary>

public void fnZipObject_closeArchive (string zipobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_closeArchive'" + string.Format("\"{0}\" ",zipobject));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);

SafeNativeMethods.mwle_fnZipObject_closeArchive(sbzipobject);
}
/// <summary>
/// @brief Close a previously opened file within the zip archive.
///    @param stream The StreamObject of a previously opened file within the zip archive.
///    @see openFileForRead()
///    @see openFileForWrite())
/// 
/// </summary>

public void fnZipObject_closeFile (string zipobject, string stream)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_closeFile'" + string.Format("\"{0}\" \"{1}\" ",zipobject,stream));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbstream = null;
if (stream != null)
     sbstream = new StringBuilder(stream, 1024);

SafeNativeMethods.mwle_fnZipObject_closeFile(sbzipobject, sbstream);
}
/// <summary>
/// @brief Deleted the given file from the zip archive
///    @param pathInZip The path and name of the file to be deleted from the zip archive.
///    @return True of the file was successfully deleted.
/// 
///    @note Files that have been deleted from the archive will still show up with a 
///    getFileEntryCount() until you close the archive.  If you need to have the file 
///    count up to date with only valid files within the archive, you could close and then 
///    open the archive again.
/// 
///    @see getFileEntryCount()
///    @see closeArchive()
///    @see openArchive())
/// 
/// </summary>

public bool fnZipObject_deleteFile (string zipobject, string pathInZip)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_deleteFile'" + string.Format("\"{0}\" \"{1}\" ",zipobject,pathInZip));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbpathInZip = null;
if (pathInZip != null)
     sbpathInZip = new StringBuilder(pathInZip, 1024);

return  SafeNativeMethods.mwle_fnZipObject_deleteFile(sbzipobject, sbpathInZip)>=1;
}
/// <summary>
/// @brief Extact a file from the zip archive and save it to the requested location.
///    @param pathInZip The path and name of the file to be extracted within the zip archive.
///    @param filename The path and name to give the extracted file.
///    @return True if the file was successfully extracted.)
/// 
/// </summary>

public bool fnZipObject_extractFile (string zipobject, string pathInZip, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_extractFile'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",zipobject,pathInZip,filename));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbpathInZip = null;
if (pathInZip != null)
     sbpathInZip = new StringBuilder(pathInZip, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

return  SafeNativeMethods.mwle_fnZipObject_extractFile(sbzipobject, sbpathInZip, sbfilename)>=1;
}
/// <summary>
/// @brief Get information on the requested file within the zip archive.
/// 
///    This methods provides five different pieces of information for the requested file:
///    ul>li>filename - The path and name of the file within the zip archive/li>
///    li>uncompressed size/li>
///    li>compressed size/li>
///    li>compression method/li>
///    li>CRC32/li>/ul>
/// 
///    Use getFileEntryCount() to obtain the total number of files within the archive.
/// 
///    @param index The index of the file within the zip archive.  Use getFileEntryCount() to determine the number of files.
///    @return A tab delimited list of information on the requested file, or an empty string if the file could not be found.
/// 
///    @see getFileEntryCount())
/// 
/// </summary>

public string fnZipObject_getFileEntry (string zipobject, int index)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_getFileEntry'" + string.Format("\"{0}\" \"{1}\" ",zipobject,index));
var returnbuff = new StringBuilder(1024);
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);

SafeNativeMethods.mwle_fnZipObject_getFileEntry(sbzipobject, index, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Get the number of files within the zip archive.
/// 
///    Use getFileEntry() to retrive information on each file within the archive.
/// 
///    @return The number of files within the zip archive.
/// 
///    @note The returned count will include any files that have been deleted from 
///    the archive using deleteFile().  To clear out all deleted files, you could 
///    close and then open the archive again.
/// 
///    @see getFileEntry()
///    @see closeArchive()
///    @see openArchive())
/// 
/// </summary>

public int fnZipObject_getFileEntryCount (string zipobject)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_getFileEntryCount'" + string.Format("\"{0}\" ",zipobject));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);

return  SafeNativeMethods.mwle_fnZipObject_getFileEntryCount(sbzipobject);
}
/// <summary>
/// read ),
///    @brief Open a zip archive for manipulation.
/// 
///    Once a zip archive is opened use the various ZipObject methods for 
///    working with the files within the archive.  Be sure to close the archive when 
///    you are done with it.
/// 
///    @param filename The path and file name of the zip archive to open.
///    @param accessMode One of read, write or readwrite
/// 
///    @return True is the archive was successfully opened.
///    
///    @note If you wish to make any changes to the archive, be sure to open it 
///    with a write or readwrite access mode.
/// 
///    @see closeArchive())
/// 
/// </summary>

public bool fnZipObject_openArchive (string zipobject, string filename, string accessMode)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_openArchive'" + string.Format("\"{0}\" \"{1}\" \"{2}\" ",zipobject,filename,accessMode));
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);
StringBuilder sbaccessMode = null;
if (accessMode != null)
     sbaccessMode = new StringBuilder(accessMode, 1024);

return  SafeNativeMethods.mwle_fnZipObject_openArchive(sbzipobject, sbfilename, sbaccessMode)>=1;
}
/// <summary>
/// @brief Open a file within the zip archive for reading.
/// 
///    Be sure to close the file when you are done with it.
/// 
///    @param filename The path and name of the file to open within the zip archive.
/// 
///    @return A standard StreamObject is returned for working with the file.
///    @note You must first open the zip archive before working with files within it.
/// 
///    @see closeFile()
///    @see openArchive())
/// 
/// </summary>

public string fnZipObject_openFileForRead (string zipobject, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_openFileForRead'" + string.Format("\"{0}\" \"{1}\" ",zipobject,filename));
var returnbuff = new StringBuilder(1024);
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnZipObject_openFileForRead(sbzipobject, sbfilename, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// @brief Open a file within the zip archive for writing to.
///    
///    Be sure to close the file when you are done with it.
/// 
///    @param filename The path and name of the file to open within the zip archive.
/// 
///    @return A standard StreamObject is returned for working with the file.
///    @note You must first open the zip archive before working with files within it.
/// 
///    @see closeFile()
///    @see openArchive())
/// 
/// </summary>

public string fnZipObject_openFileForWrite (string zipobject, string filename)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZipObject_openFileForWrite'" + string.Format("\"{0}\" \"{1}\" ",zipobject,filename));
var returnbuff = new StringBuilder(1024);
StringBuilder sbzipobject = null;
if (zipobject != null)
     sbzipobject = new StringBuilder(zipobject, 1024);
StringBuilder sbfilename = null;
if (filename != null)
     sbfilename = new StringBuilder(filename, 1024);

SafeNativeMethods.mwle_fnZipObject_openFileForWrite(sbzipobject, sbfilename, returnbuff);
return returnbuff.ToString();

}
/// <summary>
/// Dump a list of all objects assigned to the zone to the console as well as a list 
///    of all connected zone spaces.
///    @param updateFirst Whether to update the contents of the zone before dumping.  Since zoning states of 
///       objects are updated on demand, the zone contents can be outdated. )
/// 
/// </summary>

public void fnZone_dumpZoneState (string zone, bool updateFirst)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZone_dumpZoneState'" + string.Format("\"{0}\" \"{1}\" ",zone,updateFirst));
StringBuilder sbzone = null;
if (zone != null)
     sbzone = new StringBuilder(zone, 1024);

SafeNativeMethods.mwle_fnZone_dumpZoneState(sbzone, updateFirst);
}
/// <summary>
/// Get the unique numeric ID of the zone in its scene.
///    @return The ID of the zone. )
/// 
/// </summary>

public int fnZone_getZoneId (string zone)
{
if(Debugging)
System.Console.WriteLine("----------------->Extern Call 'fnZone_getZoneId'" + string.Format("\"{0}\" ",zone));
StringBuilder sbzone = null;
if (zone != null)
     sbzone = new StringBuilder(zone, 1024);

return  SafeNativeMethods.mwle_fnZone_getZoneId(sbzone);
}
	}
}